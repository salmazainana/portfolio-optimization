import numpy
import types
import mosek

def _():
  import types

  class Enum:
    @staticmethod
    def __inst(c,name):
      o = c()
      o.name  = name
      o.value = len(c.__members__)
      c.__members__.append(o)
      setattr(c, name, o)

    @classmethod
    def fromInt(c,value):
      return c.members[value]

    @staticmethod
    def new(name,membernames):
      members = []
      c = type(name, (Enum,),{ '__members__' : members })
      for n in membernames:
        Enum.__inst(c,n)
      return c
    @classmethod
    def members(c):
      return iter(c.__members__)

    def __str__(self):
      return self.__class__.__name__ + "." + self.name
    def __repr__(self):
      return self.__class__.__name__ + "." + self.name
  return Enum

class _monty:
  Enum = _()
  @staticmethod
  def deduceShape(l,dim):
    def _deduceShape(l,dim):
      if dim > 1:
        shplst = [ _deduceShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          shplst[0].append(len(l))
          return shplst[0]
        else:
          raise TypeError("Irregular array shape")
      else:
        return [len(dim)]
    return tuple(reversed(_deduceShape(l,dim)))
  @staticmethod
  def checkShape(l,dim):
    def _checkShape(l,dim):
      if dim > 1:
        shplst = [ _checkShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          pass
        else:
          raise TypeError("Irregular array shape")
        return len(l)
      else:
        try:
          return len(l)
        except TypeError:
          raise TypeError("Wrong or irregular array shape")
    _checkShape(l,dim)
    return dim

  @staticmethod
  def initJaggedArray(data, nd):
    dims = []
    d = data
    for i in range(nd):
      dims.append(len(d))
      d = d[0]

    res = numpy.zeros(dims,dtype=object)
    res.__setitem__(tuple([ slice(d) for d in dims ]), data)

    return res


  @staticmethod
  def makeJaggedArray(src,ndims,dtype):
    if src is None:
      return None
    elif len(ndims) == 1:
      if ndims[0] == 1:
        r = numpy.zeros((len(src),),dtype=dtype)
        r[:] = src
      else:
        d = _monty.deduceDims(src,ndims[0])
        r = numpy.zeros(d,dtype=dtype)
        r.__setitem__(tuple([slice(None)]*ndims[0]),src) # basically: r[:,...,:] = src
      return r
    elif ndims[0] == 1:
      r = numpy.zeros((len(src),),dtype=numpy.dtype(object))
      # Note: This is a bit tricky to do reliably with numpy as it
      # tends to think we are dealing with multidimensional arrays and
      # explode
      for i,s in enumerate(src):
        r[i] = _monty.makeJaggedArray(s,ndims[1:],dtype)

      #r[:] = [ _monty.makeJaggedArray(s,ndims[1:],dtype) for s in src ]
      return r
    else:
      d = _monty.deduceDims(src,ndims[0])
      def _(src,nd):
        if nd == 0:
          return _monty.makeJaggedArray(src)
        else:
          return [ _(s,nd-1) for s in src ]

      r = numpy.zeros(d,dtype=numpy.dtype(object))
      r.__setitem__(tuple([slice(None)]*ndims[0]),_(src,ndims[0])) # basically: r[:,...,:] = convert(src)
      return r

  @staticmethod
  def copyArray(src,dst,dim):
    if dim == 1:
      src[:] = dst[:]
    else:
      for i in range(len(src)):
        _monty.copyArray(src[i],dst[i],dim-1)
  @staticmethod
  def arg_match_sloppy_array(v,elmmatch,dim,l=None):
    if dim == 0:
      elmmatch(v)
    elif dim == 1:
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      for e in v:
        if not elmmatch(e): return False
      return True
    elif isinstance(v,list) or isinstance(v,numpy.ndarray):
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      elif not (isinstance(v[0],list) or isinstance(v[0],numpy.ndarray)): return False

      top_len = len(v[0])
      for e in v:
        if not _monty.arg_match_sloppy_array(e,elmmatch,dim-1,top_len): return False
      return True
    else:
      return False

del _

mosek_fusion_RelationKey=_monty.Enum.new('RelationKey',['EqualsTo','LessThan','GreaterThan','IsFree','InRange'])
mosek_fusion_PSDKey=_monty.Enum.new('PSDKey',['IsSymPSD','IsTrilPSD'])
mosek_fusion_QConeKey=_monty.Enum.new('QConeKey',['InQCone','InRotatedQCone','InPExpCone','InPPowCone','InDExpCone','InDPowCone','InPGeoMeanCone','InDGeoMeanCone','Positive','Negative','Unbounded','Zero','InPSDCone','InSVecPSDCone'])
mosek_fusion_ObjectiveSense=_monty.Enum.new('ObjectiveSense',['Undefined','Minimize','Maximize'])
mosek_fusion_SolutionStatus=_monty.Enum.new('SolutionStatus',['Undefined','Unknown','Optimal','Feasible','Certificate','IllposedCert'])
mosek_fusion_AccSolutionStatus=_monty.Enum.new('AccSolutionStatus',['Anything','Optimal','Feasible','Certificate'])
mosek_fusion_ProblemStatus=_monty.Enum.new('ProblemStatus',['Unknown','PrimalAndDualFeasible','PrimalFeasible','DualFeasible','PrimalInfeasible','DualInfeasible','PrimalAndDualInfeasible','IllPosed','PrimalInfeasibleOrUnbounded'])
mosek_fusion_SolverStatus=_monty.Enum.new('SolverStatus',['OK','Error','LostRace'])
mosek_fusion_SolutionType=_monty.Enum.new('SolutionType',['Default','Basic','Interior','Integer'])
mosek_fusion_StatusKey=_monty.Enum.new('StatusKey',['Unknown','Basic','SuperBasic','OnBound','Infinity'])
mosek_fusion_DJCDomainType=_monty.Enum.new('DJCDomainType',['EqualTo','LessThan','GreaterThan','IsFree','InRange','InQCone','InRotatedQCone','InPExpCone','InPPowCone','InDExpCone','InDPowCone','InOneNormCone','InInfNormCone','InPGeoMeanCone','InDGeoMeanCone','InPSDCone'])
#BEFORE CLASS
def __mk_mosek_fusion_ExprDomain():
 class ExprDomain:
  def toDJCTerm(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDomain.toDJCTerm()

    Description
    -----------

    Convert object into a disjunctive constraint term 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprDomain._match_toDJCTerm_(*args):
      return self._toDJCTerm_(*args)
    elif mosek_fusion_ExprDomain._match_alt_toDJCTerm_(*args):
      return self._toDJCTerm_alt_(*args)
    else:
      raise ValueError('Invalid argument list toDJCTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDomain.toDJCTerm()')
  def __repr__(self): return 'mosek.fusion.ExprDomain'
  @staticmethod
  def _match_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  def _toDJCTerm_alt_(self,):
    return self._toDJCTerm_()
  def _toDJCTerm_(self,):
   pass
 return ExprDomain
mosek_fusion_ExprDomain=__mk_mosek_fusion_ExprDomain()
del __mk_mosek_fusion_ExprDomain
#BEFORE CLASS
def __mk_mosek_fusion_Expression():
 class Expression:
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.getSize()

    Description
    -----------

    Return the total number of elements in the expression (the product of the dimensions). 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Expression._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_Expression._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getSize()')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    Evaluate the expression and push the result onto the work stack. 

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_Expression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def getDim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.getDim(int32)

    Description
    -----------

    Return the d'th dimension in the expression.

    Parameters
    ----------

    d : int32
    '''
    if False: pass
    elif mosek_fusion_Expression._match_getDim_I(*args):
      return self._getDim_I(*args)
    elif mosek_fusion_Expression._match_alt_getDim_I(*args):
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getDim(int32)')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.getShape()

    Description
    -----------

    Get the shape of the expression.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Expression._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_Expression._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getShape()')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.getND()

    Description
    -----------

    Return the number of dimensions in the expression.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Expression._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_Expression._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getND()')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.pick(array(int32,ndim=1))
      mosek.fusion.Expression.pick(array(int32,ndim=2))

    Description
    -----------

    Pick a number of elements from the expression.

    Parameters
    ----------

    indexes : array(int32,ndim=1)
    indexrows : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_Expression._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expression._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.pick(array(int32,ndim=1))\n\tmosek.fusion.Expression.pick(array(int32,ndim=2))')
  def getModel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.getModel()

    Description
    -----------

    Get the associated model.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Expression._match_getModel_(*args):
      return self._getModel_(*args)
    elif mosek_fusion_Expression._match_alt_getModel_(*args):
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getModel()')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.toString()

    Description
    -----------

    Return a string representation of the expression object.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Expression._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_Expression._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.toString()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.slice(int32,int32)
      mosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Get a slice of the expression.

    Parameters
    ----------

    first : int32
    firsta : array(int32,ndim=1)
    last : int32
    lasta : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Expression._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_Expression._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expression._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expression._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.slice(int32,int32)\n\tmosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expression.index(int32)
      mosek.fusion.Expression.index(array(int32,ndim=1))

    Description
    -----------

    Get a single element in the expression.

    Parameters
    ----------

    i : int32
    indexes : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Expression._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_Expression._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_Expression._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_Expression._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.index(int32)\n\tmosek.fusion.Expression.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Expression'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getDim_alt_I(self,_t__a_0):
    return self._getDim_I(numpy.int32(__a_0))
  def _getDim_I(self,_a_0):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
 return Expression
mosek_fusion_Expression=__mk_mosek_fusion_Expression()
del __mk_mosek_fusion_Expression
#BEFORE CLASS
def __mk_mosek_fusion_Variable():
 class Variable(mosek_fusion_Expression):
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.transpose()

    Description
    -----------

    Transpose the variable.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_Variable._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.transpose()')
  def diag(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.diag()
      mosek.fusion.Variable.diag(int32)

    Description
    -----------

    Return a diagonal of a square matrix. 

    Parameters
    ----------

    index : int32
        Index of the diagonal. Index 0 means the main diagonal, negative indices are below it and positive indices are above it. 
    '''
    if False: pass
    elif mosek_fusion_Variable._match_diag_(*args):
      return self._diag_(*args)
    elif mosek_fusion_Variable._match_alt_diag_(*args):
      return self._diag_alt_(*args)
    elif mosek_fusion_Variable._match_diag_I(*args):
      return self._diag_I(*args)
    elif mosek_fusion_Variable._match_alt_diag_I(*args):
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.diag()\n\tmosek.fusion.Variable.diag(int32)')
  def make_integer(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.make_integer()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_make_1integer_(*args):
      return self._make_1integer_(*args)
    elif mosek_fusion_Variable._match_alt_make_1integer_(*args):
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_integer()')
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.getSize()

    Description
    -----------

    Get the total number of elements in the variable. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_Variable._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getSize()')
  def asExpr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.asExpr()

    Description
    -----------

    Create an expression corresponding to the variable object.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_asExpr_(*args):
      return self._asExpr_(*args)
    elif mosek_fusion_Variable._match_alt_asExpr_(*args):
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.asExpr()')
  def values(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.values(int32,array(double,ndim=1),bool)

    Description
    -----------

    Return a generic nd-slice of the variable value when treated as an n-dimensional object 

    Parameters
    ----------

    offset : int32
        Offset into the target array. 
    primal : bool
        
    target : array(double,ndim=1)
        Result array. 
    '''
    if False: pass
    elif mosek_fusion_Variable._match_values_I_3DZ(*args):
      return self._values_I_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_I_3DZ(*args):
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.values(int32,array(double,ndim=1),bool)')
  def level(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.level()

    Description
    -----------

    
    Get the primal solution value of the variable.
            

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_level_(*args):
      return self._level_(*args)
    elif mosek_fusion_Variable._match_alt_level_(*args):
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.level()')
  def antidiag(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.antidiag()
      mosek.fusion.Variable.antidiag(int32)

    Description
    -----------

    Return an anti-diagonal of a square matrix. 

    Parameters
    ----------

    index : int32
        Index of the anti-diagonal. Index 0 means the main anti-diagonal, negative indices are below it and positive indices are above it. 
    '''
    if False: pass
    elif mosek_fusion_Variable._match_antidiag_(*args):
      return self._antidiag_(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_(*args):
      return self._antidiag_alt_(*args)
    elif mosek_fusion_Variable._match_antidiag_I(*args):
      return self._antidiag_I(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_I(*args):
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.antidiag()\n\tmosek.fusion.Variable.antidiag(int32)')
  def tril(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.tril()

    Description
    -----------

    Convert a square variable into a linear representation of the lower triangular part of the variable. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_tril_(*args):
      return self._tril_(*args)
    elif mosek_fusion_Variable._match_alt_tril_(*args):
      return self._tril_alt_(*args)
    else:
      raise ValueError('Invalid argument list tril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.tril()')
  def inst(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.inst(int32,array(int64,ndim=1))
      mosek.fusion.Variable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))

    Description
    -----------

    
    Get the linear identifiers for variable elements.
            

    Parameters
    ----------

    nativeidxs : array(int64,ndim=1)
    nioffset : int32
    offset : int32
        Offset into the `nindex` where we wish to receive the result.
    sparsity : array(int64,ndim=1)
    spoffset : int32
    '''
    if False: pass
    elif mosek_fusion_Variable._match_inst_I_3J(*args):
      return self._inst_I_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3J(*args):
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_Variable._match_inst_I_3JI_3J(*args):
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3JI_3J(*args):
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.getND()

    Description
    -----------

    Get the number of dimensions in the variable shape. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_Variable._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getND()')
  def setLevel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.setLevel(array(double,ndim=1))

    Description
    -----------

    Input solution values for this variable 

    Parameters
    ----------

    v : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Variable._match_setLevel__3D(*args):
      return self._setLevel__3D(*args)
    elif mosek_fusion_Variable._match_alt_setLevel__3D(*args):
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.setLevel(array(double,ndim=1))')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.toString()

    Description
    -----------

    Create a string representation of the variable. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_Variable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.toString()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.slice(int32,int32)
      mosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Get a multi-dimensional slice of the variable. 

    Parameters
    ----------

    first : int32
        The index from which the slice begins. 
    firsta : array(int32,ndim=1)
        The indices from which the slice of a multidimensional variable begins.
    last : int32
        The index after the last element of the slice. 
    lasta : array(int32,ndim=1)
        The indices after the last element of slice of a multidimensional variable.
    '''
    if False: pass
    elif mosek_fusion_Variable._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_Variable._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_Variable._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.slice(int32,int32)\n\tmosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def fromTril(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.fromTril(int32)

    Description
    -----------

    Convert from a linear representation of the lower triangular part of a square variable into a square variable. 

    Parameters
    ----------

    dim : int32
    '''
    if False: pass
    elif mosek_fusion_Variable._match_fromTril_I(*args):
      return self._fromTril_I(*args)
    elif mosek_fusion_Variable._match_alt_fromTril_I(*args):
      return self._fromTril_alt_I(*args)
    else:
      raise ValueError('Invalid argument list fromTril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.fromTril(int32)')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.getShape()

    Description
    -----------

    Get the variable shape. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_Variable._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getShape()')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.index(int32)
      mosek.fusion.Variable.index(array(int32,ndim=1))
      mosek.fusion.Variable.index(int32,int32)
      mosek.fusion.Variable.index(int32,int32,int32)

    Description
    -----------

    Return a single entry in the variable. 

    Parameters
    ----------

    i1 : int32
        Index in the first dimension of the element requested.
    i2 : int32
        Index in the second dimension of the element requested.
    i3 : int32
        Index in the third dimension of the element requested.
    idx : array(int32,ndim=1)
        List of indexes of the elements requested.
    '''
    if False: pass
    elif mosek_fusion_Variable._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_Variable._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_Variable._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_Variable._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    elif mosek_fusion_Variable._match_index_II(*args):
      return self._index_II(*args)
    elif mosek_fusion_Variable._match_alt_index_II(*args):
      return self._index_alt_II(*args)
    elif mosek_fusion_Variable._match_index_III(*args):
      return self._index_III(*args)
    elif mosek_fusion_Variable._match_alt_index_III(*args):
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.index(int32)\n\tmosek.fusion.Variable.index(array(int32,ndim=1))\n\tmosek.fusion.Variable.index(int32,int32)\n\tmosek.fusion.Variable.index(int32,int32,int32)')
  def numInst(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.numInst()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_numInst_(*args):
      return self._numInst_(*args)
    elif mosek_fusion_Variable._match_alt_numInst_(*args):
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.numInst()')
  def dual(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.dual()

    Description
    -----------

    
    Get the dual solution value of the variable.
            

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_dual_(*args):
      return self._dual_(*args)
    elif mosek_fusion_Variable._match_alt_dual_(*args):
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.dual()')
  def make_continuous(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.make_continuous()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_make_1continuous_(*args):
      return self._make_1continuous_(*args)
    elif mosek_fusion_Variable._match_alt_make_1continuous_(*args):
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_continuous()')
  def remove(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.remove()

    Description
    -----------

    Remove the variable from the model.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_remove_(*args):
      return self._remove_(*args)
    elif mosek_fusion_Variable._match_alt_remove_(*args):
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.remove()')
  def makeInteger(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.makeInteger()

    Description
    -----------

    Apply integrality constraints on the variable. Has no effect on elements of semidefinite matrix variables. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_makeInteger_(*args):
      return self._makeInteger_(*args)
    elif mosek_fusion_Variable._match_alt_makeInteger_(*args):
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeInteger()')
  def set_values(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.set_values(array(double,ndim=1),bool)

    Description
    -----------

    

    Parameters
    ----------

    primal : bool
    value : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Variable._match_set_1values__3DZ(*args):
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values__3DZ(*args):
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.set_values(array(double,ndim=1),bool)')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.pick(array(int32,ndim=1))
      mosek.fusion.Variable.pick(array(int32,ndim=2))
      mosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))
      mosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Create a one-dimensional variable by picking a list of indexes from this variable. 

    Parameters
    ----------

    i1 : array(int32,ndim=1)
        Index along the first dimension.
    i2 : array(int32,ndim=1)
        Index along the second dimension.
    i3 : array(int32,ndim=1)
        Index along the third dimension.
    idxs : array(int32,ndim=1)
        Indexes of the elements requested.
    midxs : array(int32,ndim=2)
        A sequence of multi-dimensional indexes of the elements requested.
    '''
    if False: pass
    elif mosek_fusion_Variable._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Variable._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I(*args):
      return self._pick__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I(*args):
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I_3I(*args):
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I_3I(*args):
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.pick(array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=2))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def makeContinuous(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.makeContinuous()

    Description
    -----------

    Drop integrality constraints on the variable, if any. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Variable._match_makeContinuous_(*args):
      return self._makeContinuous_(*args)
    elif mosek_fusion_Variable._match_alt_makeContinuous_(*args):
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeContinuous()')
  def reshape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Variable.reshape(array(int32,ndim=1))
      mosek.fusion.Variable.reshape(int32)
      mosek.fusion.Variable.reshape(int32,int32)
      mosek.fusion.Variable.reshape(int32,int32,int32)

    Description
    -----------

    Reshape the variable. The new shape must have the same total size as the current.

    Parameters
    ----------

    dim0 : int32
        First dimension of new shape
    dim1 : int32
        Second dimension of new shape
    dim2 : int32
        Third dimension of new shape
    shape : array(int32,ndim=1)
        The new shape.
    '''
    if False: pass
    elif mosek_fusion_Variable._match_reshape__3I(*args):
      return self._reshape__3I(*args)
    elif mosek_fusion_Variable._match_alt_reshape__3I(*args):
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_Variable._match_reshape_I(*args):
      return self._reshape_I(*args)
    elif mosek_fusion_Variable._match_alt_reshape_I(*args):
      return self._reshape_alt_I(*args)
    elif mosek_fusion_Variable._match_reshape_II(*args):
      return self._reshape_II(*args)
    elif mosek_fusion_Variable._match_alt_reshape_II(*args):
      return self._reshape_alt_II(*args)
    elif mosek_fusion_Variable._match_reshape_III(*args):
      return self._reshape_III(*args)
    elif mosek_fusion_Variable._match_alt_reshape_III(*args):
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.reshape(array(int32,ndim=1))\n\tmosek.fusion.Variable.reshape(int32)\n\tmosek.fusion.Variable.reshape(int32,int32)\n\tmosek.fusion.Variable.reshape(int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.Variable'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   pass
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_I__(_a_2) and __arg_match__3J__(_a_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match__3J__(_a_3))
  def _inst_alt_I_3JI_3J(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int64))
   _1_res = self._inst_I_3JI_3J(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _inst_I_3JI_3J(self,_a_0,_a_1,_a_2,_a_3):
   pass
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1))
  def _inst_alt_I_3J(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _1_res = self._inst_I_3J(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _inst_I_3J(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  def _setLevel_alt__3D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setLevel__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setLevel__3D(self,_a_0):
   pass
  @staticmethod
  def _match_fromTril_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_fromTril_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _fromTril_alt_I(self,_t__a_0):
    return self._fromTril_I(numpy.int32(__a_0))
  def _fromTril_I(self,_a_0):
   pass
  @staticmethod
  def _match_tril_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_tril_(*args):
    if len(args) != 0: return False
    return True
  def _tril_alt_(self,):
    return self._tril_()
  def _tril_(self,):
   pass
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _reshape_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._reshape_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _reshape_III(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _reshape_alt_II(self,_t__a_0,_t__a_1):
    return self._reshape_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _reshape_II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _reshape_alt_I(self,_t__a_0):
    return self._reshape_I(numpy.int32(__a_0))
  def _reshape_I(self,_a_0):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _reshape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._reshape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _reshape__3I(self,_a_0):
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Z__(_a_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Z__(_a_1))
  def _set_1values_alt__3DZ(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = self._set_1values__3DZ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _set_1values__3DZ(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3D__(_a_1) and __arg_match_Z__(_a_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match_Z__(_a_2))
  def _values_alt_I_3DZ(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = self._values_I_3DZ(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _values_I_3DZ(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   pass
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2))
  def _pick_alt__3I_3I_3I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I_3I_3I(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _pick_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I_3I(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   pass
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   pass
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _antidiag_alt_I(self,_t__a_0):
    return self._antidiag_I(numpy.int32(__a_0))
  def _antidiag_I(self,_a_0):
   pass
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   pass
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _diag_alt_I(self,_t__a_0):
    return self._diag_I(numpy.int32(__a_0))
  def _diag_I(self,_a_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   pass
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _index_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._index_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _index_III(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _index_alt_II(self,_t__a_0,_t__a_1):
    return self._index_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _index_II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
 return Variable
mosek_fusion_Variable=__mk_mosek_fusion_Variable()
del __mk_mosek_fusion_Variable
#BEFORE CLASS
def __mk_mosek_fusion_Parameter():
 class Parameter(mosek_fusion_Expression):
  def isSparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.isSparse()

    Description
    -----------

    Return whether the parameter has a sparsity pattern.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_isSparse_(*args):
      return self._isSparse_(*args)
    elif mosek_fusion_Parameter._match_alt_isSparse_(*args):
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.isSparse()')
  def getAllIndexes(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getAllIndexes(array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    dst : array(int32,ndim=1)
    ofs : int32
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getAllIndexes__3II(*args):
      return self._getAllIndexes__3II(*args)
    elif mosek_fusion_Parameter._match_alt_getAllIndexes__3II(*args):
      return self._getAllIndexes_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list getAllIndexes('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getAllIndexes(array(int32,ndim=1),int32)')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getShape()

    Description
    -----------

    Get the parameter shape

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_Parameter._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getShape()')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.pick(array(int32,ndim=1))
      mosek.fusion.Parameter.pick(array(int32,ndim=2))

    Description
    -----------

    

    Parameters
    ----------

    idxs : array(int32,ndim=1)
    midxs : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_Parameter._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Parameter._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_Parameter._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.pick(array(int32,ndim=1))\n\tmosek.fusion.Parameter.pick(array(int32,ndim=2))')
  def setValue(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.setValue(double)
      mosek.fusion.Parameter.setValue(array(double,ndim=1))
      mosek.fusion.Parameter.setValue(array(double,ndim=2))

    Description
    -----------

    Set the parameter values. 

    Parameters
    ----------

    value : double
        Set all parameter elements to this value.
    values : array(double,ndim=1)
        Set parameter elements to these values. The length of the array must match the size of the parameter. This form is valid no matter the shape of the parameter.
    values2 : array(double,ndim=2)
        Set parameter elements to these values. The shape must exactly match the shape of the two-dimensional parameter.
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_setValue_D(*args):
      return self._setValue_D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue_D(*args):
      return self._setValue_alt_D(*args)
    elif mosek_fusion_Parameter._match_setValue__3D(*args):
      return self._setValue__3D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue__3D(*args):
      return self._setValue_alt__3D(*args)
    elif mosek_fusion_Parameter._match_setValue__3_5D(*args):
      return self._setValue__3_5D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue__3_5D(*args):
      return self._setValue_alt__3_5D(*args)
    else:
      raise ValueError('Invalid argument list setValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.setValue(double)\n\tmosek.fusion.Parameter.setValue(array(double,ndim=1))\n\tmosek.fusion.Parameter.setValue(array(double,ndim=2))')
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getSize()

    Description
    -----------

    Get the total number of elements in the parameter

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_Parameter._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getSize()')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.transpose()

    Description
    -----------

    Transpose a one- or two-dimensional parameter.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_Parameter._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.transpose()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.slice(int32,int32)
      mosek.fusion.Parameter.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Take a slice of the parameter.

    Parameters
    ----------

    astart : array(int32,ndim=1)
        The first index in the parameter.
    astop : array(int32,ndim=1)
        The last-plus-one index in the parameter.
    start : int32
        The first index in a one-dimensional parameter.
    stop : int32
        The last-plus-one index in a one-dimensional parameter.
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_Parameter._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_Parameter._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Parameter._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.slice(int32,int32)\n\tmosek.fusion.Parameter.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getIndex(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getIndex(int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getIndex_I(*args):
      return self._getIndex_I(*args)
    elif mosek_fusion_Parameter._match_alt_getIndex_I(*args):
      return self._getIndex_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getIndex(int32)')
  def getValue(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getValue()

    Description
    -----------

    Get the current parameter values. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getValue_(*args):
      return self._getValue_(*args)
    elif mosek_fusion_Parameter._match_alt_getValue_(*args):
      return self._getValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list getValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getValue()')
  def reshape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.reshape(array(int32,ndim=1))

    Description
    -----------

    Reshape the parameter. The new shape must have the same size as the old.

    Parameters
    ----------

    dims : array(int32,ndim=1)
        The new shape
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_reshape__3I(*args):
      return self._reshape__3I(*args)
    elif mosek_fusion_Parameter._match_alt_reshape__3I(*args):
      return self._reshape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.reshape(array(int32,ndim=1))')
  def getNumNonzero(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getNumNonzero()

    Description
    -----------

    Get number of non-zero elements in the parameter. This means the number of elements in the sparsity pattern - *not* the number of numeric non-zeros.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getNumNonzero_(*args):
      return self._getNumNonzero_(*args)
    elif mosek_fusion_Parameter._match_alt_getNumNonzero_(*args):
      return self._getNumNonzero_alt_(*args)
    else:
      raise ValueError('Invalid argument list getNumNonzero('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getNumNonzero()')
  def getDim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getDim(int32)

    Description
    -----------

    Get the size of one dimension of the shape

    Parameters
    ----------

    i : int32
        The index of the dimension
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getDim_I(*args):
      return self._getDim_I(*args)
    elif mosek_fusion_Parameter._match_alt_getDim_I(*args):
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getDim(int32)')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getND()

    Description
    -----------

    Get the number of dimensions in the parameter shape

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_Parameter._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getND()')
  def asExpr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.asExpr()

    Description
    -----------

    Convert parameter to an expression

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Parameter._match_asExpr_(*args):
      return self._asExpr_(*args)
    elif mosek_fusion_Parameter._match_alt_asExpr_(*args):
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.asExpr()')
  def clone(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.clone(mosek.fusion.Model)

    Description
    -----------

    

    Parameters
    ----------

    m : mosek.fusion.Model
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_clone_Lmosek_4fusion_4Model_2(*args):
      return self._clone_Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_Parameter._match_alt_clone_Lmosek_4fusion_4Model_2(*args):
      return self._clone_alt_Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.clone(mosek.fusion.Model)')
  def getSp(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameter.getSp(array(int64,ndim=1),int32)

    Description
    -----------

    Return The sparsity pattern.

    Parameters
    ----------

    dest : array(int64,ndim=1)
    offset : int32
    '''
    if False: pass
    elif mosek_fusion_Parameter._match_getSp__3JI(*args):
      return self._getSp__3JI(*args)
    elif mosek_fusion_Parameter._match_alt_getSp__3JI(*args):
      return self._getSp_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list getSp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getSp(array(int64,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.Parameter'
  @staticmethod
  def _match_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_a_0))
  @staticmethod
  def _match_alt_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_a_0))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _getAllIndexes_alt__3II(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._getAllIndexes__3II(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getAllIndexes__3II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_getIndex_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getIndex_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getIndex_alt_I(self,_t__a_0):
    return self._getIndex_I(numpy.int32(__a_0))
  def _getIndex_I(self,_a_0):
   pass
  @staticmethod
  def _match_getSp__3JI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_getSp__3JI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match_I__(_a_1))
  def _getSp_alt__3JI(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._getSp__3JI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getSp__3JI(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getDim_alt_I(self,_t__a_0):
    return self._getDim_I(numpy.int32(__a_0))
  def _getDim_I(self,_a_0):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _reshape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._reshape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _reshape__3I(self,_a_0):
   pass
  @staticmethod
  def _match_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  def _getNumNonzero_alt_(self,):
    return self._getNumNonzero_()
  def _getNumNonzero_(self,):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
  @staticmethod
  def _match_getValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getValue_(*args):
    if len(args) != 0: return False
    return True
  def _getValue_alt_(self,):
    return self._getValue_()
  def _getValue_(self,):
   pass
  @staticmethod
  def _match_setValue__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_setValue__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  def _setValue_alt__3_5D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = self._setValue__3_5D(_a_0)
   return _1_res
  def _setValue__3_5D(self,_a_0):
   pass
  @staticmethod
  def _match_setValue__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_setValue__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  def _setValue_alt__3D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setValue__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setValue__3D(self,_a_0):
   pass
  @staticmethod
  def _match_setValue_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_setValue_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  def _setValue_alt_D(self,_t__a_0):
    return self._setValue_D(numpy.float64(__a_0))
  def _setValue_D(self,_a_0):
   pass
 return Parameter
mosek_fusion_Parameter=__mk_mosek_fusion_Parameter()
del __mk_mosek_fusion_Parameter
#BEFORE CLASS
def __mk_mosek_fusion_FusionException():
 class FusionException(Exception):
  __slots__ = ['_FusionException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionException.ctor(string)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.FusionException.toString()

    Description
    -----------

    Return the exception message. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_FusionException._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_FusionException._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionException.__new__(FusionException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionException
mosek_fusion_FusionException=__mk_mosek_fusion_FusionException()
del __mk_mosek_fusion_FusionException
#BEFORE CLASS
def __mk_mosek_fusion_SolutionError():
 class SolutionError(mosek_fusion_FusionException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionError.ctor()\n\tmosek.fusion.SolutionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SolutionError'
  @staticmethod
  def _ctor_():
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionException._ctor_init_S(self,"Solution is invalid or undefined")
  @staticmethod
  def _ctor_S(msg):
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionException._ctor_init_S(self,msg)
 return SolutionError
mosek_fusion_SolutionError=__mk_mosek_fusion_SolutionError()
del __mk_mosek_fusion_SolutionError
#BEFORE CLASS
def __mk_mosek_fusion_UnimplementedError():
 class UnimplementedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnimplementedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnimplementedError'
  @staticmethod
  def _ctor_S(msg):
    o = UnimplementedError.__new__(UnimplementedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnimplementedError
mosek_fusion_UnimplementedError=__mk_mosek_fusion_UnimplementedError()
del __mk_mosek_fusion_UnimplementedError
#BEFORE CLASS
def __mk_mosek_fusion_FatalError():
 class FatalError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FatalError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.FatalError'
  @staticmethod
  def _ctor_S(msg):
    o = FatalError.__new__(FatalError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return FatalError
mosek_fusion_FatalError=__mk_mosek_fusion_FatalError()
del __mk_mosek_fusion_FatalError
#BEFORE CLASS
def __mk_mosek_fusion_UnexpectedError():
 class UnexpectedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FusionException_2(*args):
      self._ctor_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnexpectedError.ctor(mosek.fusion.FusionException)\n\tmosek.fusion.UnexpectedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnexpectedError'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FusionException_2(e):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_Lmosek_4fusion_4FusionException_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FusionException_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FusionException_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FusionException_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FusionException_2(e)
  def _ctor_init_Lmosek_4fusion_4FusionException_2(self,e):
   Exception.__init__(self,e._toString_())
  @staticmethod
  def _ctor_S(msg):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnexpectedError
mosek_fusion_UnexpectedError=__mk_mosek_fusion_UnexpectedError()
del __mk_mosek_fusion_UnexpectedError
#BEFORE CLASS
def __mk_mosek_fusion_FusionRuntimeException():
 class FusionRuntimeException(Exception):
  __slots__ = ['_FusionRuntimeException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionRuntimeException.ctor(string)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.FusionRuntimeException.toString()

    Description
    -----------

    Return the exception message. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_FusionRuntimeException._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_FusionRuntimeException._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionRuntimeException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionRuntimeException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionRuntimeException.__new__(FusionRuntimeException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionRuntimeException
mosek_fusion_FusionRuntimeException=__mk_mosek_fusion_FusionRuntimeException()
del __mk_mosek_fusion_FusionRuntimeException
#BEFORE CLASS
def __mk_mosek_fusion_SparseFormatError():
 class SparseFormatError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SparseFormatError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SparseFormatError'
  @staticmethod
  def _ctor_S(msg):
    o = SparseFormatError.__new__(SparseFormatError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SparseFormatError
mosek_fusion_SparseFormatError=__mk_mosek_fusion_SparseFormatError()
del __mk_mosek_fusion_SparseFormatError
#BEFORE CLASS
def __mk_mosek_fusion_SliceError():
 class SliceError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SliceError.ctor()\n\tmosek.fusion.SliceError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SliceError'
  @staticmethod
  def _ctor_():
    o = SliceError.__new__(SliceError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Invalid slice range")
  @staticmethod
  def _ctor_S(msg):
    o = SliceError.__new__(SliceError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SliceError
mosek_fusion_SliceError=__mk_mosek_fusion_SliceError()
del __mk_mosek_fusion_SliceError
#BEFORE CLASS
def __mk_mosek_fusion_UpdateError():
 class UpdateError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UpdateError.ctor()\n\tmosek.fusion.UpdateError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UpdateError'
  @staticmethod
  def _ctor_():
    o = UpdateError.__new__(UpdateError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Cannot update parameterized item")
  @staticmethod
  def _ctor_S(msg):
    o = UpdateError.__new__(UpdateError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return UpdateError
mosek_fusion_UpdateError=__mk_mosek_fusion_UpdateError()
del __mk_mosek_fusion_UpdateError
#BEFORE CLASS
def __mk_mosek_fusion_SetDefinitionError():
 class SetDefinitionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SetDefinitionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SetDefinitionError'
  @staticmethod
  def _ctor_S(msg):
    o = SetDefinitionError.__new__(SetDefinitionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SetDefinitionError
mosek_fusion_SetDefinitionError=__mk_mosek_fusion_SetDefinitionError()
del __mk_mosek_fusion_SetDefinitionError
#BEFORE CLASS
def __mk_mosek_fusion_OptimizeError():
 class OptimizeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.OptimizeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.OptimizeError'
  @staticmethod
  def _ctor_S(msg):
    o = OptimizeError.__new__(OptimizeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return OptimizeError
mosek_fusion_OptimizeError=__mk_mosek_fusion_OptimizeError()
del __mk_mosek_fusion_OptimizeError
#BEFORE CLASS
def __mk_mosek_fusion_NameError():
 class NameError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NameError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.NameError'
  @staticmethod
  def _ctor_S(msg):
    o = NameError.__new__(NameError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return NameError
mosek_fusion_NameError=__mk_mosek_fusion_NameError()
del __mk_mosek_fusion_NameError
#BEFORE CLASS
def __mk_mosek_fusion_DeletionError():
 class DeletionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DeletionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DeletionError'
  @staticmethod
  def _ctor_S(msg):
    o = DeletionError.__new__(DeletionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DeletionError
mosek_fusion_DeletionError=__mk_mosek_fusion_DeletionError()
del __mk_mosek_fusion_DeletionError
#BEFORE CLASS
def __mk_mosek_fusion_ModelError():
 class ModelError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ModelError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ModelError'
  @staticmethod
  def _ctor_S(msg):
    o = ModelError.__new__(ModelError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ModelError
mosek_fusion_ModelError=__mk_mosek_fusion_ModelError()
del __mk_mosek_fusion_ModelError
#BEFORE CLASS
def __mk_mosek_fusion_MatrixError():
 class MatrixError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.MatrixError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.MatrixError'
  @staticmethod
  def _ctor_S(msg):
    o = MatrixError.__new__(MatrixError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return MatrixError
mosek_fusion_MatrixError=__mk_mosek_fusion_MatrixError()
del __mk_mosek_fusion_MatrixError
#BEFORE CLASS
def __mk_mosek_fusion_DimensionError():
 class DimensionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DimensionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DimensionError'
  @staticmethod
  def _ctor_S(msg):
    o = DimensionError.__new__(DimensionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DimensionError
mosek_fusion_DimensionError=__mk_mosek_fusion_DimensionError()
del __mk_mosek_fusion_DimensionError
#BEFORE CLASS
def __mk_mosek_fusion_LengthError():
 class LengthError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LengthError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.LengthError'
  @staticmethod
  def _ctor_S(msg):
    o = LengthError.__new__(LengthError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return LengthError
mosek_fusion_LengthError=__mk_mosek_fusion_LengthError()
del __mk_mosek_fusion_LengthError
#BEFORE CLASS
def __mk_mosek_fusion_RangeError():
 class RangeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RangeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.RangeError'
  @staticmethod
  def _ctor_S(msg):
    o = RangeError.__new__(RangeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return RangeError
mosek_fusion_RangeError=__mk_mosek_fusion_RangeError()
del __mk_mosek_fusion_RangeError
#BEFORE CLASS
def __mk_mosek_fusion_IndexError():
 class IndexError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IndexError'
  @staticmethod
  def _ctor_S(msg):
    o = IndexError.__new__(IndexError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IndexError
mosek_fusion_IndexError=__mk_mosek_fusion_IndexError()
del __mk_mosek_fusion_IndexError
#BEFORE CLASS
def __mk_mosek_fusion_DomainError():
 class DomainError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DomainError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DomainError'
  @staticmethod
  def _ctor_S(msg):
    o = DomainError.__new__(DomainError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DomainError
mosek_fusion_DomainError=__mk_mosek_fusion_DomainError()
del __mk_mosek_fusion_DomainError
#BEFORE CLASS
def __mk_mosek_fusion_ValueConversionError():
 class ValueConversionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ValueConversionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ValueConversionError'
  @staticmethod
  def _ctor_S(msg):
    o = ValueConversionError.__new__(ValueConversionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ValueConversionError
mosek_fusion_ValueConversionError=__mk_mosek_fusion_ValueConversionError()
del __mk_mosek_fusion_ValueConversionError
#BEFORE CLASS
def __mk_mosek_fusion_ParameterError():
 class ParameterError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ParameterError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ParameterError'
  @staticmethod
  def _ctor_S(msg):
    o = ParameterError.__new__(ParameterError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ParameterError
mosek_fusion_ParameterError=__mk_mosek_fusion_ParameterError()
del __mk_mosek_fusion_ParameterError
#BEFORE CLASS
def __mk_mosek_fusion_ExpressionError():
 class ExpressionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExpressionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ExpressionError'
  @staticmethod
  def _ctor_S(msg):
    o = ExpressionError.__new__(ExpressionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ExpressionError
mosek_fusion_ExpressionError=__mk_mosek_fusion_ExpressionError()
del __mk_mosek_fusion_ExpressionError
#BEFORE CLASS
def __mk_mosek_fusion_IOError():
 class IOError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IOError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IOError'
  @staticmethod
  def _ctor_S(msg):
    o = IOError.__new__(IOError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IOError
mosek_fusion_IOError=__mk_mosek_fusion_IOError()
del __mk_mosek_fusion_IOError
#BEFORE CLASS
def __mk_mosek_fusion_Disjunction():
 class Disjunction(object):
  __slots__ = ['_Disjunction__id']
  def __repr__(self): return 'mosek.fusion.Disjunction'
  @staticmethod
  def _ctor_J(id):
    o = Disjunction.__new__(Disjunction)
    o._ctor_init_J(id)
    return o
  @staticmethod
  def __match_ctor_J(*args):
    if len(args) != 1: return False
    id, = args
    return (__arg_match_J__(id))
  @staticmethod
  def __match_alt_ctor_J(*args):
    if len(args) != 1: return False
    id, = args
    return (__arg_alt_match_J__(id))
  def _ctor_alt_init_J(self,id):
    self._ctor_init_J(numpy.int64(id))
  def _ctor_init_J(self,id):
   (self.__id) = id
 return Disjunction
mosek_fusion_Disjunction=__mk_mosek_fusion_Disjunction()
del __mk_mosek_fusion_Disjunction
#BEFORE CLASS
def __mk_mosek_fusion_DisjunctionTerms():
 class DisjunctionTerms(object):
  __slots__ = ['_terms']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Term_2(*args):
      self._ctor_init__3Lmosek_4fusion_4Term_2(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Term_2(*args):
      self._ctor_alt_init__3Lmosek_4fusion_4Term_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4ExprRangeDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4ExprRangeDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4ExprLinearDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4ExprLinearDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(*args):
      self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(*args):
      self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(*args):
      self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DisjunctionTerms.ctor(array(mosek.fusion.Term,ndim=1))\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.ExprRangeDomain)\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.ExprLinearDomain)\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.DisjunctionTerms,array(mosek.fusion.Term,ndim=1))\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.DisjunctionTerms,mosek.fusion.Term)\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.DisjunctionTerms,mosek.fusion.ExprRangeDomain)\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.DisjunctionTerms,mosek.fusion.ExprLinearDomain)\n\tmosek.fusion.DisjunctionTerms.ctor(mosek.fusion.DisjunctionTerms,mosek.fusion.DisjunctionTerms)')
  def __repr__(self): return 'mosek.fusion.DisjunctionTerms'
  @staticmethod
  def _ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(terms1,term):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(terms1,term)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 2: return False
    terms1,term, = args
    return (__arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(terms1) and __arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(term))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 2: return False
    terms1,term, = args
    return (__arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(terms1) and __arg_alt_match_Lmosek_4fusion_4ExprRangeDomain_2__(term))
  def _ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(self,terms1,term):
    self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(terms1,term)
  def _ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprRangeDomain_2(self,terms1,term):
   mosek_fusion_DisjunctionTerms._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(self,terms1,mosek.fusion.DJC._term_Lmosek_4fusion_4ExprRangeDomain_2(term))
  @staticmethod
  def _ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(terms1,term):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(terms1,term)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 2: return False
    terms1,term, = args
    return (__arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(terms1) and __arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(term))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 2: return False
    terms1,term, = args
    return (__arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(terms1) and __arg_alt_match_Lmosek_4fusion_4ExprLinearDomain_2__(term))
  def _ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(self,terms1,term):
    self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(terms1,term)
  def _ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4ExprLinearDomain_2(self,terms1,term):
   mosek_fusion_DisjunctionTerms._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(self,terms1,mosek.fusion.DJC._term_Lmosek_4fusion_4ExprLinearDomain_2(term))
  @staticmethod
  def _ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(terms1,term2):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(terms1,term2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(*args):
    if len(args) != 2: return False
    terms1,term2, = args
    return (__arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(terms1) and __arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(term2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(*args):
    if len(args) != 2: return False
    terms1,term2, = args
    return (__arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(terms1) and __arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(term2))
  def _ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(self,terms1,term2):
    self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(terms1,term2)
  def _ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4DisjunctionTerms_2(self,terms1,term2):
   mosek_fusion_DisjunctionTerms._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(self,terms1,(term2._terms))
  @staticmethod
  def _ctor_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(term1,term2):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(term1,term2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    term1,term2, = args
    return (__arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(term1) and __arg_match__3Lmosek_4fusion_4Term_2__(term2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    term1,term2, = args
    return (__arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(term1) and __arg_alt_match__3Lmosek_4fusion_4Term_2__(term2))
  def _ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(self,term1,term2):
    self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(term1,numpy.array(term2,dtype=numpy.dtype(object)))
  def _ctor_init_Lmosek_4fusion_4DisjunctionTerms_2_3Lmosek_4fusion_4Term_2(self,term1,term2):
   _a_0=int(((term1._terms)).shape[0])
   self._terms = numpy.zeros(((int(((term1._terms)).shape[0]) + int((term2).shape[0])),), dtype=numpy.dtype(object))
   _a_1=0
   while (_a_1 < int(((term1._terms)).shape[0])):
    self._terms[_a_1] = (term1._terms)[_a_1]
    _a_1 += 1
   _a_2=0
   while (_a_2 < int((term2).shape[0])):
    self._terms[(_a_2 + _a_0)] = term2[_a_2]
    _a_2 += 1
  @staticmethod
  def _ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(term1,term2):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(term1,term2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    term1,term2, = args
    return (__arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(term1) and __arg_match_Lmosek_4fusion_4Term_2__(term2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    term1,term2, = args
    return (__arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(term1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(term2))
  def _ctor_alt_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(self,term1,term2):
    self._ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(term1,term2)
  def _ctor_init_Lmosek_4fusion_4DisjunctionTerms_2Lmosek_4fusion_4Term_2(self,term1,term2):
   self._terms = numpy.zeros(((int(((term1._terms)).shape[0]) + 1),), dtype=numpy.dtype(object))
   _a_0=0
   while (_a_0 < int(((term1._terms)).shape[0])):
    self._terms[_a_0] = (term1._terms)[_a_0]
    _a_0 += 1
   self._terms[int(((term1._terms)).shape[0])] = term2
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Term_2(terms):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init__3Lmosek_4fusion_4Term_2(terms)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    terms, = args
    return (__arg_match__3Lmosek_4fusion_4Term_2__(terms))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    terms, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Term_2__(terms))
  def _ctor_alt_init__3Lmosek_4fusion_4Term_2(self,terms):
    self._ctor_init__3Lmosek_4fusion_4Term_2(numpy.array(terms,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4Term_2(self,terms):
   (self._terms) = numpy.array([terms[_a_0] for _a_0 in range(0,int((terms).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _ctor_Lmosek_4fusion_4ExprRangeDomain_2(term):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4ExprRangeDomain_2(term)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 1: return False
    term, = args
    return (__arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(term))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 1: return False
    term, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprRangeDomain_2__(term))
  def _ctor_alt_init_Lmosek_4fusion_4ExprRangeDomain_2(self,term):
    self._ctor_init_Lmosek_4fusion_4ExprRangeDomain_2(term)
  def _ctor_init_Lmosek_4fusion_4ExprRangeDomain_2(self,term):
   self._terms = numpy.array([mosek.fusion.DJC._term_Lmosek_4fusion_4ExprRangeDomain_2(term)], dtype=numpy.dtype(object))
  @staticmethod
  def _ctor_Lmosek_4fusion_4ExprLinearDomain_2(term):
    o = DisjunctionTerms.__new__(DisjunctionTerms)
    o._ctor_init_Lmosek_4fusion_4ExprLinearDomain_2(term)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 1: return False
    term, = args
    return (__arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(term))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 1: return False
    term, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprLinearDomain_2__(term))
  def _ctor_alt_init_Lmosek_4fusion_4ExprLinearDomain_2(self,term):
    self._ctor_init_Lmosek_4fusion_4ExprLinearDomain_2(term)
  def _ctor_init_Lmosek_4fusion_4ExprLinearDomain_2(self,term):
   self._terms = numpy.array([mosek.fusion.DJC._term_Lmosek_4fusion_4ExprLinearDomain_2(term)], dtype=numpy.dtype(object))
 return DisjunctionTerms
mosek_fusion_DisjunctionTerms=__mk_mosek_fusion_DisjunctionTerms()
del __mk_mosek_fusion_DisjunctionTerms
#BEFORE CLASS
def __mk_mosek_fusion_Term():
 class Term(mosek_fusion_ExprDomain,object):
  __slots__ = ['_domains','_exprs']
  def toDJCTerm(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Term.toDJCTerm()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Term._match_toDJCTerm_(*args):
      return self._toDJCTerm_(*args)
    elif mosek_fusion_Term._match_alt_toDJCTerm_(*args):
      return self._toDJCTerm_alt_(*args)
    else:
      raise ValueError('Invalid argument list toDJCTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Term.toDJCTerm()')
  def size(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Term.size()

    Description
    -----------

    Total size of the term. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Term._match_size_(*args):
      return self._size_(*args)
    elif mosek_fusion_Term._match_alt_size_(*args):
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Term.size()')
  def __repr__(self): return 'mosek.fusion.Term'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(elist,dlist):
    o = Term.__new__(Term)
    o._ctor_init__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(elist,dlist)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    elist,dlist, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(elist) and __arg_match__3Lmosek_4fusion_4DJCDomain_2__(dlist))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    elist,dlist, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(elist) and __arg_alt_match__3Lmosek_4fusion_4DJCDomain_2__(dlist))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(self,elist,dlist):
    self._ctor_init__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(numpy.array(elist,dtype=numpy.dtype(object)),numpy.array(dlist,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(self,elist,dlist):
   _a_0=int((elist).shape[0])
   self._exprs = numpy.ndarray((_a_0,), dtype=numpy.dtype(object))
   self._domains = numpy.ndarray((_a_0,), dtype=numpy.dtype(object))
   for _a_1 in range(0,_a_0):
    self._exprs[_a_1] = elist[_a_1]
    self._domains[_a_1] = dlist[_a_1]
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d):
    o = Term.__new__(Term)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4DJCDomain_2__(d))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4DJCDomain_2__(d))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
   self._exprs = numpy.array([e], dtype=numpy.dtype(object))
   self._domains = numpy.array([d], dtype=numpy.dtype(object))
  @staticmethod
  def _ctor__3Lmosek_4fusion_4SimpleTerm_2(t):
    o = Term.__new__(Term)
    o._ctor_init__3Lmosek_4fusion_4SimpleTerm_2(t)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    t, = args
    return (__arg_match__3Lmosek_4fusion_4SimpleTerm_2__(t))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    t, = args
    return (__arg_alt_match__3Lmosek_4fusion_4SimpleTerm_2__(t))
  def _ctor_alt_init__3Lmosek_4fusion_4SimpleTerm_2(self,t):
    self._ctor_init__3Lmosek_4fusion_4SimpleTerm_2(numpy.array(t,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4SimpleTerm_2(self,t):
   _a_0=int((t).shape[0])
   self._exprs = numpy.ndarray((_a_0,), dtype=numpy.dtype(object))
   self._domains = numpy.ndarray((_a_0,), dtype=numpy.dtype(object))
   for _a_1 in range(0,_a_0):
    self._exprs[_a_1] = (t[_a_1]._exprs)[0]
    self._domains[_a_1] = (t[_a_1]._domains)[0]
  def _numaccterms_alt_(self,):
    return self._numaccterms_()
  def _numaccterms_(self,):
   _a_0=0
   for _a_1 in range(0,int((self._domains).shape[0])):
    _a_0 += self._domains[_a_1]._numaccterms_()
   return numpy.int32(_a_0)
  def _numaccrows_alt_(self,):
    return self._numaccrows_()
  def _numaccrows_(self,):
   _a_0=0
   for _a_1 in range(0,int((self._domains).shape[0])):
    _a_0 += self._domains[_a_1]._numaccrows_()
   return numpy.int32(_a_0)
  def _num_alt_(self,):
    return self._num_()
  def _num_(self,):
   return numpy.int32(int((self._domains).shape[0]))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _a_0=0
   for _a_1 in range(0,int((self._domains).shape[0])):
    _a_0 += self._domains[_a_1]._size_()
   return numpy.int32(_a_0)
  @staticmethod
  def _match_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  def _toDJCTerm_alt_(self,):
    return self._toDJCTerm_()
  def _toDJCTerm_(self,):
   return (self)
 return Term
mosek_fusion_Term=__mk_mosek_fusion_Term()
del __mk_mosek_fusion_Term
#BEFORE CLASS
def __mk_mosek_fusion_SimpleTerm():
 class SimpleTerm(mosek_fusion_Term):
  def __repr__(self): return 'mosek.fusion.SimpleTerm'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d):
    o = SimpleTerm.__new__(SimpleTerm)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4DJCDomain_2__(d))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4DJCDomain_2__(d))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
   mosek_fusion_Term._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d)
 return SimpleTerm
mosek_fusion_SimpleTerm=__mk_mosek_fusion_SimpleTerm()
del __mk_mosek_fusion_SimpleTerm
#BEFORE CLASS
def __mk_mosek_fusion_DJCDomain():
 class DJCDomain(object):
  __slots__ = ['dom','conedim','shape','par','b']
  def size(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DJCDomain.size()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_DJCDomain._match_size_(*args):
      return self._size_(*args)
    elif mosek_fusion_DJCDomain._match_alt_size_(*args):
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJCDomain.size()')
  def __repr__(self): return 'mosek.fusion.DJCDomain'
  @staticmethod
  def _ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,dom_):
    o = DJCDomain.__new__(DJCDomain)
    o._ctor_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,dom_)
    return o
  @staticmethod
  def __match_ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 4: return False
    b_,par_,shape_,dom_, = args
    return (__arg_match__3D__(b_) and __arg_match__3D__(par_) and __arg_match__3I__(shape_) and __arg_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  @staticmethod
  def __match_alt_ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 4: return False
    b_,par_,shape_,dom_, = args
    return (__arg_alt_match__3D__(b_) and __arg_alt_match__3D__(par_) and __arg_alt_match__3I__(shape_) and __arg_alt_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  def _ctor_alt_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,dom_):
    self._ctor_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(numpy.array(b_,dtype=numpy.dtype(numpy.float64)),numpy.array(par_,dtype=numpy.dtype(numpy.float64)),numpy.array(shape_,dtype=numpy.dtype(numpy.int32)),dom_)
  def _ctor_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,dom_):
   self.b = b_
   self.par = par_
   self.shape = shape_
   self.dom = dom_
   self.conedim = (int((shape_).shape[0]) - 1)
  @staticmethod
  def _ctor__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,conedim_,dom_):
    o = DJCDomain.__new__(DJCDomain)
    o._ctor_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,conedim_,dom_)
    return o
  @staticmethod
  def __match_ctor__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 5: return False
    b_,par_,shape_,conedim_,dom_, = args
    return (__arg_match__3D__(b_) and __arg_match__3D__(par_) and __arg_match__3I__(shape_) and __arg_match_I__(conedim_) and __arg_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  @staticmethod
  def __match_alt_ctor__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 5: return False
    b_,par_,shape_,conedim_,dom_, = args
    return (__arg_alt_match__3D__(b_) and __arg_alt_match__3D__(par_) and __arg_alt_match__3I__(shape_) and __arg_alt_match_I__(conedim_) and __arg_alt_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  def _ctor_alt_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,conedim_,dom_):
    self._ctor_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(numpy.array(b_,dtype=numpy.dtype(numpy.float64)),numpy.array(par_,dtype=numpy.dtype(numpy.float64)),numpy.array(shape_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim_),dom_)
  def _ctor_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,conedim_,dom_):
   self.b = b_
   self.par = par_
   self.shape = shape_
   self.dom = dom_
   self.conedim = conedim_
  def _numaccterms_alt_(self,):
    return self._numaccterms_()
  def _numaccterms_(self,):
   if (self.dom==mosek.fusion.DJCDomainType.InRange):
    return numpy.int32(2)
   else:
    return numpy.int32(1)
  def _numaccrows_alt_(self,):
    return self._numaccrows_()
  def _numaccrows_(self,):
   if (self.dom==mosek.fusion.DJCDomainType.InRange):
    return numpy.int32((self._size_() * 2))
   else:
    return numpy.int32(self._size_())
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _a_0=1
   _a_0 = fragments._c_closure_0(_a_0,self.shape)
   _a_0 = numpy.int32(_a_0) # postprocess
   return numpy.int32(_a_0)
 return DJCDomain
mosek_fusion_DJCDomain=__mk_mosek_fusion_DJCDomain()
del __mk_mosek_fusion_DJCDomain
#BEFORE CLASS
def __mk_mosek_fusion_DJC():
 class DJC(object):
  @staticmethod
  def ANDFromTerms(*args):
    '''
    Syntax
    ------

      mosek.fusion.DJC.ANDFromTerms(array(mosek.fusion.Term,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    tlist : array(mosek.fusion.Term,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_DJC._match_ANDFromTerms__3Lmosek_4fusion_4Term_2(*args):
      return mosek_fusion_DJC._ANDFromTerms__3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_DJC._match_alt_ANDFromTerms__3Lmosek_4fusion_4Term_2(*args):
      return mosek_fusion_DJC._ANDFromTerms_alt__3Lmosek_4fusion_4Term_2(*args)
    else:
      raise ValueError('Invalid argument list ANDFromTerms('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJC.ANDFromTerms(array(mosek.fusion.Term,ndim=1))')
  @staticmethod
  def AND(*args):
    '''
    Syntax
    ------

      mosek.fusion.DJC.AND(array(mosek.fusion.SimpleTerm,ndim=1))
      mosek.fusion.DJC.AND(array(mosek.fusion.ExprDomain,ndim=1))
      mosek.fusion.DJC.AND(mosek.fusion.SimpleTerm)
      mosek.fusion.DJC.AND(mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm)
      mosek.fusion.DJC.AND(mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm)

    Description
    -----------

    Create a conjunction of simple terms. 

    Parameters
    ----------

    elist : array(mosek.fusion.ExprDomain,ndim=1)
    s1 : mosek.fusion.SimpleTerm
        A simple term. 
    s2 : mosek.fusion.SimpleTerm
        A simple term. 
    s3 : mosek.fusion.SimpleTerm
        A simple term. 
    slist : array(mosek.fusion.SimpleTerm,ndim=1)
        A list of simple terms in the conjunction. 
    '''
    if False: pass
    elif mosek_fusion_DJC._match_AND__3Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND__3Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_alt__3Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_AND__3Lmosek_4fusion_4ExprDomain_2(*args):
      return mosek_fusion_DJC._AND__3Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_AND__3Lmosek_4fusion_4ExprDomain_2(*args):
      return mosek_fusion_DJC._AND_alt__3Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_DJC._match_AND_Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND_Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_alt_Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
      return mosek_fusion_DJC._AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    else:
      raise ValueError('Invalid argument list AND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJC.AND(array(mosek.fusion.SimpleTerm,ndim=1))\n\tmosek.fusion.DJC.AND(array(mosek.fusion.ExprDomain,ndim=1))\n\tmosek.fusion.DJC.AND(mosek.fusion.SimpleTerm)\n\tmosek.fusion.DJC.AND(mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm)\n\tmosek.fusion.DJC.AND(mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm)')
  @staticmethod
  def term(*args):
    '''
    Syntax
    ------

      mosek.fusion.DJC.term(mosek.fusion.ExprRangeDomain)
      mosek.fusion.DJC.term(mosek.fusion.ExprLinearDomain)
      mosek.fusion.DJC.term(mosek.fusion.Variable,mosek.fusion.RangeDomain)
      mosek.fusion.DJC.term(mosek.fusion.Expression,mosek.fusion.RangeDomain)
      mosek.fusion.DJC.term(mosek.fusion.Variable,mosek.fusion.LinearDomain)
      mosek.fusion.DJC.term(mosek.fusion.Expression,mosek.fusion.LinearDomain)

    Description
    -----------

    Create a simple term. 

    Parameters
    ----------

    dom : mosek.fusion.LinearDomain
        The domain of this simple term. 
    expr : mosek.fusion.Expression
        An expression. 
    exprdom : mosek.fusion.ExprLinearDomain
    x : mosek.fusion.Variable
        A variable. 
    '''
    if False: pass
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4ExprRangeDomain_2(*args):
      return mosek_fusion_DJC._term_Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4ExprRangeDomain_2(*args):
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4ExprLinearDomain_2(*args):
      return mosek_fusion_DJC._term_Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4ExprLinearDomain_2(*args):
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    else:
      raise ValueError('Invalid argument list term('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJC.term(mosek.fusion.ExprRangeDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.ExprLinearDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Expression,mosek.fusion.LinearDomain)')
  def __repr__(self): return 'mosek.fusion.DJC'
  @staticmethod
  def _match_ANDFromTerms__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Term_2__(_a_0))
  @staticmethod
  def _match_alt_ANDFromTerms__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Term_2__(_a_0))
  @staticmethod
  def _ANDFromTerms_alt__3Lmosek_4fusion_4Term_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_DJC._ANDFromTerms__3Lmosek_4fusion_4Term_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _ANDFromTerms__3Lmosek_4fusion_4Term_2(_a_0):
   _a_1=0
   for _a_2 in range(0,int((_a_0).shape[0])):
    _a_1 += _a_0[_a_2]._num_()
   _a_3=numpy.ndarray((_a_1,), dtype=numpy.dtype(object))
   _a_4=numpy.ndarray((_a_1,), dtype=numpy.dtype(object))
   _a_1 = 0
   for _a_5 in range(0,int((_a_0).shape[0])):
    for _a_6 in range(0,_a_0[_a_5]._num_()):
     _a_3[_a_1] = (_a_0[_a_5]._exprs)[_a_6]
     _a_4[_a_1] = (_a_0[_a_5]._domains)[_a_6]
     _a_1 += 1
   return (mosek_fusion_Term._ctor__3Lmosek_4fusion_4Expression_2_3Lmosek_4fusion_4DJCDomain_2(_a_3,_a_4))
  @staticmethod
  def _match_AND__3Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4ExprDomain_2__(_a_0))
  @staticmethod
  def _match_alt_AND__3Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4ExprDomain_2__(_a_0))
  @staticmethod
  def _AND_alt__3Lmosek_4fusion_4ExprDomain_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_DJC._AND__3Lmosek_4fusion_4ExprDomain_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _AND__3Lmosek_4fusion_4ExprDomain_2(_a_0):
   return (mosek.fusion.DJC._ANDFromTerms__3Lmosek_4fusion_4Term_2(numpy.array([_a_0[_a_1]._toDJCTerm_() for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4SimpleTerm_2__(_a_0) and __arg_match_Lmosek_4fusion_4SimpleTerm_2__(_a_1) and __arg_match_Lmosek_4fusion_4SimpleTerm_2__(_a_2))
  @staticmethod
  def _match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_a_2))
  @staticmethod
  def _AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4SimpleTerm_2__(_a_0) and __arg_match_Lmosek_4fusion_4SimpleTerm_2__(_a_1))
  @staticmethod
  def _match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_a_1))
  @staticmethod
  def _AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_t__a_0,_t__a_1):
    return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_a_0,_a_1)
  @staticmethod
  def _AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_a_0,_a_1):
   return (mosek.fusion.DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND_Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4SimpleTerm_2__(_a_0))
  @staticmethod
  def _match_alt_AND_Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_a_0))
  @staticmethod
  def _AND_alt_Lmosek_4fusion_4SimpleTerm_2(_t__a_0):
    return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2(_a_0)
  @staticmethod
  def _AND_Lmosek_4fusion_4SimpleTerm_2(_a_0):
   return (mosek.fusion.DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(numpy.array([_a_0], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4SimpleTerm_2__(_a_0))
  @staticmethod
  def _match_alt_AND__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4SimpleTerm_2__(_a_0))
  @staticmethod
  def _AND_alt__3Lmosek_4fusion_4SimpleTerm_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _AND__3Lmosek_4fusion_4SimpleTerm_2(_a_0):
   return (mosek_fusion_Term._ctor__3Lmosek_4fusion_4SimpleTerm_2(_a_0))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_t__a_0,_t__a_1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1):
   if ((_a_1._sparsity) is not None):
    raise mosek_fusion_DomainError._ctor_S("Sparse domain is not acceptable in disjunctive constraints")
   if (_a_1._cardinal_flag):
    raise mosek_fusion_DomainError._ctor_S("Integer domain is not acceptable in disjunctive constraints")
   _a_2=(_a_1._lb)
   _a_3=(_a_1._ub)
   _a_4=_a_0._getShape_()
   _a_5=_a_0._getSize_()
   _a_6=(_a_1._shape)
   if (_a_6 is None):
    _a_6 = _a_4
   else:
    if (int((_a_6).shape[0])!=int((_a_4).shape[0])):
     raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
    else:
     for _a_9 in range(0,int((_a_6).shape[0])):
      if (_a_6[_a_9]!=_a_4[_a_9]):
       raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
   if (_a_1._scalable):
    _a_7 = numpy.array([_a_2[0] for _a_10 in range(0,_a_5)], dtype=numpy.dtype(numpy.float64))
    _a_8 = numpy.array([_a_3[0] for _a_11 in range(0,_a_5)], dtype=numpy.dtype(numpy.float64))
   else:
    _a_7 = _a_2
    _a_8 = _a_3
   return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_a_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_a_7,_a_8,_a_6,mosek.fusion.DJCDomainType.InRange)))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_t__a_0,_t__a_1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0._asExpr_(),_a_1))
  @staticmethod
  def _match_term_Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(_a_0))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprRangeDomain_2__(_a_0))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4ExprRangeDomain_2(_t__a_0):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4ExprRangeDomain_2(_a_0)
  @staticmethod
  def _term_Lmosek_4fusion_4ExprRangeDomain_2(_a_0):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2((_a_0.expr),(_a_0.dom)))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_t__a_0,_t__a_1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1):
   if ((_a_1._sparsity) is not None):
    raise mosek_fusion_DomainError._ctor_S("Sparse domain is not acceptable in disjunctive constraints")
   if (_a_1._cardinal_flag):
    raise mosek_fusion_DomainError._ctor_S("Integer domain is not acceptable in disjunctive constraints")
   _a_2=(_a_1._bnd)
   _a_3=_a_0._getShape_()
   _a_4=_a_0._getSize_()
   _a_5=(_a_1._shape)
   if (_a_5 is None):
    _a_5 = _a_3
   else:
    if (int((_a_5).shape[0])!=int((_a_3).shape[0])):
     raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
    else:
     for _a_7 in range(0,int((_a_5).shape[0])):
      if (_a_5[_a_7]!=_a_3[_a_7]):
       raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
   if ((_a_1._bnd) is None):
    _a_6 = numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   elif (_a_1._scalable):
    _a_6 = numpy.array([_a_2[0] for _a_8 in range(0,_a_4)], dtype=numpy.dtype(numpy.float64))
   elif (_a_1._empty):
    _a_6 = numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   else:
    _a_6 = _a_2
   if ((_a_1._key)==mosek.fusion.RelationKey.EqualsTo):
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_a_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_a_6,None,_a_5,mosek.fusion.DJCDomainType.EqualTo)))
   elif ((_a_1._key)==mosek.fusion.RelationKey.LessThan):
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_a_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_a_6,None,_a_5,mosek.fusion.DJCDomainType.LessThan)))
   elif ((_a_1._key)==mosek.fusion.RelationKey.GreaterThan):
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_a_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_a_6,None,_a_5,mosek.fusion.DJCDomainType.GreaterThan)))
   elif ((_a_1._key)==mosek.fusion.RelationKey.IsFree):
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_a_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_a_6,None,_a_5,mosek.fusion.DJCDomainType.IsFree)))
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid linear domain")
  @staticmethod
  def _match_term_Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(_a_0))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprLinearDomain_2__(_a_0))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4ExprLinearDomain_2(_t__a_0):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4ExprLinearDomain_2(_a_0)
  @staticmethod
  def _term_Lmosek_4fusion_4ExprLinearDomain_2(_a_0):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2((_a_0.expr),(_a_0.dom)))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_t__a_0,_t__a_1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0._asExpr_(),_a_1))
 return DJC
mosek_fusion_DJC=__mk_mosek_fusion_DJC()
del __mk_mosek_fusion_DJC
def __mk_mosek_fusion_BaseModel():
  import threading
  import mosek
  import mosek.fusion
  import numpy
  
  class BaseModel(object):
    _lock = threading.Lock()
    _global_env = None
    _global_env_counter = 0
  
    @classmethod
    def _globalEnv(self):
      self._lock.acquire()
      try:
        if BaseModel._global_env is None:
          try:
            env = mosek.Env(globalenv=True)
            BaseModel._global_env = env
            BaseModel._global_env_counter += 1
          except mosek.Exception as e:
            raise UnexpectedError(e)
        return BaseModel._global_env
      finally:
        self._lock.release()
  
    @classmethod
    def _env_1putlicensecode__3I(self,code):
      self._globalEnv().putlicensecode(code)
  
    @classmethod
    def _env_1putlicensepath_S(self,path):
      self._globalEnv().putlicensepath(path)
  
    @classmethod
    def _env_1putlicensewait_Z(self,yn):
      if yn:
        self._globalEnv().putlicensewait(1)
      else:
        self._globalEnv().putlicensewait(0)
  
    @classmethod
    def _env_1getversion_(self):
      return ".".join([str(_) for _ in mosek.Env.getversion()])
  
    def __callback(self,callbackkey,dinf,iinf,liinf):
      if self.__user_cb is not None:
        try:
          if self.__user_cb(callbackkey,dinf,iinf,liinf):
            self.__break = True
        except:
          self.__break = True
      if self.__user_pgs is not None:
        try:
          if self.__user_pgs(callbackkey):
            self.__break = True
        except:
          self.__break = True
      return 1 if self.__break else 0
  
    def _ctor_init_SS(self,name,licfile):
      env = self._globalEnv()
      self.__modelname = name
      self.__break = False
      task = mosek.Task(self._global_env, 0, 0);
      self.__user_cb = None
      self.__user_pgs = None
      finished = False
      try:
        task.putintparam(mosek.iparam.log_expand,0);
        task.putintparam(mosek.iparam.remove_unused_solutions,1);
        self.__task = task
        if name is not None:
          task.puttaskname(name)
  
        self._synched = mosek_fusion_SolutionStatus.Optimal;
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        self.__objname = None
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def _ctor_init_Lmosek_4fusion_4BaseModel_2(self,m):
      env = self._globalEnv()
      self.__modelname = m.__modelname
      self.__break = False
      self.__user_cb = None
      self.__user_pgs = None
      task = mosek.Task(m.__task)
      finished = False
      try:
        self.__task = task
        self._synched = m._synched
  
        self._sol_itr = m._sol_itr._clone_() if m._sol_itr is not None else None
        self._sol_bas = m._sol_bas._clone_() if m._sol_bas is not None else None
        self._sol_itg = m._sol_itg._clone_() if m._sol_itg is not None else None
  
        self.__objname = m.__objname
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def __del__(self):
        lock = self._lock
        if hasattr(self,'_BaseModel__task'):
          lock.acquire()
          try:
            task = self.__task
            BaseModel._global_env_counter -= 1
            task.__del__()
  
            for a in self.__class__.__slots__ + ['_sol_itr','_sol_bas','_sol_itg',
                                                 '_BaseModel__user_cb','_BaseModel__user_pgs','_BaseModel__loghandler','_BaseModel__logwriter','_BaseModel__task']:
              try: delattr(self,a)
              except AttributeError: pass
          finally:
            lock.release()
  
    def __enter__(self):
      return self
    def __exit__(self,exc_type,exc_val,exc_tb):
      self.__del__()
    def _dispose_(self):
      self.__del__()
  
    def _task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,handler):
      self.__user_cb = handler
    def _task_1setCallbackHandler_LSystem_4CallbackHandler_2(self,handler):
      self.__user_pgs = handler
  
    def _task_1setLogHandler_LSystem_4StreamWriter_2(self,handler):
      """
      Set the object to handle log output from the solver.
  
      The handler object must have a write method accepting a string.
      """
      self.__logwriter = handler
  
    def _task_1put_1param_SS(self,name,value):
      self.__task.putnastrparam(name,value)
    def _task_1put_1param_SD(self,name,value):
      self.__task.putnadouparam(name,value)
    def _task_1put_1param_SI(self,name,value):
      self.__task.putnaintparam(name,value)
  
    def _task_1get_1dinf_S(self,name):
      key = mosek_fusion_SolverInfo._getdouinf(name)
      if key is None:
        raise NameError("Invalid double info name '%s'" % name)
      else:
        return self.__task.getdouinf(key)
  
    def _task_1get_1iinf_S(self,name):
      key = mosek_fusion_SolverInfo._getintinf(name)
      if key is None:
        raise NameError("Invalid integer info name '%s'" % name)
      else:
        return self.__task.getintinf(key)
  
    def _task_1get_1liinf_S(self,name):
      key = mosek_fusion_SolverInfo._getlintinf(name)
      if key is None:
        raise NameError("Invalid long integer info name '%s'" % name)
      else:
        return self.__task.getlintinf(key)
  
    def _numVariables_ (self):
      return len(self.__vars)
    def _numConstraints_ (self):
      return len(self.__cons)
  
    @staticmethod
    def __convert_names(names):
      namelist = None
      if names is not None:
        namelist = []
        namedaxisidxs = []
        for axisi,nl in enumerate(names):
          if nl is not None:
            namelist.extend(nl)
            namedaxisidxs.append(axisi)
      else:
        namelist = None
        namedaxisidxs = None
  
      return namedaxisidxs,namelist
    def _task_1format_1djc_1names__3JS_3I_3_3S(self,sub,fmt,dims,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generatedjcnames(sub,fmt,dims,None,namedaxisidxs,namelist)
    def _task_1format_1acc_1names__3JS_3I_3_3S(self,sub,fmt,dims,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generateaccnames(sub,fmt,dims,None,namedaxisidxs,namelist)
    def _task_1format_1var_1names__3IS_3I_3J_3_3S(self,subj,fmt,dims,sp,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generatevarnames(subj,fmt,dims,sp,namedaxisidxs,namelist)
    def _task_1format_1barvar_1names__3IS_3I_3_3S(self,subj,fmt,dims,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generatebarvarnames(subj,fmt,dims,None,namedaxisidxs,namelist)
    def _task_1format_1con_1names__3IS_3I_3J_3_3S(self,subj,fmt,dims,sp,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generateconnames(subj,fmt,dims,sp,namedaxisidxs,namelist)
  
    def _task_1con_1name_IS(self,idx,name): self.__task.putconname(idx,name)
    def _task_1var_1name_IS(self,idx, name): self.__task.putvarname(idx,name)
    def _task_1acc_1name_JS(self,idx, name): self.__task.putaccname(idx,name)
    def _task_1djc_1name_JS(self,idx, name): self.__task.putdjcname(idx,name)
    def _task_1barvar_1name_IS(self,idx, name): self.__task.putbarvarname(idx,name)
  
    def _task_1numcon_(self):
      return self.__task.getnumcon()
    def _task_1numvar_(self):
      return self.__task.getnumvar()
    def _task_1numacc_(self):
      return self.__task.getnumacc()
    def _task_1numafe_(self):
      return self.__task.getnumafe()
    def _task_1numdjc_(self):
      return self.__task.getnumdjc()
  
    def __task_putvarboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putvarboundlist(idxs,bka,bl,bu)
  
    def __task_putconboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putconboundlist(idxs,bka,bl,bu)
  
    def _task_1con_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1con_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1con_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1con_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putconboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1con_1putboundlist_1fr__3I(self,idxs):
      self.__task_putconboundlist( idxs, None, None, mosek.boundkey.fr);
  
  
    def _task_1var_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1var_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1var_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1var_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putvarboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putboundlist_1fr__3I(self,idxs):
      self.__task_putvarboundlist( idxs, None, None, mosek.boundkey.fr);
  
    def _task_1var_1putintlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
    def _task_1var_1putcontlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_cont] * len(idxs))
  
  
    def _task_1task_1optimize_ (self):
      try:
        self.__task.optimize()
        if self.__logwriter is not None:
          self.__task.solutionsummary(streamtype.log)
      except mosek.Error as e:
        raise OptimizeError("Error occurred while optimizing")
  
    def __task_appendvars(self,num):
      idx = self.__task.getnumvar()
      self.__task.appendvars(num)
      return idx
  
    def __task_appendcons(self,num):
      idx = self.__task.getnumcon()
      self.__task.appendcons(num)
      return idx
  
    def _task_1append_1var_I(self,num):
      return self.__task_appendvars(num)
  
    def _task_1append_1con_I(self,num):
      return self.__task_appendcons(num)
  
    # def _task_1append_1zerocones_I(self, numcone):
    #   self.__task.appendconesseq([mosek.conetype.zero for i in range(numcone)], numpy.zeros(numcone),numpy.zeros(numcone,int), 0)
  
    # def _task_1clear_1cones__3I(self, idxs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.zero, 0.0, 0,[])
  
    # def _task_1put_1zerocones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.zero, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1quadcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.quad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1rquadcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.rquad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1pexpcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.pexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1ppowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.ppow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1dexpcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.dexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1dpowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.dpow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1onenormcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.onenrm, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1infnormcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.infnrm, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1pgeomeancones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.pgeomean, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1dgeomeancones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.dgeomean, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1putarowlist__3I_3J_3I_3D(self,sub, ptrb, subj, cof):
      num   = len(sub)
      self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);
  
    def _task_1cleararowlist__3I(self,sub):
      num  = len(sub)
      ptr = numpy.zeros(num,dtype=numpy.int64)
      self.__task.putarowlist(sub, ptr, ptr, numpy.zeros(0,dtype=numpy.int32), numpy.zeros(0,dtype=numpy.float64))
  
      # This is probably awfully slow
      nnz   = self.__task.getnumbaranz()
      if nnz > 0:
        idxij = numpy.zeros(nnz,dtype=numpy.int64)
        self.__task.getbarasparsity(idxij)
        sub = set(sub)
        for idx in idxij:
          i,j = self.__task.getbaraidxij(idx)
          if i in sub:
            self.__task.putbaraij(i,j,[],[])
  
    def _task_1clearacollist__3I(self,sub):
      num  = len(sub)
      ptr = numpy.zeros(num,dtype=numpy.int64)
      self.__task.putacollist(sub, ptr, ptr, numpy.zeros(0,dtype=numpy.int32), numpy.zeros(0,dtype=numpy.float64))
  
    def _task_1putaijlist__3I_3I_3DJ(self,subi,subj,cof,num):
      self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
  
    def _task_1putobjectivename_S(self,name):
      self.__task.putobjname("" if name is None else name)
  
    def _task_1putobjective_Z_3I_3DD(self,maximize,subj,cof,cfix):
      c = numpy.zeros(self.__task.getnumvar(),numpy.float64)
      idxs = numpy.arange(0,len(c),dtype=numpy.int32)
      for i in range(len(subj)):
        c[subj[i]] += cof[i]
      self.__task.putclist(idxs,c)
      self.__task.putcfix(cfix)
      self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
    def _task_1putclist__3I_3D(self,subj,cof):
      self.__task.putclist(subj,cof)
  
  
    def _task_1appendsymmatlist__3I_3J_3I_3I_3D(self,dim,nz,subi,subj,cof):
      r = numpy.zeros(len(dim),numpy.int64)
      #print(dim,nz,"totalnz = {}, len(subi) = {},len(subj) = {}, subi = {}".format(sum(nz),len(subi),len(subj),subi))
      self.__task.appendsparsesymmatlist(dim,nz,subi,subj,cof,r)
      return r
  
    def _task_1putbarc__3I_3I_3I_3D(self,subj,subk,subl,val):
      #rint("putbarc: ",subj,subk,subl,val)
      self.__task.putbarcblocktriplet(subj,subk,subl,val)
      #self.__task.writedata("intermediate1.ptf")
  
    def _task_1putbaraijlist__3I_3I_3J(self,subi,subj,matidx):
      alpha = numpy.ones(len(subi),numpy.float64)
      ptr = numpy.arange(0,len(subi)+1,dtype=numpy.int64)
      self.__task.putbaraijlist(subi,subj,ptr[:-1],ptr[1:],matidx,alpha)
  
    def _task_1putbararowlist__3I_3J_3I_3J(self,subi,ptr,subj,matidx):
      alpha = numpy.ones(len(subj),numpy.float64)
      nummat = numpy.ones(len(subj),numpy.int64)
      self.__task.putbararowlist(subi,ptr[:-1],ptr[1:],subj,nummat,matidx,alpha)
  
  
    def _task_1barvardim_I(self,index):
      return self.__task.getdimbarvarj(index)
  
    def _task_1numbarvar_(self):
      return self.__task.getnumbarvar()
  
  
    def _task_1append_1barvar_II(self,size, num):
      res = self.__task.getnumbarvar()
      self.__task.appendbarvars([size] * num)
      return res
  
    def _task_1setnumvar_I(self,num):
      numvar = self.__task.getnumvar()
      if numvar > num:
        self.__task.removevars(range(num,numvar))
  
  
    def _task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(self,whichsol,first,last,xx):
      if   whichsol == mosek_fusion_SolutionType.Interior:
        self.__task.putxxslice(mosek.soltype.itr, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Integer:
        self.__task.putxxslice(mosek.soltype.itg, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Basic:
        self.__task.putxxslice(mosek.soltype.bas, first,last,xx)
  
    def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
      numvar  = self.__task.getnumvar()
      numcon  = self.__task.getnumcon()
      numcone = self.__task.getnumcone()
      numbarvar = self.__task.getnumbarvar()
  
      if inumcone < numcone:
        self.__task.removecones(range(inumcone,numcone))
  
      if inumvar < numvar:
        n = numvar-inumvar
        vals = numpy.zeros((n,), numpy.float64)
        bk   = [ mosek.boundkey.fx for i in range(n) ]
        self.__task.putvarboundslice(inumvar,numvar,bk, vals, vals)
  
      if (inumcon < numcon):
        idxs = range(inumcon,numcon)
        self.__task.removecons(idxs)
  
      if (inumbarvar < numbarvar):
        self.__task.removebarvars(range(inumbarvar,numbarvar))
  
    def _task_1append_1afes_J(self,num):
      first = self.__task.getnumafe()
      self.__task.appendafes(num)
      return first
  
  
    def _task_1clearafelist__3J(self,idxs):
      self.__task.emptyafefrowlist(idxs)
      self.__task.emptyafebarfrowlist(idxs)
      self.__task.putafeglist(idxs,numpy.zeros(len(idxs),dtype=numpy.float64))
  
    def _task_1putafeflist__3J_3I_3I_3D_3D(self,idxs,ptr,subj,cof,g):
      lptr = numpy.array(ptr[:-1],dtype=numpy.int64)
      rownz = numpy.array([ptr[i+1]-ptr[i] for i in range(len(ptr)-1)],dtype=numpy.int32)
      self.__task.putafefrowlist(idxs,rownz,lptr, subj,cof)
      self.__task.putafeglist(idxs,g)
  
    # def _task_1putafebarfrowlist__3I_3J_3I_3J (self,idxs,ptr,barsubj,symmatidx):
    #     num = len(barsubj)
    #     afeidxlist = numpy.array([ idxs[i] for i in range(len(idxs)) for j in range(ptr[i],ptr[i+1]) ],dtype=numpy.int64)
    #     numtermslist = numpy.ones(num,numpy.int64)
    #     ptrtermslist = numpy.arange(num,numpy.int64)
    #     termweights = numpy.ones(num,numpy.float64)
    #     self.__task.putafebarfentrylist(afeidxlist,barsubj,numtermslist,ptrtermslist,symmatidx,termweights)
  
    def _task_1putafefijlist__3I_3I_3D (self,idxs,subj,cof):
      self.__task.putafefentrylist(numpy.array(idxs,dtype=numpy.int64),subj,cof)
    def _task_putafefglist__3I_3D(self,idxs,g):
      self.__task.putafeglist(idxs,g)
  
    def _task_1append_1accs_JI_3J_3D(self,domidx,numcone,afeidxs,g):
      domidxs = numpy.array([domidx for i in range(numcone)],dtype=numpy.int64)
      self.__task.appendaccs(domidxs,afeidxs,g)
  
    def _task_1putacclist__3J_3J_3J_3D(self,accidxs,domidxs,afeidxs,g):
      self.__task.putacclist(accidxs,domidxs,afeidxs,g)
  
  
  
    @staticmethod
    def __convertSolutionStatus(soltype,sol,status,prosta):
      pd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
      try: sol.pstatus = pd[status]
      except KeyError: sol.pstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.dstatus = dd[status]
      except KeyError: sol.dstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.probstatus = psd[prosta]
      except KeyError: sol.probstatus = mosek_fusion_SolutionStatus.Unknown
  
  
    @staticmethod
    def _matchargs_task_1write_S(self,*args):
        return True
    def _task_1write_S(self,filename):
        self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
        #self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
        self.__task.writedata(filename)
  
    def _task_1write_1stream_SLSystem_4DataStream_2(self,ext,stream):
        exts = {
          'mps' : mosek.dataformat.mps,
          'cbf' : mosek.dataformat.cb,
          'ptf' : mosek.dataformat.ptf,
          'opf' : mosek.dataformat.op,
          'lp'  : mosek.dataformat.lp,
          'jtask'  : mosek.dataformat.json_task,
          'task'  : mosek.dataformat.task,
        }
        ct = {
          'gz' : mosek.compresstype.gzip,
          'zst' : mosek.compresstype.zstd,
        }
  
        fmt = mosek.dataformat.mps
        comptype = mosek.compresstype.none
        parts = ext.split('.')
        if len(parts) > 0: fmt = parts[0]
        if len(parts) > 1: comptype = parts[1]
  
        try:
          self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
          self.__task.writedatastream(exts.get(fmt,mosek.dataformat.mps), ct.get(comptype,mosek.compresstype.none), stream)
        except mosek.Error as e:
          raise mosek.fusion.UnexpectedError(e.msg)
  
    def _task_1write(self,filename):
      return self._writeProblem_S(filename)
  
    def _task_1get_(self):
      return self.__task
  
    def _clonetask_(self):
      return mosek.Task(self.__task)
    clonetask = _clonetask_
  
    def _task_1break_1solve_(self):
      self.__break = True
  
    def _task_1putoptserver_1host_S(self, addr):
      self.__task.putoptserverhost(addr)
  
    def _task_1analyze_1problem_I(self, detail):
      try:
        self.__task.putintparam(mosek.iparam.log_ana_pro, detail)
        self.__task.analyzeproblem(mosek.streamtype.log)
      except mosek.Error as e:
        raise mosek.fusion.UnexpectedError(e.msg)
  
    def _report_1solution__Lmosek_4fusion_4SolutionType_Emosek_4fusion_4ProblemStatus_Emosek_4fusion_4SolutionStatus_Lmosek_4fusion_4SolutionStatus_DDIIIIIZZ(
        self,
        soltype,
        prosta,
        psolsta,
        dsolsta,
        pobj,
        dobj,
        numvar,
        numcon,
        numbarelm,
        numacc,
        numaccelm,
        hasprimal,
        hasdual):
      assert False
    def _report_1solution_1get_1xx__3D  (self,v): self.__task.getxxslice(  self.__cursol,0,len(v),v)
    def _report_1solution_1get_1slx__3D (self,v): self.__task.getslxslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1sux__3D (self,v): self.__task.getsuxslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1xc__3D  (self,v): self.__task.getxcslice(  self.__cursol,0,len(v),v)
    def _report_1solution_1get_1slc__3D (self,v): self.__task.getslcslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1suc__3D (self,v): self.__task.getsucslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1barx__3D(self,v): self.__task.getbarxslice(self.__cursol,0,self.__task.getnumbarvar(),len(v),v)
    def _report_1solution_1get_1bars__3D(self,v): self.__task.getbarsslice(self.__cursol,0,self.__task.getnumbarvar(),len(v),v)
    def _report_1solution_1get_1accx__3D(self,v): self.__task.evaluateaccs(self.__cursol,v)
    def _report_1solution_1get_1accy__3D(self,v):
      ptr = 0
      numacc = self.__task.getnumacc()
      for i in range(numacc):
        accn   = self.__task.getaccn(i)
        data = numpy.zeros(accn,numpy.float64)
        self.__task.getaccdoty(self.__cursol,i,data);
        v[ptr:ptr+accn] = data
        ptr += accn
  
    def _report_1solution_1get_1accptr__3I(self,v):
      ptr = 0
      numacc = self.__task.getnumacc()
      for i in range(numacc):
        v[i] = ptr;
        ptr += self.__task.getaccn(i)
  
    #def __report_task_solution(self,mosek.soltype st, int numvar, int numcon, int numbarelm, long numacc, long numaccelm) {
    def __report_task_solution(self,st,numvar,numcon,numbarelm,numacc,numaccelm):
      pd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.unknown :                    mosek_fusion_SolutionStatus.Unknown,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.unknown :                    mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
  
      solsta = self.__task.getsolsta(st)
      prosta = self.__task.getprosta(st)
  
      psolsta = pd[solsta]
      dsolsta = dd[solsta]
  
      # Special unconditional cases for integer solution:
      if st == mosek.soltype.itg:
        dsolsta = mosek_fusion_SolutionStatus.Undefined
        if prosta == mosek.prosta.prim_infeas:
          psolsta = mosek_fusion_SolutionStatus.Undefined
  
      hasprimal = psolsta != mosek_fusion_SolutionStatus.Undefined
      hasdual   = dsolsta != mosek_fusion_SolutionStatus.Undefined
  
      pobj   = self.__task.getprimalobj(st) if hasprimal else 0.0
      dobj   = self.__task.getdualobj(st) if hasdual else 0.0
  
      ps = psd[prosta]
  
      if   st == mosek.soltype.bas: soltp = mosek_fusion_SolutionType.Basic
      elif st == mosek.soltype.itr: soltp = mosek_fusion_SolutionType.Interior
      elif st == mosek.soltype.itg: soltp = mosek_fusion_SolutionType.Integer
  
      self.__cursol = st
      self._report_1solution_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(
        soltp,ps,psolsta,dsolsta,pobj,dobj,numvar,numcon,numbarelm,numacc,numaccelm,hasprimal,hasdual)
  
  
  
  
    @classmethod
    def _env_1solve_1batch_ZDI_3Lmosek_4fusion_4Model_2(self,israce,timelimit,numthreads,models):
      n = len(models)
      tasks = [_m.getTask() for _m in models]
      res = [mosek.rescode.err_unknown] * n
      trm = [mosek.rescode.err_unknown] * n
      ok = False
      try:
        BaseModel._globalEnv().optimizebatch(israce,          # israce
                                             timelimit,       # timelimit
                                             numthreads,      # numthread
                                             tasks,
                                             trm,
                                             res)
        ok = True
      except mosek.Error as e:
        raise mosek_fusion_OptimizeError(str(e))
      finally:
        if not ok: # means exception, post-solve won't be called
          for _m in models:
            _m._sol_itr = None
            _m._sol_bas = None
            _m._sol_itg = None
  
      return [mosek_fusion_SolverStatus.Error if res[i]!=mosek.rescode.ok else mosek_fusion_SolverStatus.LostRace if trm[i]==mosek.rescode.trm_lost_race else mosek_fusion_SolverStatus.OK for i in range(n)]
  
    @staticmethod
    def _matchargs_task_1solve_(self,*args):
      return True
    def _task_1solve_ZSS(self, remote, server, port):
      task = self.__task
      ok = False
      try:
        trmcode = mosek.rescode.ok
        try:
          self.__break = False
          if remote:
            trmcode = task.optimizermt(server, port)
          else:
            trmcode = task.optimize()
          task.solutionsummary(mosek.streamtype.log)
          ok = True
        except mosek.Error as e:
          raise mosek_fusion_OptimizeError(str(e))
      finally:
        if not ok: # means exception, post-solve won't be called
          self._sol_itr = None
          self._sol_bas = None
          self._sol_itg = None
  
    def _task_1post_1solve_(self):
      task = self.__task  
      numcon  = task.getnumcon()
      numvar  = task.getnumvar()
      numbarvar = task.getnumbarvar()
      barvarveclen = 0
      for j in range(numbarvar):
        barxjdim = task.getdimbarvarj(j)
        barvarveclen += barxjdim * (1+barxjdim)/2
      barvarveclen = numpy.int32(barvarveclen)
      numacc = task.getnumacc();
      numaccelm = task.getaccntot();
  
      sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
      sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
      sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)
  
      self._clear_1solutions_();
      if sol_itr_def:
        self.__report_task_solution(mosek.soltype.itr, numvar, numcon, barvarveclen,numacc,numaccelm)
      if sol_bas_def:
        self.__report_task_solution(mosek.soltype.bas, numvar, numcon, barvarveclen,numacc,numaccelm)
      if sol_itg_def:
        self.__report_task_solution(mosek.soltype.itg, numvar, numcon, barvarveclen,numacc,numaccelm)
  
  
    @staticmethod
    def _env_1syeig_I_3D_3D(n,a,w): BaseModel._globalEnv().syeig(n,a,w)
    @staticmethod
    def _env_1syevd_I_3D_3D(n,a,w): BaseModel._globalEnv().syevd(n,a,w)
    #@staticmethod
    #def _env_1potrf_I_3D(n,a):      BaseModel._globalEnv().potrf(n,a)
  
  
  
    def _task_1putafefrow_J_3I_3D(self,idx,subj,cof): self.__task.putafefrow(idx,subj,cof)
  
    def _task_1clearaferowlist__3I(self,idxs):
      subj = numpy.zeros(0,dtype=numpy.int32)
      val  = numpy.zeros(0,dtype=numpy.float64)
  
      for i in range(len(idxs)):
          self.__task.putafefrow(idxs[i],subj,val)
          self.__task.putafeg(idxs[i],0.0)
      raise  UnexpectedError("Not implemented: clearbarfrowlist");
  
    def _task_1putafefrowlist__3I_3I_3I_3D_3D(self,idxs,ptr,subj,cof,g):
      for i in range(len(idxs)):
          self.__task.putafefrow(idxs[i],subj[ptr[i]:ptr[i+1]],cof[ptr[i]:ptr[i+1]])
          self.__task.putafeg(idxs[i],g[i])
  
    def _task_1putafebarfrowlist__3I_3I_3I_3J (self,idxs,ptr,barsubj,symmatidx):
      num = len(barsubj);
      #print('ptr = ',ptr)
      #print('idxs = ',idxs)
      #print('barsubj = ',barsubj)
      afeidxlist   = numpy.array([idxs[i] for i in range(len(idxs)) for j in range(ptr[i],ptr[i+1])],dtype=numpy.int64)
      numtermslist = numpy.ones(num,dtype=numpy.int64)
      ptrtermslist = numpy.arange(num,dtype=numpy.int64)
      termweights  = numpy.ones(num,dtype=numpy.float64)
      #print('afeidxlist   = ',afeidxlist  )
      #print('numtermslist = ',numtermslist)
      #print('ptrtermslist = ',ptrtermslist)
      #print('termweights  = ',termweights )
  
      #print(idxs,afeidxlist,barsubj,numtermslist,ptrtermslist,symmatidx,termweights)
      #print(len(idxs),len(afeidxlist),len(barsubj),len(numtermslist),len(ptrtermslist),len(symmatidx),len(termweights))
      self.__task.putafebarfentrylist(afeidxlist,barsubj,numtermslist,ptrtermslist,symmatidx,termweights)
  
    #def _task_1putafefijlist__3I_3I_3D(self,idxs,subj,cof):
    #  raise UnexpectedError("Not implemented: putafefijlist")
  
    def _task_1putafefglist__3I_3D (self,idxs,g):
      for i,v in zip(idxs,g):
        self.__task.putafeg(i,v)
  
    def _task_1append_1accs_II_3I_3D_3I(self,domidx,numcone,afeidxs,g,accidxs):
      domidxs = numpy.array([domidx]*numcone,dtype=numpy.int32)
      lafeidxs = numpy.array(afeidxs,dtype=numpy.int64)
      firstacc = self.__task.getnumacc()
  
      for i in range(numcone):
        accidxs[i] = firstacc + i
      self.__task.appendaccs(domidxs,lafeidxs,g)
  
    def _task_1putafefrow_I_3I_3D (self,idx,subj,cof):
      self.__task.putafefrow(idx, subj, cof)
  
    def _task_1append_1domain_1quad_I     (self, conesize): return self.__task.appendquadraticconedomain(conesize)
    def _task_1append_1domain_1rquad_I    (self, conesize): return self.__task.appendrquadraticconedomain(conesize)
    def _task_1append_1domain_1pexp_      (self): return self.__task.appendprimalexpconedomain()
    def _task_1append_1domain_1dexp_      (self): return self.__task.appenddualexpconedomain()
    def _task_1append_1domain_1ppow_I_3D  (self, conesize, alpha): return self.__task.appendprimalpowerconedomain(conesize,alpha)
    def _task_1append_1domain_1dpow_I_3D  (self, conesize, alpha): return self.__task.appenddualpowerconedomain(conesize,alpha)
    #def _task_1append_1domain_1onenorm_I  (self, conesize): return self.__task.appendonenormconedomain(conesize)
    #def _task_1append_1domain_1infnorm_I  (self, conesize): return self.__task.appendinfnormconedomain(conesize)
    def _task_1append_1domain_1pgeomean_I (self, conesize): return self.__task.appendprimalgeomeanconedomain(conesize)
    def _task_1append_1domain_1dgeomean_I (self, conesize): return self.__task.appenddualgeomeanconedomain(conesize)
    def _task_1append_1domain_1rpos_I     (self, conesize): return self.__task.appendrplusdomain(conesize)
    def _task_1append_1domain_1rneg_I     (self, conesize): return self.__task.appendrminusdomain(conesize)
    def _task_1append_1domain_1r_I        (self, conesize): return self.__task.appendrdomain(conesize)
    def _task_1append_1domain_1rzero_I    (self, conesize): return self.__task.appendrzerodomain(conesize)
    def _task_1append_1domain_1svec_1psd_I(self, conesize): return self.__task.appendsvecpsdconedomain(conesize)
    def _task_1append_1domain_1empty_     (self): return self.__task.appendrdomain(0)
    def __task_append_1afes(self,num):
      idx = self.__task.getnumafe()
      self.__task.appendafes(num)
      return idx
  
    def __task_appenddjcs(self,num):
      idx = self.__task.getnumdjc()
      self.__task.appenddjcs(num)
      return idx
  
    def _task_1append_1djc_J(self,num):
      return self.__task_appenddjcs(num)
  
    def _task_1putdjcslice_JJ_3J_3J_3J_3J_3D(self,first,last,numterm,termsizes,domidxlist,afeidxlist,b):
      return self.__task.putdjcslice(first,last,domidxlist,afeidxlist,b,termsizes,numterm)
  return BaseModel
mosek_fusion_BaseModel=__mk_mosek_fusion_BaseModel()
#BEFORE CLASS
def __mk_mosek_fusion_Model():
 class Model(mosek_fusion_BaseModel):
  __slots__ = ['_Model__xs','_Model__ws','_Model__rs','_Model__sol_itg','_Model__sol_bas','_Model__sol_itr','_Model__con_map','_Model__acons','_Model__cons','_Model__task_numaferow','_Model__param_value','_Model__param_num','_Model__par_map','_Model__numparameter','_Model__parameters','_Model__initsol_xx_flag','_Model__initsol_xx','_Model__var_map','_Model__barvars','_Model__vars','_Model__bfixidx','_Model__barvar_block_elm_j','_Model__barvar_block_elm_i','_Model__barvar_block_elm_barj','_Model__barvar_block_elm_ptr','_Model__barvar_block_dim','_Model__barvar_block_ptr','_Model__barvar_dim','_Model__barvar_num','_Model__var_elm_acc_ofs','_Model__var_elm_acc_idx','_Model__var_block_acc_id','_Model__var_block_map','_Model__acon_elm_afe','_Model__acon_elm_ofs','_Model__acon_elm_scale','_Model__acon_elm_accid','_Model__acon_afe','_Model__acon_acc','_Model__acon_block_map','_Model__acc_block_map','_Model__obj_blocks','_Model__afe_blocks','_Model__con_blocks','_Model__num_task_acc','_Model__num_task_afe','_Model__num_task_con','_Model__solutionptr','_Model__acceptable_sol','_Model__model_name']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args):
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):
      self._ctor_alt_init_S(*args)
    elif self.__match_ctor_I(*args):
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_SI(*args):
      self._ctor_init_SI(*args)
    elif self.__match_alt_ctor_SI(*args):
      self._ctor_alt_init_SI(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Model.ctor()\n\tmosek.fusion.Model.ctor(string)\n\tmosek.fusion.Model.ctor(int32)\n\tmosek.fusion.Model.ctor(string,int32)')
  def optserverHost(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.optserverHost(string)

    Description
    -----------

    Specify an OptServer for remote calls.

    Parameters
    ----------

    addr : string
        Address of the |optserver|. It should be a valid URL, for example ``http://server:port`` or ``https://server:port``.
    '''
    if False: pass
    elif mosek_fusion_Model._match_optserverHost_S(*args):
      return self._optserverHost_S(*args)
    elif mosek_fusion_Model._match_alt_optserverHost_S(*args):
      return self._optserverHost_alt_S(*args)
    else:
      raise ValueError('Invalid argument list optserverHost('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.optserverHost(string)')
  def primalObjValue(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.primalObjValue()

    Description
    -----------

    Get the primal objective value in the current solution.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_primalObjValue_(*args):
      return self._primalObjValue_(*args)
    elif mosek_fusion_Model._match_alt_primalObjValue_(*args):
      return self._primalObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list primalObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.primalObjValue()')
  def getProblemStatus(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getProblemStatus()
      mosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)

    Description
    -----------

    Return the problem status.

    Parameters
    ----------

    which : mosek.fusion.SolutionType
    '''
    if False: pass
    elif mosek_fusion_Model._match_getProblemStatus_(*args):
      return self._getProblemStatus_(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_(*args):
      return self._getProblemStatus_alt_(*args)
    elif mosek_fusion_Model._match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
      return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
      return self._getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getProblemStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getProblemStatus()\n\tmosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)')
  def writeTask(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.writeTask(string)

    Description
    -----------

    Dump the current solver task to a file.

    Parameters
    ----------

    filename : string
    '''
    if False: pass
    elif mosek_fusion_Model._match_writeTask_S(*args):
      return self._writeTask_S(*args)
    elif mosek_fusion_Model._match_alt_writeTask_S(*args):
      return self._writeTask_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTask(string)')
  def setSolverParam(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.setSolverParam(string,string)
      mosek.fusion.Model.setSolverParam(string,int32)
      mosek.fusion.Model.setSolverParam(string,double)

    Description
    -----------

    Set a double parameter  

    Parameters
    ----------

    floatval : double
        A floating point value to assign to the parameter.
    intval : int32
        An integer value to assign to the parameter.
    name : string
        Name of the parameter to set
    strval : string
        A string value to assign to the parameter.
    '''
    if False: pass
    elif mosek_fusion_Model._match_setSolverParam_SS(*args):
      return self._setSolverParam_SS(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SS(*args):
      return self._setSolverParam_alt_SS(*args)
    elif mosek_fusion_Model._match_setSolverParam_SI(*args):
      return self._setSolverParam_SI(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SI(*args):
      return self._setSolverParam_alt_SI(*args)
    elif mosek_fusion_Model._match_setSolverParam_SD(*args):
      return self._setSolverParam_SD(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SD(*args):
      return self._setSolverParam_alt_SD(*args)
    else:
      raise ValueError('Invalid argument list setSolverParam('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setSolverParam(string,string)\n\tmosek.fusion.Model.setSolverParam(string,int32)\n\tmosek.fusion.Model.setSolverParam(string,double)')
  def getConstraintValues(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getConstraintValues(bool,array(int32,ndim=1),array(double,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    nativeidxs : array(int32,ndim=1)
    offset : int32
    primal : bool
    res : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Model._match_getConstraintValues_Z_3I_3DI(*args):
      return self._getConstraintValues_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintValues_Z_3I_3DI(*args):
      return self._getConstraintValues_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintValues(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  def getConstraintDuals(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getConstraintDuals(bool,array(int32,ndim=1),array(double,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    lower : bool
    nativeidxs : array(int32,ndim=1)
    offset : int32
    res : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Model._match_getConstraintDuals_Z_3I_3DI(*args):
      return self._getConstraintDuals_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintDuals_Z_3I_3DI(*args):
      return self._getConstraintDuals_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintDuals(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  def acceptedSolutionStatus(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)

    Description
    -----------

    Set the accepted solution status. 

    Parameters
    ----------

    what : mosek.fusion.AccSolutionStatus
    '''
    if False: pass
    elif mosek_fusion_Model._match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
      return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_Model._match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
      return self._acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list acceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)')
  def updateObjective(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.updateObjective(mosek.fusion.Expression,mosek.fusion.Variable)

    Description
    -----------

    Update part of the objective.

    Parameters
    ----------

    expr : mosek.fusion.Expression
    x : mosek.fusion.Variable
    '''
    if False: pass
    elif mosek_fusion_Model._match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
      return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
      return self._updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list updateObjective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.updateObjective(mosek.fusion.Expression,mosek.fusion.Variable)')
  def dispose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.dispose()

    Description
    -----------

    Destroy the Model object 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_dispose_(*args):
      return self._dispose_(*args)
    elif mosek_fusion_Model._match_alt_dispose_(*args):
      return self._dispose_alt_(*args)
    else:
      raise ValueError('Invalid argument list dispose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dispose()')
  def disjunction(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.disjunction(mosek.fusion.DisjunctionTerms)
      mosek.fusion.Model.disjunction(array(mosek.fusion.Term,ndim=1))
      mosek.fusion.Model.disjunction(mosek.fusion.Term)
      mosek.fusion.Model.disjunction(mosek.fusion.ExprDomain)
      mosek.fusion.Model.disjunction(array(mosek.fusion.ExprDomain,ndim=1))
      mosek.fusion.Model.disjunction(mosek.fusion.Term,mosek.fusion.Term)
      mosek.fusion.Model.disjunction(string,mosek.fusion.Term)
      mosek.fusion.Model.disjunction(string,mosek.fusion.ExprDomain)
      mosek.fusion.Model.disjunction(string,array(mosek.fusion.Term,ndim=1))
      mosek.fusion.Model.disjunction(string,array(mosek.fusion.ExprDomain,ndim=1))
      mosek.fusion.Model.disjunction(string,mosek.fusion.DisjunctionTerms)
      mosek.fusion.Model.disjunction(string,mosek.fusion.Term,mosek.fusion.Term)
      mosek.fusion.Model.disjunction(mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term)
      mosek.fusion.Model.disjunction(string,mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term)

    Description
    -----------

    Create a new disjunctive constraint in the model. 

    Parameters
    ----------

    djcterms : mosek.fusion.DisjunctionTerms
        An object encapsulating the terms of a disjunctive constraint. 
    name : string
        The name of this disjunctive constraint. 
    t1 : mosek.fusion.Term
        A term in the disjunction. 
    t2 : mosek.fusion.Term
        A term in the disjunction. 
    t3 : mosek.fusion.Term
        A term in the disjunction. 
    term : mosek.fusion.ExprDomain
    terms : array(mosek.fusion.ExprDomain,ndim=1)
        A list of terms forming the disjunctive constraint. 
    '''
    if False: pass
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4DisjunctionTerms_2(*args):
      return self._disjunction_Lmosek_4fusion_4DisjunctionTerms_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4DisjunctionTerms_2(*args):
      return self._disjunction_alt_Lmosek_4fusion_4DisjunctionTerms_2(*args)
    elif mosek_fusion_Model._match_disjunction__3Lmosek_4fusion_4Term_2(*args):
      return self._disjunction__3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction__3Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt__3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_alt_Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_disjunction__3Lmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction__3Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction__3Lmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_alt__3Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4Term_2(*args):
      return self._disjunction_SLmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_SLmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_SLmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_alt_SLmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_disjunction_S_3Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_S_3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_S_3Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_S_3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_S_3Lmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_S_3Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_S_3Lmosek_4fusion_4ExprDomain_2(*args):
      return self._disjunction_alt_S_3Lmosek_4fusion_4ExprDomain_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4DisjunctionTerms_2(*args):
      return self._disjunction_SLmosek_4fusion_4DisjunctionTerms_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4DisjunctionTerms_2(*args):
      return self._disjunction_alt_SLmosek_4fusion_4DisjunctionTerms_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
      return self._disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    else:
      raise ValueError('Invalid argument list disjunction('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.disjunction(mosek.fusion.DisjunctionTerms)\n\tmosek.fusion.Model.disjunction(array(mosek.fusion.Term,ndim=1))\n\tmosek.fusion.Model.disjunction(mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(mosek.fusion.ExprDomain)\n\tmosek.fusion.Model.disjunction(array(mosek.fusion.ExprDomain,ndim=1))\n\tmosek.fusion.Model.disjunction(mosek.fusion.Term,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.ExprDomain)\n\tmosek.fusion.Model.disjunction(string,array(mosek.fusion.Term,ndim=1))\n\tmosek.fusion.Model.disjunction(string,array(mosek.fusion.ExprDomain,ndim=1))\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.DisjunctionTerms)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.Term,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term)')
  def flushParameters(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.flushParameters()

    Description
    -----------

    
    Flush all parameters to the underlying task.
            

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_flushParameters_(*args):
      return self._flushParameters_(*args)
    elif mosek_fusion_Model._match_alt_flushParameters_(*args):
      return self._flushParameters_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushParameters('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushParameters()')
  def getSolverDoubleInfo(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getSolverDoubleInfo(string)

    Description
    -----------

    Fetch a solution information item from the solver 

    Parameters
    ----------

    name : string
    '''
    if False: pass
    elif mosek_fusion_Model._match_getSolverDoubleInfo_S(*args):
      return self._getSolverDoubleInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverDoubleInfo_S(*args):
      return self._getSolverDoubleInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverDoubleInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverDoubleInfo(string)')
  def solve(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.solve()
      mosek.fusion.Model.solve(string,string)

    Description
    -----------

    Attempt to optimize the model.

    Parameters
    ----------

    accesstoken : string
        Access token if optimizing remotely with authentication.
    addr : string
        Address of the |optserver| if optimizing remotely. It should be a valid URL, for example ``http://server:port`` or ``https://server:port``.
    '''
    if False: pass
    elif mosek_fusion_Model._match_solve_(*args):
      return self._solve_(*args)
    elif mosek_fusion_Model._match_alt_solve_(*args):
      return self._solve_alt_(*args)
    elif mosek_fusion_Model._match_solve_SS(*args):
      return self._solve_SS(*args)
    elif mosek_fusion_Model._match_alt_solve_SS(*args):
      return self._solve_alt_SS(*args)
    else:
      raise ValueError('Invalid argument list solve('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solve()\n\tmosek.fusion.Model.solve(string,string)')
  def getConstraint(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getConstraint(string)
      mosek.fusion.Model.getConstraint(int32)

    Description
    -----------

    Get the constraint matching the given name or linear index. 

    Parameters
    ----------

    index : int32
        The constraint's linear index.
    name : string
        The constraint's name.
    '''
    if False: pass
    elif mosek_fusion_Model._match_getConstraint_S(*args):
      return self._getConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_S(*args):
      return self._getConstraint_alt_S(*args)
    elif mosek_fusion_Model._match_getConstraint_I(*args):
      return self._getConstraint_I(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_I(*args):
      return self._getConstraint_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraint(string)\n\tmosek.fusion.Model.getConstraint(int32)')
  def getPrimalSolutionStatus(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getPrimalSolutionStatus()
      mosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)

    Description
    -----------

    Return the primal solution status.

    Parameters
    ----------

    which : mosek.fusion.SolutionType
    '''
    if False: pass
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_(*args):
      return self._getPrimalSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_(*args):
      return self._getPrimalSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
      return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
      return self._getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getPrimalSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getPrimalSolutionStatus()\n\tmosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)')
  def writeTaskStream(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.writeTaskStream(string,System.DataStream)

    Description
    -----------

    Write the current solver task to a stream.

    Parameters
    ----------

    ext : string
    stream : System.DataStream
    '''
    if False: pass
    elif mosek_fusion_Model._match_writeTaskStream_SLSystem_4DataStream_2(*args):
      return self._writeTaskStream_SLSystem_4DataStream_2(*args)
    elif mosek_fusion_Model._match_alt_writeTaskStream_SLSystem_4DataStream_2(*args):
      return self._writeTaskStream_alt_SLSystem_4DataStream_2(*args)
    else:
      raise ValueError('Invalid argument list writeTaskStream('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTaskStream(string,System.DataStream)')
  def hasConstraint(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.hasConstraint(string)

    Description
    -----------

    Check whether the model contains a constraint with a given name.

    Parameters
    ----------

    name : string
        The constraint name.
    '''
    if False: pass
    elif mosek_fusion_Model._match_hasConstraint_S(*args):
      return self._hasConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_hasConstraint_S(*args):
      return self._hasConstraint_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasConstraint(string)')
  def flushSolutions(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.flushSolutions()

    Description
    -----------

    If any solution values have been provided, flush those values to the underlying task. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_flushSolutions_(*args):
      return self._flushSolutions_(*args)
    elif mosek_fusion_Model._match_alt_flushSolutions_(*args):
      return self._flushSolutions_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushSolutions('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushSolutions()')
  def variable(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.variable()
      mosek.fusion.Model.variable(mosek.fusion.RangeDomain)
      mosek.fusion.Model.variable(string)
      mosek.fusion.Model.variable(mosek.fusion.LinearDomain)
      mosek.fusion.Model.variable(int32)
      mosek.fusion.Model.variable(mosek.fusion.ConeDomain)
      mosek.fusion.Model.variable(array(int32,ndim=1))
      mosek.fusion.Model.variable(mosek.fusion.PSDDomain)
      mosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)
      mosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)
      mosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.ConeDomain)
      mosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)
      mosek.fusion.Model.variable(string,int32)
      mosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)
      mosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)
      mosek.fusion.Model.variable(string,array(int32,ndim=1))
      mosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)
      mosek.fusion.Model.variable(int32,mosek.fusion.ConeDomain)
      mosek.fusion.Model.variable(string,mosek.fusion.ConeDomain)
      mosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)
      mosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)
      mosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)
      mosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)
      mosek.fusion.Model.variable(string,int32,mosek.fusion.ConeDomain)
      mosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)
      mosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.ConeDomain)
      mosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)
      mosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)
      mosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)
      mosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)
      mosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)

    Description
    -----------

    Create a new variable in the model. 

    Parameters
    ----------

    ldom : mosek.fusion.LinearDomain
        
        A linear domain for the variable.
                  
    m : int32
        
        Number of semidefinite variables.
    n : int32
        
        Dimension of the semidefinite variable.
    name : string
        
        Name of the variable. This must be unique among all variables in
        the model. The value |null| is allowed instead of a unique name.
                  
    psddom : mosek.fusion.PSDDomain
        
        A semidefinte domain for the variable.
    qdom : mosek.fusion.ConeDomain
        
        A conic domain for the variable.
    rdom : mosek.fusion.RangeDomain
        
        A ranged domain for the variable.
    shp : array(int32,ndim=1)
        
        Defines the shape of the variable.
                  
    size : int32
        
        Size of the variable. The variable becomes a one-dimensional vector of the given size.
                  
    '''
    if False: pass
    elif mosek_fusion_Model._match_variable_(*args):
      return self._variable_(*args)
    elif mosek_fusion_Model._match_alt_variable_(*args):
      return self._variable_alt_(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S(*args):
      return self._variable_S(*args)
    elif mosek_fusion_Model._match_alt_variable_S(*args):
      return self._variable_alt_S(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_I(*args):
      return self._variable_I(*args)
    elif mosek_fusion_Model._match_alt_variable_I(*args):
      return self._variable_alt_I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3I(*args):
      return self._variable__3I(*args)
    elif mosek_fusion_Model._match_alt_variable__3I(*args):
      return self._variable_alt__3I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_alt_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_alt__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_alt__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SI(*args):
      return self._variable_SI(*args)
    elif mosek_fusion_Model._match_alt_variable_SI(*args):
      return self._variable_alt_SI(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_alt__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_alt_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3I(*args):
      return self._variable_S_3I(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3I(*args):
      return self._variable_alt_S_3I(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_alt_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_alt_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_alt_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_alt_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_alt_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
      return self._variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
      return self._variable_alt_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
      return self._variable_alt_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_SIILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
      return self._variable_alt_SIILmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list variable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.variable()\n\tmosek.fusion.Model.variable(mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string)\n\tmosek.fusion.Model.variable(mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32)\n\tmosek.fusion.Model.variable(mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1))\n\tmosek.fusion.Model.variable(mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1))\n\tmosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)')
  def getDualSolutionStatus(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getDualSolutionStatus()
      mosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)

    Description
    -----------

    Return the dual solution status.

    Parameters
    ----------

    which : mosek.fusion.SolutionType
    '''
    if False: pass
    elif mosek_fusion_Model._match_getDualSolutionStatus_(*args):
      return self._getDualSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_(*args):
      return self._getDualSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
      return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
      return self._getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getDualSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getDualSolutionStatus()\n\tmosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)')
  def constraint(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.constraint(mosek.fusion.ExprRangeDomain)
      mosek.fusion.Model.constraint(mosek.fusion.ExprConicDomain)
      mosek.fusion.Model.constraint(mosek.fusion.ExprPSDDomain)
      mosek.fusion.Model.constraint(mosek.fusion.ExprLinearDomain)
      mosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.ConeDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.ExprLinearDomain)
      mosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.ExprPSDDomain)
      mosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)
      mosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.ExprRangeDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.ExprConicDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)
      mosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.ConeDomain)

    Description
    -----------

    Create a new constraint in the model. 

    Parameters
    ----------

    expr : mosek.fusion.Expression
        An expression. 
    exprdom : mosek.fusion.ExprConicDomain
    ldom : mosek.fusion.LinearDomain
        
        A linear domain.
                  
    name : string
        
        Name of the constraint. This must be unique among all constraints in
        the model. The value |null| is allowed instead of a unique name.
                  
    psddom : mosek.fusion.PSDDomain
        
        A positive semidefinte domain.
    qdom : mosek.fusion.ConeDomain
        
        A domain in a cone.
    rdom : mosek.fusion.RangeDomain
        
        A ranged domain.
    '''
    if False: pass
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4ExprRangeDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4ExprRangeDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4ExprRangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4ExprConicDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4ExprConicDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4ExprConicDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4ExprConicDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4ExprPSDDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4ExprPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4ExprPSDDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4ExprPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4ExprLinearDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4ExprLinearDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4ExprLinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4ExprLinearDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4ExprLinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4ExprLinearDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4ExprLinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4ExprPSDDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4ExprPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4ExprPSDDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4ExprPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4ExprRangeDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4ExprRangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4ExprRangeDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4ExprRangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4ExprConicDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4ExprConicDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4ExprConicDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4ExprConicDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list constraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.constraint(mosek.fusion.ExprRangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.ExprConicDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.ExprPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.ExprLinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.ExprLinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.ExprPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.ExprRangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.ExprConicDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.ConeDomain)')
  def getVariable(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getVariable(string)
      mosek.fusion.Model.getVariable(int32)

    Description
    -----------

    Get the variable matching the given name or linear index. 

    Parameters
    ----------

    index : int32
        The variable's linear index.
    name : string
        The variable's name.
    '''
    if False: pass
    elif mosek_fusion_Model._match_getVariable_S(*args):
      return self._getVariable_S(*args)
    elif mosek_fusion_Model._match_alt_getVariable_S(*args):
      return self._getVariable_alt_S(*args)
    elif mosek_fusion_Model._match_getVariable_I(*args):
      return self._getVariable_I(*args)
    elif mosek_fusion_Model._match_alt_getVariable_I(*args):
      return self._getVariable_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariable(string)\n\tmosek.fusion.Model.getVariable(int32)')
  def dualObjValue(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.dualObjValue()

    Description
    -----------

    Get the dual objective value in the current solution.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_dualObjValue_(*args):
      return self._dualObjValue_(*args)
    elif mosek_fusion_Model._match_alt_dualObjValue_(*args):
      return self._dualObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list dualObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dualObjValue()')
  def selectedSolution(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)

    Description
    -----------

    Chooses a solution.

    Parameters
    ----------

    soltype : mosek.fusion.SolutionType
    '''
    if False: pass
    elif mosek_fusion_Model._match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
      return self._selectedSolution_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
      return self._selectedSolution_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list selectedSolution('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)')
  def writeTaskNoFlush(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.writeTaskNoFlush(string)

    Description
    -----------

    

    Parameters
    ----------

    filename : string
    '''
    if False: pass
    elif mosek_fusion_Model._match_writeTaskNoFlush_S(*args):
      return self._writeTaskNoFlush_S(*args)
    elif mosek_fusion_Model._match_alt_writeTaskNoFlush_S(*args):
      return self._writeTaskNoFlush_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTaskNoFlush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTaskNoFlush(string)')
  def setLogHandler(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.setLogHandler(System.StreamWriter)

    Description
    -----------

    Attach a log handler. 

    Parameters
    ----------

    h : System.StreamWriter
    '''
    if False: pass
    elif mosek_fusion_Model._match_setLogHandler_LSystem_4StreamWriter_2(*args):
      return self._setLogHandler_LSystem_4StreamWriter_2(*args)
    elif mosek_fusion_Model._match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
      return self._setLogHandler_alt_LSystem_4StreamWriter_2(*args)
    else:
      raise ValueError('Invalid argument list setLogHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setLogHandler(System.StreamWriter)')
  def getVariableValues(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getVariableValues(bool,array(int64,ndim=1),array(double,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    nativeidxs : array(int64,ndim=1)
    offset : int32
    primal : bool
    res : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Model._match_getVariableValues_Z_3J_3DI(*args):
      return self._getVariableValues_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableValues_Z_3J_3DI(*args):
      return self._getVariableValues_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableValues(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def getVariableDuals(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getVariableDuals(bool,array(int64,ndim=1),array(double,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    lower : bool
    nativeidxs : array(int64,ndim=1)
    offset : int32
    res : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Model._match_getVariableDuals_Z_3J_3DI(*args):
      return self._getVariableDuals_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableDuals_Z_3J_3DI(*args):
      return self._getVariableDuals_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableDuals(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def dataReport(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.dataReport()
      mosek.fusion.Model.dataReport(int32)

    Description
    -----------

    Print out a report about problem data.

    Parameters
    ----------

    detail : int32
        The amount of detail to include, where 0 means nothing and 10 is full. If not provided then a full report is printed.
    '''
    if False: pass
    elif mosek_fusion_Model._match_dataReport_(*args):
      return self._dataReport_(*args)
    elif mosek_fusion_Model._match_alt_dataReport_(*args):
      return self._dataReport_alt_(*args)
    elif mosek_fusion_Model._match_dataReport_I(*args):
      return self._dataReport_I(*args)
    elif mosek_fusion_Model._match_alt_dataReport_I(*args):
      return self._dataReport_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dataReport('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dataReport()\n\tmosek.fusion.Model.dataReport(int32)')
  def getSolverIntInfo(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getSolverIntInfo(string)

    Description
    -----------

    Fetch a solution information item from the solver 

    Parameters
    ----------

    name : string
    '''
    if False: pass
    elif mosek_fusion_Model._match_getSolverIntInfo_S(*args):
      return self._getSolverIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverIntInfo_S(*args):
      return self._getSolverIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverIntInfo(string)')
  @staticmethod
  def putlicensepath(*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.putlicensepath(string)

    Description
    -----------

    Set the license path in the global environment. 

    Parameters
    ----------

    licfile : string
    '''
    if False: pass
    elif mosek_fusion_Model._match_putlicensepath_S(*args):
      return mosek_fusion_Model._putlicensepath_S(*args)
    elif mosek_fusion_Model._match_alt_putlicensepath_S(*args):
      return mosek_fusion_Model._putlicensepath_alt_S(*args)
    else:
      raise ValueError('Invalid argument list putlicensepath('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensepath(string)')
  def getName(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getName()

    Description
    -----------

    Return the model name, or an empty string if it has not been set.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_getName_(*args):
      return self._getName_(*args)
    elif mosek_fusion_Model._match_alt_getName_(*args):
      return self._getName_alt_(*args)
    else:
      raise ValueError('Invalid argument list getName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getName()')
  def hasParameter(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.hasParameter(string)

    Description
    -----------

    Check whether the model contains a parameter with a given name.

    Parameters
    ----------

    name : string
        The parameter's name.
    '''
    if False: pass
    elif mosek_fusion_Model._match_hasParameter_S(*args):
      return self._hasParameter_S(*args)
    elif mosek_fusion_Model._match_alt_hasParameter_S(*args):
      return self._hasParameter_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasParameter(string)')
  def hasVariable(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.hasVariable(string)

    Description
    -----------

    Check whether the model contains a variable with a given name.

    Parameters
    ----------

    name : string
        The variable name.
    '''
    if False: pass
    elif mosek_fusion_Model._match_hasVariable_S(*args):
      return self._hasVariable_S(*args)
    elif mosek_fusion_Model._match_alt_hasVariable_S(*args):
      return self._hasVariable_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasVariable(string)')
  def setDataCallbackHandler(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)

    Description
    -----------

    Attach a data callback handler. 

    Parameters
    ----------

    h : System.DataCallbackHandler
    '''
    if False: pass
    elif mosek_fusion_Model._match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
      return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
      return self._setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setDataCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)')
  @staticmethod
  def putlicensecode(*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.putlicensecode(array(int32,ndim=1))

    Description
    -----------

    Set the license code in the global environment. 

    Parameters
    ----------

    code : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Model._match_putlicensecode__3I(*args):
      return mosek_fusion_Model._putlicensecode__3I(*args)
    elif mosek_fusion_Model._match_alt_putlicensecode__3I(*args):
      return mosek_fusion_Model._putlicensecode_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list putlicensecode('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensecode(array(int32,ndim=1))')
  def parameter(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.parameter()
      mosek.fusion.Model.parameter(string)
      mosek.fusion.Model.parameter(int32)
      mosek.fusion.Model.parameter(array(int32,ndim=1))
      mosek.fusion.Model.parameter(string,int32)
      mosek.fusion.Model.parameter(array(int32,ndim=1),array(int64,ndim=1))
      mosek.fusion.Model.parameter(int32,int32)
      mosek.fusion.Model.parameter(array(int32,ndim=1),array(int32,ndim=2))
      mosek.fusion.Model.parameter(string,array(int32,ndim=1))
      mosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int64,ndim=1))
      mosek.fusion.Model.parameter(int32,int32,int32)
      mosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int32,ndim=2))
      mosek.fusion.Model.parameter(string,int32,int32)
      mosek.fusion.Model.parameter(string,int32,int32,int32)

    Description
    -----------

    Create a new parameter in the model. 

    Parameters
    ----------

    d1 : int32
        First dimension of a parameter.
    d2 : int32
        Second dimension of a parameter.
    d3 : int32
        Third dimension of a parameter.
    name : string
        Name of the parameter.
    shape : array(int32,ndim=1)
        Shape of the parameter.
    sp : array(int64,ndim=1)
        Non-zero sparsity pattern as a list of linear indexes, if the parameter is sparse.
    sparsity : array(int32,ndim=2)
        Non-zero sparsity pattern, if the parameter is sparse.
    '''
    if False: pass
    elif mosek_fusion_Model._match_parameter_(*args):
      return self._parameter_(*args)
    elif mosek_fusion_Model._match_alt_parameter_(*args):
      return self._parameter_alt_(*args)
    elif mosek_fusion_Model._match_parameter_S(*args):
      return self._parameter_S(*args)
    elif mosek_fusion_Model._match_alt_parameter_S(*args):
      return self._parameter_alt_S(*args)
    elif mosek_fusion_Model._match_parameter_I(*args):
      return self._parameter_I(*args)
    elif mosek_fusion_Model._match_alt_parameter_I(*args):
      return self._parameter_alt_I(*args)
    elif mosek_fusion_Model._match_parameter__3I(*args):
      return self._parameter__3I(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I(*args):
      return self._parameter_alt__3I(*args)
    elif mosek_fusion_Model._match_parameter_SI(*args):
      return self._parameter_SI(*args)
    elif mosek_fusion_Model._match_alt_parameter_SI(*args):
      return self._parameter_alt_SI(*args)
    elif mosek_fusion_Model._match_parameter__3I_3J(*args):
      return self._parameter__3I_3J(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I_3J(*args):
      return self._parameter_alt__3I_3J(*args)
    elif mosek_fusion_Model._match_parameter_II(*args):
      return self._parameter_II(*args)
    elif mosek_fusion_Model._match_alt_parameter_II(*args):
      return self._parameter_alt_II(*args)
    elif mosek_fusion_Model._match_parameter__3I_3_5I(*args):
      return self._parameter__3I_3_5I(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I_3_5I(*args):
      return self._parameter_alt__3I_3_5I(*args)
    elif mosek_fusion_Model._match_parameter_S_3I(*args):
      return self._parameter_S_3I(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I(*args):
      return self._parameter_alt_S_3I(*args)
    elif mosek_fusion_Model._match_parameter_S_3I_3J(*args):
      return self._parameter_S_3I_3J(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I_3J(*args):
      return self._parameter_alt_S_3I_3J(*args)
    elif mosek_fusion_Model._match_parameter_III(*args):
      return self._parameter_III(*args)
    elif mosek_fusion_Model._match_alt_parameter_III(*args):
      return self._parameter_alt_III(*args)
    elif mosek_fusion_Model._match_parameter_S_3I_3_5I(*args):
      return self._parameter_S_3I_3_5I(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I_3_5I(*args):
      return self._parameter_alt_S_3I_3_5I(*args)
    elif mosek_fusion_Model._match_parameter_SII(*args):
      return self._parameter_SII(*args)
    elif mosek_fusion_Model._match_alt_parameter_SII(*args):
      return self._parameter_alt_SII(*args)
    elif mosek_fusion_Model._match_parameter_SIII(*args):
      return self._parameter_SIII(*args)
    elif mosek_fusion_Model._match_alt_parameter_SIII(*args):
      return self._parameter_alt_SIII(*args)
    else:
      raise ValueError('Invalid argument list parameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.parameter()\n\tmosek.fusion.Model.parameter(string)\n\tmosek.fusion.Model.parameter(int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1))\n\tmosek.fusion.Model.parameter(string,int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Model.parameter(int32,int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1),array(int32,ndim=2))\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1))\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Model.parameter(int32,int32,int32)\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int32,ndim=2))\n\tmosek.fusion.Model.parameter(string,int32,int32)\n\tmosek.fusion.Model.parameter(string,int32,int32,int32)')
  def getAcceptedSolutionStatus(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getAcceptedSolutionStatus()

    Description
    -----------

    Get the accepted solution status. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_getAcceptedSolutionStatus_(*args):
      return self._getAcceptedSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getAcceptedSolutionStatus_(*args):
      return self._getAcceptedSolutionStatus_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAcceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getAcceptedSolutionStatus()')
  @staticmethod
  def getVersion(*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getVersion()

    Description
    -----------

    Return MOSEK version.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_getVersion_(*args):
      return mosek_fusion_Model._getVersion_(*args)
    elif mosek_fusion_Model._match_alt_getVersion_(*args):
      return mosek_fusion_Model._getVersion_alt_(*args)
    else:
      raise ValueError('Invalid argument list getVersion('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVersion()')
  def clone(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.clone()

    Description
    -----------

    Return a copy of the model.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_clone_(*args):
      return self._clone_(*args)
    elif mosek_fusion_Model._match_alt_clone_(*args):
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.clone()')
  @staticmethod
  def solveBatch(*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.solveBatch(bool,double,int32,array(mosek.fusion.Model,ndim=1))

    Description
    -----------

    Attempt to optimize a collection of models in parallel.

    Parameters
    ----------

    israce : bool
        If true, then the function is terminated after the first model completed.
    maxtime : double
        Time limit: if nonnegative, then the function is terminated after this time (seconds).
    models : array(mosek.fusion.Model,ndim=1)
        An array of models to be solved.
    numthreads : int32
        The number of threads for the whole pool available to all models. If set to 0 the number of threads used will be equal to the number of cores detected on the machine.
    '''
    if False: pass
    elif mosek_fusion_Model._match_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args):
      return mosek_fusion_Model._solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_Model._match_alt_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args):
      return mosek_fusion_Model._solveBatch_alt_ZDI_3Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list solveBatch('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solveBatch(bool,double,int32,array(mosek.fusion.Model,ndim=1))')
  @staticmethod
  def putlicensewait(*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.putlicensewait(bool)

    Description
    -----------

    Set the license wait flag in the global environment. 

    Parameters
    ----------

    wait : bool
    '''
    if False: pass
    elif mosek_fusion_Model._match_putlicensewait_Z(*args):
      return mosek_fusion_Model._putlicensewait_Z(*args)
    elif mosek_fusion_Model._match_alt_putlicensewait_Z(*args):
      return mosek_fusion_Model._putlicensewait_alt_Z(*args)
    else:
      raise ValueError('Invalid argument list putlicensewait('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensewait(bool)')
  def setVariableValues(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.setVariableValues(bool,array(int64,ndim=1),array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    nativeidxs : array(int64,ndim=1)
    primal : bool
    values : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Model._match_setVariableValues_Z_3J_3D(*args):
      return self._setVariableValues_Z_3J_3D(*args)
    elif mosek_fusion_Model._match_alt_setVariableValues_Z_3J_3D(*args):
      return self._setVariableValues_alt_Z_3J_3D(*args)
    else:
      raise ValueError('Invalid argument list setVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setVariableValues(bool,array(int64,ndim=1),array(double,ndim=1))')
  def getSolverLIntInfo(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getSolverLIntInfo(string)

    Description
    -----------

    Fetch a solution information item from the solver 

    Parameters
    ----------

    name : string
    '''
    if False: pass
    elif mosek_fusion_Model._match_getSolverLIntInfo_S(*args):
      return self._getSolverLIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverLIntInfo_S(*args):
      return self._getSolverLIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverLIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverLIntInfo(string)')
  def setCallbackHandler(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.setCallbackHandler(System.CallbackHandler)

    Description
    -----------

    Attach a progress callback handler. 

    Parameters
    ----------

    h : System.CallbackHandler
    '''
    if False: pass
    elif mosek_fusion_Model._match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
      return self._setCallbackHandler_LSystem_4CallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
      return self._setCallbackHandler_alt_LSystem_4CallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setCallbackHandler(System.CallbackHandler)')
  def breakSolver(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.breakSolver()

    Description
    -----------

    Request that the solver terminates as soon as possible. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_breakSolver_(*args):
      return self._breakSolver_(*args)
    elif mosek_fusion_Model._match_alt_breakSolver_(*args):
      return self._breakSolver_alt_(*args)
    else:
      raise ValueError('Invalid argument list breakSolver('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.breakSolver()')
  def objective(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.objective(double)
      mosek.fusion.Model.objective(string,double)
      mosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)
      mosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)
      mosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)
      mosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)

    Description
    -----------

    Replace the objective expression.

    Parameters
    ----------

    c : double
        A constant scalar. 
    expr : mosek.fusion.Expression
        The objective expression. This must be an affine expression that evaluates to a scalar. 
    name : string
        Name of the objective. This may be any string, and it has no function except when writing the problem to an external file format.
    sense : mosek.fusion.ObjectiveSense
        The objective sense. Defines whether the objective must be minimized or maximized.
    '''
    if False: pass
    elif mosek_fusion_Model._match_objective_D(*args):
      return self._objective_D(*args)
    elif mosek_fusion_Model._match_alt_objective_D(*args):
      return self._objective_alt_D(*args)
    elif mosek_fusion_Model._match_objective_SD(*args):
      return self._objective_SD(*args)
    elif mosek_fusion_Model._match_alt_objective_SD(*args):
      return self._objective_alt_SD(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
      return self._objective_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list objective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.objective(double)\n\tmosek.fusion.Model.objective(string,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)')
  def getTask(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getTask()

    Description
    -----------

    Return the underlying MOSEK task object. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Model._match_getTask_(*args):
      return self._getTask_(*args)
    elif mosek_fusion_Model._match_alt_getTask_(*args):
      return self._getTask_alt_(*args)
    else:
      raise ValueError('Invalid argument list getTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getTask()')
  def getParameter(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Model.getParameter(string)

    Description
    -----------

    Get the parameter matching the given name. 

    Parameters
    ----------

    name : string
        The parameter's name.
    '''
    if False: pass
    elif mosek_fusion_Model._match_getParameter_S(*args):
      return self._getParameter_S(*args)
    elif mosek_fusion_Model._match_alt_getParameter_S(*args):
      return self._getParameter_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getParameter(string)')
  def __repr__(self): return 'mosek.fusion.Model'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2(m):
    o = Model.__new__(Model)
    o._ctor_init_Lmosek_4fusion_4Model_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Model_2(m)
  def _ctor_init_Lmosek_4fusion_4Model_2(self,m):
   mosek_fusion_BaseModel._ctor_init_Lmosek_4fusion_4BaseModel_2(self,m)
   _a_0=self
   self.__model_name = (m.__model_name)
   self.__acceptable_sol = (m.__acceptable_sol)
   self.__solutionptr = (m.__solutionptr)
   self.__sol_itr = ((m.__sol_itr)._clone_() if (((m.__sol_itr) is not None) ) else None)
   self.__sol_itg = ((m.__sol_itg)._clone_() if (((m.__sol_itg) is not None) ) else None)
   self.__sol_bas = ((m.__sol_bas)._clone_() if (((m.__sol_bas) is not None) ) else None)
   self.__num_task_afe = (m.__num_task_afe)
   self.__num_task_con = (m.__num_task_con)
   self.__num_task_acc = (m.__num_task_acc)
   self.__con_blocks = mosek_fusion_RowBlockManager._ctor_Lmosek_4fusion_4RowBlockManager_2((m.__con_blocks))
   self.__afe_blocks = mosek_fusion_RowBlockManager._ctor_Lmosek_4fusion_4RowBlockManager_2((m.__afe_blocks))
   self.__obj_blocks = mosek_fusion_RowBlockManager._ctor_Lmosek_4fusion_4RowBlockManager_2((m.__obj_blocks))
   self.__acc_block_map = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__acc_block_map))
   self.__acon_block_map = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__acon_block_map))
   self.__acon_acc = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_acc))
   self.__acon_afe = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_afe))
   self.__acon_elm_accid = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_elm_accid))
   self.__acon_elm_scale = mosek.fusion.Utils.Tools._arraycopy__3D((m.__acon_elm_scale))
   self.__acon_elm_ofs = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_elm_ofs))
   self.__acon_elm_afe = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_elm_afe))
   self.__task_numaferow = (m.__task_numaferow)
   self.__var_block_map = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__var_block_map))
   self.__var_block_acc_id = mosek.fusion.Utils.Tools._arraycopy__3I((m.__var_block_acc_id))
   self.__var_elm_acc_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__var_elm_acc_idx))
   self.__var_elm_acc_ofs = mosek.fusion.Utils.Tools._arraycopy__3I((m.__var_elm_acc_ofs))
   self.__barvar_num = 0
   self.__barvar_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_dim))
   self.__barvar_block_ptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_ptr))
   self.__barvar_block_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_dim))
   self.__barvar_block_elm_ptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_ptr))
   self.__barvar_block_elm_barj = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_barj))
   self.__barvar_block_elm_i = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_i))
   self.__barvar_block_elm_j = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_j))
   self.__vars = numpy.array([((m.__vars)[_a_1]._clone_Lmosek_4fusion_4Model_2(_a_0) if (((m.__vars)[_a_1] is not None) ) else None) for _a_1 in range(0,int(((m.__vars)).shape[0]))], dtype=numpy.dtype(object))
   self.__barvars = numpy.array([((m.__barvars)[_a_2]._clone_Lmosek_4fusion_4Model_2(_a_0) if (((m.__barvars)[_a_2] is not None) ) else None) for _a_2 in range(0,int(((m.__barvars)).shape[0]))], dtype=numpy.dtype(object))
   self.__var_map = (m.__var_map)._clone_()
   self.__cons = numpy.array([((m.__cons)[_a_3]._clone_Lmosek_4fusion_4Model_2(_a_0) if (((m.__cons)[_a_3] is not None) ) else None) for _a_3 in range(0,int(((m.__cons)).shape[0]))], dtype=numpy.dtype(object))
   self.__acons = numpy.array([((m.__acons)[_a_4]._clone_Lmosek_4fusion_4Model_2(_a_0) if (((m.__acons)[_a_4] is not None) ) else None) for _a_4 in range(0,int(((m.__acons)).shape[0]))], dtype=numpy.dtype(object))
   self.__con_map = (m.__con_map)._clone_()
   self.__numparameter = (m.__numparameter)
   self.__parameters = (None if (((m.__parameters) is None) ) else numpy.array([((m.__parameters)[_a_5]._clone_Lmosek_4fusion_4Model_2(_a_0) if (((m.__parameters)[_a_5] is not None) ) else None) for _a_5 in range(0,int(((m.__parameters)).shape[0]))], dtype=numpy.dtype(object)))
   self.__par_map = (m.__par_map)._clone_()
   self.__param_num = (m.__param_num)
   self.__param_value = (mosek.fusion.Utils.Tools._arraycopy__3D((m.__param_value)) if (((m.__param_value) is not None) ) else None)
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__bfixidx = (m.__bfixidx)
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_SI(name,basesize):
    o = Model.__new__(Model)
    o._ctor_init_SI(name,basesize)
    return o
  @staticmethod
  def __match_ctor_SI(*args):
    if len(args) != 2: return False
    name,basesize, = args
    return (__arg_match_S__(name) and __arg_match_I__(basesize))
  @staticmethod
  def __match_alt_ctor_SI(*args):
    if len(args) != 2: return False
    name,basesize, = args
    return (__arg_alt_match_S__(name) and __arg_alt_match_I__(basesize))
  def _ctor_alt_init_SI(self,name,basesize):
    self._ctor_init_SI(name,numpy.int32(basesize))
  def _ctor_init_SI(self,name,basesize):
   mosek_fusion_BaseModel._ctor_init_SS(self,name,"")
   self.__model_name = name
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.Optimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__sol_itr = None
   self.__sol_itg = None
   self.__sol_bas = None
   self.__num_task_afe = 0
   self.__num_task_con = 0
   self.__num_task_acc = 0
   self.__con_blocks = mosek_fusion_RowBlockManager._ctor_()
   self.__afe_blocks = mosek_fusion_RowBlockManager._ctor_()
   self.__obj_blocks = mosek_fusion_RowBlockManager._ctor_()
   self.__acc_block_map = mosek_fusion_LinkedBlocks._ctor_()
   self.__acon_block_map = mosek_fusion_LinkedBlocks._ctor_()
   self.__task_numaferow = 0
   self.__acon_acc = numpy.zeros((self.__acon_block_map._block_1capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_afe = numpy.zeros((self.__acon_block_map._block_1capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_elm_accid = numpy.zeros((self.__acon_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_elm_scale = numpy.array([1.0 for _a_0 in range(0,self.__acon_block_map._capacity_())], dtype=numpy.dtype(numpy.float64))
   self.__acon_elm_ofs = numpy.zeros((self.__acon_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_elm_afe = numpy.zeros((self.__acon_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__var_block_map = mosek_fusion_LinkedBlocks._ctor_()
   self.__var_block_acc_id = numpy.zeros((self.__var_block_map._block_1capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__var_elm_acc_idx = numpy.zeros((self.__var_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__var_elm_acc_ofs = numpy.zeros((self.__var_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__barvar_num = 0
   self.__barvar_dim = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_ptr = numpy.zeros(((basesize + 1),), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_dim = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_ptr = numpy.zeros(((basesize + 1),), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_barj = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_i = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_j = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__vars = numpy.array([None for _a_1 in range(0,(basesize * 8))], dtype=numpy.dtype(object))
   self.__barvars = numpy.array([None for _a_2 in range(0,basesize)], dtype=numpy.dtype(object))
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__cons = numpy.array([None for _a_3 in range(0,(basesize * 8))], dtype=numpy.dtype(object))
   self.__acons = numpy.array([None for _a_4 in range(0,(basesize * 8))], dtype=numpy.dtype(object))
   self.__con_map = mosek.fusion.Utils.StringIntMap()
   self.__numparameter = 0
   self.__parameters = None
   self.__par_map = mosek.fusion.Utils.StringIntMap()
   self.__param_num = 0
   self.__param_value = None
   _a_5=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
   _a_6=self.__linearvar_1alloc_I_3I(1,_a_5)
   self.__bfixidx = _a_5[0]
   self._task_1var_1putboundlist_1fx__3I_3D(numpy.array([self.__bfixidx], dtype=numpy.dtype(numpy.int32)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)))
   self._task_1var_1name_IS(self.__bfixidx,"1.0")
   self._task_1append_1domain_1empty_()
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_I(basesize):
    o = Model.__new__(Model)
    o._ctor_init_I(basesize)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    basesize, = args
    return (__arg_match_I__(basesize))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    basesize, = args
    return (__arg_alt_match_I__(basesize))
  def _ctor_alt_init_I(self,basesize):
    self._ctor_init_I(numpy.int32(basesize))
  def _ctor_init_I(self,basesize):
   mosek_fusion_Model._ctor_init_SI(self,"",basesize)
  @staticmethod
  def _ctor_S(name):
    o = Model.__new__(Model)
    o._ctor_init_S(name)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_match_S__(name))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_alt_match_S__(name))
  def _ctor_alt_init_S(self,name):
    self._ctor_init_S(name)
  def _ctor_init_S(self,name):
   mosek_fusion_Model._ctor_init_SI(self,name,128)
  @staticmethod
  def _ctor_():
    o = Model.__new__(Model)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_Model._ctor_init_S(self,"")
  @staticmethod
  def _match_disjunction_S_3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match__3Lmosek_4fusion_4Term_2__(_a_1))
  @staticmethod
  def _match_alt_disjunction_S_3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3Lmosek_4fusion_4Term_2__(_a_1))
  def _disjunction_alt_S_3Lmosek_4fusion_4Term_2(self,_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(object))
   _1_res = self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _disjunction_S_3Lmosek_4fusion_4Term_2(self,_a_0,_a_1):
   _a_2=int((_a_1).shape[0])
   _a_3=0
   _a_4=0
   _a_5=0
   _a_6=0
   for _a_7 in range(0,_a_2):
    _a_3 += _a_1[_a_7]._size_()
    _a_4 += _a_1[_a_7]._num_()
    _a_6 += _a_1[_a_7]._numaccrows_()
    _a_5 += _a_1[_a_7]._numaccterms_()
   _a_8=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_9=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
   _a_10=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.float64))
   _a_11=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int64))
   _a_12=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   _a_13=self.__afe_1allocate__3I(_a_8)
   _a_14=0
   _a_15=0
   _a_16=0
   _a_17=0
   for _a_18 in range(0,_a_2):
    for _a_19 in range(0,_a_1[_a_18]._num_()):
     _a_20=(_a_1[_a_18]._domains)[_a_19]
     _a_21=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2((_a_1[_a_18]._exprs)[_a_19])))
     _a_21._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
     self.__rs._pop_1expr_()
     _a_22=(self.__rs.i32)
     _a_23=(self.__rs.i64)
     _a_24=(self.__rs.f64)
     _a_25=(self.__rs.nd)
     _a_26=(self.__rs.shape_base)
     _a_27=(self.__rs.nelem)
     _a_28=(self.__rs.nnz)
     _a_29=(self.__rs.ncodeatom)
     _a_30=(self.__rs.hassp)
     _a_31=(self.__rs.ptr_base)
     _a_32=(self.__rs.nidxs_base)
     _a_33=(self.__rs.cof_base)
     _a_34=(self.__rs.code_base)
     _a_35=(self.__rs.codeptr_base)
     _a_36=(self.__rs.cconst_base)
     _a_37=numpy.array([_a_22[(_a_26 + _a_38)] for _a_38 in range(0,_a_25)], dtype=numpy.dtype(numpy.int32))
     self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_a_8,_a_17,self.__rs,_a_27,_a_28,_a_31,_a_32,_a_33)
     if ((_a_20.dom)==mosek.fusion.DJCDomainType.InRange):
      _a_39=(_a_20.b)
      _a_40=(_a_20.par)
      fragments._c_closure_1(_a_9,_a_10,_a_8,_a_17,_a_16,_a_39,_a_27,_a_40) 
      _a_11[_a_15] = self._task_1append_1domain_1rpos_I(_a_27)
      _a_11[(_a_15 + 1)] = self._task_1append_1domain_1rneg_I(_a_27)
      _a_12[_a_18] += 2
      _a_15 += 2
      _a_16 += (_a_27 * 2)
     elif (((_a_20.dom)==mosek.fusion.DJCDomainType.EqualTo) or (((_a_20.dom)==mosek.fusion.DJCDomainType.LessThan) or (((_a_20.dom)==mosek.fusion.DJCDomainType.GreaterThan) or ((_a_20.dom)==mosek.fusion.DJCDomainType.IsFree)))):
      _a_41=(_a_20.b)
      fragments._c_closure_2(_a_9,_a_10,_a_8,_a_17,_a_16,_a_41,_a_27) 
      if ((_a_20.dom)==mosek.fusion.DJCDomainType.EqualTo):
       _a_11[_a_15] = self._task_1append_1domain_1rzero_I(_a_27)
      elif ((_a_20.dom)==mosek.fusion.DJCDomainType.LessThan):
       _a_11[_a_15] = self._task_1append_1domain_1rneg_I(_a_27)
      elif ((_a_20.dom)==mosek.fusion.DJCDomainType.GreaterThan):
       _a_11[_a_15] = self._task_1append_1domain_1rpos_I(_a_27)
      else:
       _a_11[_a_15] = self._task_1append_1domain_1r_I(_a_27)
      _a_12[_a_18] += 1
      _a_15 += 1
      _a_16 += _a_27
     else:
      raise mosek_fusion_UnexpectedError._ctor_S("Not implemented: Non-linear conic DJC constraints")
     if (_a_29 > 0):
      self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([_a_8[(_a_17 + _a_42)] for _a_42 in range(0,_a_27)], dtype=numpy.dtype(numpy.int32)),_a_31,_a_32,_a_35,_a_34,_a_36)
     _a_17 += _a_27
     _a_14 += 1
   _a_43=self._task_1append_1djc_J(1)
   self._task_1putdjcslice_JJ_3J_3J_3J_3J_3D(_a_43,(_a_43 + 1),numpy.array([numpy.int64(_a_2)], dtype=numpy.dtype(numpy.int64)),_a_12,_a_11,numpy.array([_a_9[_a_44] for _a_44 in range(0,int((_a_9).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_10)
   if (int(len(_a_0)) > 0):
    self._task_1djc_1name_JS(_a_43,mosek.fusion.Utils.StringBuffer()._a_S(_a_0)._a_S("[")._a_S("]")._toString_())
   return (mosek_fusion_Disjunction._ctor_J(_a_43))
  @staticmethod
  def _match_disjunction__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Term_2__(_a_0))
  @staticmethod
  def _match_alt_disjunction__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Term_2__(_a_0))
  def _disjunction_alt__3Lmosek_4fusion_4Term_2(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = self._disjunction__3Lmosek_4fusion_4Term_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _disjunction__3Lmosek_4fusion_4Term_2(self,_a_0):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",_a_0))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4DisjunctionTerms_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(_a_0))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4DisjunctionTerms_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(_a_0))
  def _disjunction_alt_Lmosek_4fusion_4DisjunctionTerms_2(self,_t__a_0):
    return self._disjunction_Lmosek_4fusion_4DisjunctionTerms_2(_a_0)
  def _disjunction_Lmosek_4fusion_4DisjunctionTerms_2(self,_a_0):
   return (self._disjunction__3Lmosek_4fusion_4Term_2((_a_0._terms)))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4DisjunctionTerms_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(_a_1))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4DisjunctionTerms_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(_a_1))
  def _disjunction_alt_SLmosek_4fusion_4DisjunctionTerms_2(self,_t__a_0,_t__a_1):
    return self._disjunction_SLmosek_4fusion_4DisjunctionTerms_2(_a_0,_a_1)
  def _disjunction_SLmosek_4fusion_4DisjunctionTerms_2(self,_a_0,_a_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,(_a_1._terms)))
  @staticmethod
  def _match_disjunction_S_3Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match__3Lmosek_4fusion_4ExprDomain_2__(_a_1))
  @staticmethod
  def _match_alt_disjunction_S_3Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3Lmosek_4fusion_4ExprDomain_2__(_a_1))
  def _disjunction_alt_S_3Lmosek_4fusion_4ExprDomain_2(self,_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(object))
   _1_res = self._disjunction_S_3Lmosek_4fusion_4ExprDomain_2(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _disjunction_S_3Lmosek_4fusion_4ExprDomain_2(self,_a_0,_a_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,numpy.array([_a_1[_a_2]._toDJCTerm_() for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction__3Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4ExprDomain_2__(_a_0))
  @staticmethod
  def _match_alt_disjunction__3Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4ExprDomain_2__(_a_0))
  def _disjunction_alt__3Lmosek_4fusion_4ExprDomain_2(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = self._disjunction__3Lmosek_4fusion_4ExprDomain_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _disjunction__3Lmosek_4fusion_4ExprDomain_2(self,_a_0):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_a_0[_a_1]._toDJCTerm_() for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4ExprDomain_2__(_a_1))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ExprDomain_2__(_a_1))
  def _disjunction_alt_SLmosek_4fusion_4ExprDomain_2(self,_t__a_0,_t__a_1):
    return self._disjunction_SLmosek_4fusion_4ExprDomain_2(_a_0,_a_1)
  def _disjunction_SLmosek_4fusion_4ExprDomain_2(self,_a_0,_a_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,numpy.array([_a_1._toDJCTerm_()], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprDomain_2__(_a_0))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4ExprDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprDomain_2__(_a_0))
  def _disjunction_alt_Lmosek_4fusion_4ExprDomain_2(self,_t__a_0):
    return self._disjunction_Lmosek_4fusion_4ExprDomain_2(_a_0)
  def _disjunction_Lmosek_4fusion_4ExprDomain_2(self,_a_0):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_a_0._toDJCTerm_()], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Term_2__(_a_0) and __arg_match_Lmosek_4fusion_4Term_2__(_a_1) and __arg_match_Lmosek_4fusion_4Term_2__(_a_2))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Term_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_2))
  def _disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_a_0,_a_1,_a_2)
  def _disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_a_0,_a_1,_a_2):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Term_2__(_a_0) and __arg_match_Lmosek_4fusion_4Term_2__(_a_1))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Term_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_1))
  def _disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__a_0,_t__a_1):
    return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_a_0,_a_1)
  def _disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_a_0,_a_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_a_0,_a_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Term_2__(_a_0))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Term_2__(_a_0))
  def _disjunction_alt_Lmosek_4fusion_4Term_2(self,_t__a_0):
    return self._disjunction_Lmosek_4fusion_4Term_2(_a_0)
  def _disjunction_Lmosek_4fusion_4Term_2(self,_a_0):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_a_0], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Term_2__(_a_1) and __arg_match_Lmosek_4fusion_4Term_2__(_a_2) and __arg_match_Lmosek_4fusion_4Term_2__(_a_3))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_3))
  def _disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_a_0,_a_1,_a_2,_a_3)
  def _disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_a_0,_a_1,_a_2,_a_3):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,numpy.array([_a_1,_a_2,_a_3], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Term_2__(_a_1) and __arg_match_Lmosek_4fusion_4Term_2__(_a_2))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_2))
  def _disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_a_0,_a_1,_a_2)
  def _disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_a_0,_a_1,_a_2):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,numpy.array([_a_1,_a_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Term_2__(_a_1))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_a_1))
  def _disjunction_alt_SLmosek_4fusion_4Term_2(self,_t__a_0,_t__a_1):
    return self._disjunction_SLmosek_4fusion_4Term_2(_a_0,_a_1)
  def _disjunction_SLmosek_4fusion_4Term_2(self,_a_0,_a_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_a_0,numpy.array([_a_1], dtype=numpy.dtype(object))))
  def _formstConstr_alt_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = self._formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_a_0,_a_1,_a_2):
   return (_a_0)
  def __acon_1release_alt_I(self,_t__a_0):
    return self.__acon_1release_I(numpy.int32(__a_0))
  def __acon_1release_I(self,_a_0):
   _a_1=self.__acon_block_map._blocksize_I(_a_0)
   if (_a_1 >= 0):
    _a_2=self.__acc_block_map._blocksize_I(self.__acon_acc[_a_0])
    _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    _a_4=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    self.__acc_block_map._get_I_3II(self.__acon_acc[_a_0],_a_3,0)
    self.__acc_block_map._free_I(self.__acon_acc[_a_0])
    self.__afe_blocks._get_I_3II(self.__acon_afe[_a_0],_a_4,0)
    self.__afe_1release_I(self.__acon_afe[_a_0])
    self.__acon_block_map._free_I(_a_0)
    self._task_1clearafelist__3J(numpy.array([_a_4[_a_5] for _a_5 in range(0,_a_1)], dtype=numpy.dtype(numpy.int64)))
    self._task_1putacclist__3J_3J_3J_3D(numpy.array([_a_3[_a_6] for _a_6 in range(0,_a_2)], dtype=numpy.dtype(numpy.int64)),numpy.array([0 for _a_7 in range(0,_a_2)], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
  def __acon_1allocate_alt_JII_3D_3I_3I(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.int64(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.float64))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int32))
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__acon_1allocate_JII_3D_3I_3I(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __acon_1allocate_JII_3D_3I_3I(self,_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   _a_6=(_a_2 * _a_1)
   _a_7=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
   _a_8=self.__acon_block_map._alloc_I(_a_6)
   _a_9=self.__acc_block_map._alloc_I(_a_2)
   _a_10=self.__afe_1allocate__3I(_a_4)
   self.__acon_block_map._get_I_3II(_a_8,_a_7,0)
   self.__acc_block_map._get_I_3II(_a_9,_a_5,0)
   _a_11=self.__acon_block_map._block_1capacity_()
   _a_12=self.__acon_block_map._capacity_()
   if (_a_11 > int((self.__acon_acc).shape[0])):
    _a_13=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
    _a_14=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_acc,0,_a_13,0,int((self.__acon_acc).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_afe,0,_a_14,0,int((self.__acon_afe).shape[0]))
    self.__acon_acc = _a_13
    self.__acon_afe = _a_14
   self.__acon_acc[_a_8] = _a_9
   self.__acon_afe[_a_8] = _a_10
   if (_a_8 >= int((self.__acons).shape[0])):
    _a_15=numpy.array([None for _a_16 in range(0,(int((self.__acons).shape[0]) * 2))], dtype=numpy.dtype(object))
    for _a_17 in range(0,int((self.__acons).shape[0])):
     _a_15[_a_17] = self.__acons[_a_17]
    self.__acons = _a_15
   if (_a_12 > int((self.__acon_elm_accid).shape[0])):
    _a_18=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    _a_19=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.float64))
    _a_20=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    _a_21=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_elm_accid,0,_a_18,0,int((self.__acon_elm_accid).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__acon_elm_scale,0,_a_19,0,int((self.__acon_elm_scale).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_elm_ofs,0,_a_20,0,int((self.__acon_elm_ofs).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_elm_afe,0,_a_21,0,int((self.__acon_elm_afe).shape[0]))
    self.__acon_elm_accid = _a_18
    self.__acon_elm_ofs = _a_20
    self.__acon_elm_afe = _a_21
    self.__acon_elm_scale = _a_19
   _a_22=0
   _a_22 = fragments._c_closure_3(_a_5,_a_22)
   _a_22 = numpy.int32(_a_22) # postprocess
   _a_22 += 1
   _a_23=self._task_1numacc_()
   if (_a_23 < _a_22):
    self._task_1append_1accs_JI_3J_3D(0,(_a_22 - _a_23),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   self._task_1putacclist__3J_3J_3J_3D(numpy.array([_a_5[_a_24] for _a_24 in range(0,int((_a_5).shape[0]))], dtype=numpy.dtype(numpy.int64)),numpy.array([_a_0 for _a_25 in range(0,int((_a_5).shape[0]))], dtype=numpy.dtype(numpy.int64)),numpy.array([_a_4[_a_26] for _a_26 in range(0,int((_a_4).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_3)
   fragments._c_closure_4(_a_5,self.__acon_elm_accid,self.__acon_elm_afe,self.__acon_elm_ofs,self.__acon_elm_scale,_a_7,_a_4,_a_1,_a_2) 
   return numpy.int32(_a_8)
  def __afe_1release_alt_I(self,_t__a_0):
    return self.__afe_1release_I(numpy.int32(__a_0))
  def __afe_1release_I(self,_a_0):
   _a_1=numpy.zeros((self.__afe_blocks._blocksize_I(_a_0),), dtype=numpy.dtype(numpy.int32))
   self.__afe_blocks._release_I_3I(_a_0,_a_1)
   self._task_1clearafelist__3J(numpy.array([_a_1[_a_2] for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int64)))
  def __afe_1allocate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__afe_1allocate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __afe_1allocate__3I(self,_a_0):
   _a_1=self.__afe_blocks._allocate__3I(_a_0)
   if (int((_a_0).shape[0]) > 0):
    _a_2=self._task_1numafe_()
    _a_3=_a_0[0]
    _a_3 = fragments._c_closure_5(_a_3,_a_0)
    _a_3 = numpy.int32(_a_3) # postprocess
    if ((_a_3 + 1) > _a_2):
     _a_4=((_a_3 + 1) - _a_2)
     self._task_1append_1afes_J(_a_4)
     self.__task_numaferow += _a_4
   return numpy.int32(_a_1)
  def __con_1release_alt_I(self,_t__a_0):
    return self.__con_1release_I(numpy.int32(__a_0))
  def __con_1release_I(self,_a_0):
   _a_1=self.__con_blocks._blocksize_I(_a_0)
   if (_a_1 >= 0):
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    self.__con_blocks._release_I_3I(_a_0,_a_2)
    self.__cons[_a_0] = None
    self._task_1con_1putboundlist_1fr__3I(_a_2)
  def __con_1allocate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__con_1allocate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __con_1allocate__3I(self,_a_0):
   _a_1=self.__con_blocks._allocate__3I(_a_0)
   if (int((_a_0).shape[0]) > 0):
    _a_2=_a_0[0]
    _a_2 = fragments._c_closure_6(_a_2,_a_0)
    _a_2 = numpy.int32(_a_2) # postprocess
    if ((_a_2 + 1) > self.__num_task_con):
     _a_3=((_a_2 + 1) - self.__num_task_con)
     self._task_1append_1con_I(_a_3)
     self.__num_task_con += _a_3
   if (_a_1 >= int((self.__cons).shape[0])):
    _a_4=numpy.array([None for _a_5 in range(0,(int((self.__cons).shape[0]) * 2))], dtype=numpy.dtype(object))
    for _a_6 in range(0,int((self.__cons).shape[0])):
     _a_4[_a_6] = self.__cons[_a_6]
    self.__cons = _a_4
   return numpy.int32(_a_1)
  def __barvar_1alloc_alt_II_3I_3J(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int64))
   _1_res = self.__barvar_1alloc_II_3I_3J(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __barvar_1alloc_II_3I_3J(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=self.__barvar_num
   self.__barvar_num += 1
   _a_5=((_a_0 * (_a_0 + 1)) // 2)
   _a_6=(_a_5 * _a_1)
   _a_7=self.__barvar_block_ptr[_a_4]
   _a_8=int((self.__barvar_block_dim).shape[0])
   _a_9=self.__barvar_block_elm_ptr[_a_4]
   _a_10=int((self.__barvar_block_elm_barj).shape[0])
   if (_a_8 < (_a_7 + 1)):
    _a_11=numpy.zeros(((int((self.__barvar_block_dim).shape[0]) * 2),), dtype=numpy.dtype(numpy.int32))
    _a_12=numpy.zeros((((int((self.__barvar_block_dim).shape[0]) * 2) + 1),), dtype=numpy.dtype(numpy.int32))
    _a_13=numpy.zeros((((int((self.__barvar_block_dim).shape[0]) * 2) + 1),), dtype=numpy.dtype(numpy.int32))
    _a_14=numpy.array([None for _a_15 in range(0,((int((self.__barvar_block_dim).shape[0]) * 2) + 1))], dtype=numpy.dtype(object))
    for _a_16 in range(0,int((self.__barvars).shape[0])):
     _a_14[_a_16] = self.__barvars[_a_16]
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_dim,0,_a_11,0,int((self.__barvar_block_dim).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_ptr,0,_a_12,0,int((self.__barvar_block_ptr).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_ptr,0,_a_13,0,int((self.__barvar_block_elm_ptr).shape[0]))
    self.__barvar_block_dim = _a_11
    self.__barvar_block_ptr = _a_12
    self.__barvar_block_elm_ptr = _a_13
    self.__barvars = _a_14
   if (_a_10 < (_a_9 + _a_6)):
    _a_17=((_a_10 + _a_6) - _a_9)
    if (_a_17 < _a_10):
     _a_17 = _a_10
    _a_18=(_a_10 + _a_17)
    _a_19=numpy.zeros((_a_18,), dtype=numpy.dtype(numpy.int32))
    _a_20=numpy.zeros((_a_18,), dtype=numpy.dtype(numpy.int32))
    _a_21=numpy.zeros((_a_18,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_barj,0,_a_19,0,int((self.__barvar_block_elm_barj).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_i,0,_a_20,0,int((self.__barvar_block_elm_i).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_j,0,_a_21,0,int((self.__barvar_block_elm_j).shape[0]))
    self.__barvar_block_elm_barj = _a_19
    self.__barvar_block_elm_i = _a_20
    self.__barvar_block_elm_j = _a_21
   _a_22=self._task_1numbarvar_()
   fragments._c_closure_7(_a_2,_a_22,_a_1) 
   if ((_a_22 + _a_1) >= int((self.__barvar_dim).shape[0])):
    _a_23=((_a_22 + _a_1) - int((self.__barvar_dim).shape[0]))
    if (_a_23 < int((self.__barvar_dim).shape[0])):
     _a_23 = int((self.__barvar_dim).shape[0])
    _a_24=(_a_23 + int((self.__barvar_dim).shape[0]))
    _a_25=numpy.zeros((_a_24,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_dim,0,_a_25,0,int((self.__barvar_dim).shape[0]))
    self.__barvar_dim = _a_25
   self.__barvar_block_dim[_a_4] = _a_0
   self.__barvar_block_ptr[(_a_4 + 1)] = (self.__barvar_block_ptr[_a_4] + _a_1)
   self.__barvar_block_elm_ptr[(_a_4 + 1)] = (self.__barvar_block_elm_ptr[_a_4] + _a_6)
   fragments._c_closure_8(self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,self.__barvar_block_elm_ptr,self.__barvar_dim,_a_4,_a_0,_a_22,_a_3,_a_1) 
   _a_26=self._task_1append_1barvar_II(_a_0,_a_1)
   return numpy.int32(_a_4)
  def __conicvar_1alloc_alt_JII_3I_3I(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.int64(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__conicvar_1alloc_JII_3I_3I(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __conicvar_1alloc_JII_3I_3I(self,_a_0,_a_1,_a_2,_a_3,_a_4):
   _a_5=(_a_1 * _a_2)
   _a_6=self.__linearvar_1alloc_I_3I(_a_5,_a_4)
   _a_7=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.float64))
   _a_8=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_9=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_10=self.__acon_1allocate_JII_3D_3I_3I(_a_0,_a_1,_a_2,_a_7,_a_9,_a_3)
   self.__var_block_acc_id[_a_6] = _a_10
   fragments._c_closure_9(_a_3,_a_1,_a_5,_a_4,self.__var_elm_acc_idx,self.__var_elm_acc_ofs) 
   self._task_1putafeflist__3J_3I_3I_3D_3D(numpy.array([_a_9[_a_11] for _a_11 in range(0,int((_a_9).shape[0]))], dtype=numpy.dtype(numpy.int64)),numpy.array([_a_12 for _a_12 in range(0,(_a_5 + 1))], dtype=numpy.dtype(numpy.int32)),_a_4,numpy.array([1.0 for _a_13 in range(0,_a_5)], dtype=numpy.dtype(numpy.float64)),numpy.array([0.0 for _a_14 in range(0,_a_5)], dtype=numpy.dtype(numpy.float64)))
   return numpy.int32(_a_6)
  def __linearvar_1alloc_alt_I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__linearvar_1alloc_I_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __linearvar_1alloc_I_3I(self,_a_0,_a_1):
   _a_2=self.__var_block_map._alloc_I(_a_0)
   _a_3=(self.__var_block_map._maxidx_I(_a_2) + 1)
   _a_4=self.__var_block_map._capacity_()
   _a_5=self.__var_block_map._block_1capacity_()
   self.__var_block_map._get_I_3II(_a_2,_a_1,0)
   if (self._task_1numvar_() < _a_3):
    self._task_1append_1var_I((_a_3 - self._task_1numvar_()))
   if (_a_2 >= int((self.__vars).shape[0])):
    _a_6=numpy.array([None for _a_7 in range(0,(int((self.__vars).shape[0]) * 2))], dtype=numpy.dtype(object))
    for _a_8 in range(0,int((self.__vars).shape[0])):
     _a_6[_a_8] = self.__vars[_a_8]
    self.__vars = _a_6
   if (_a_5 > int((self.__var_block_acc_id).shape[0])):
    _a_9=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__var_block_acc_id,0,_a_9,0,int((self.__var_block_acc_id).shape[0]))
    self.__var_block_acc_id = _a_9
   if (_a_4 > int((self.__var_elm_acc_idx).shape[0])):
    _a_10=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__var_elm_acc_idx,0,_a_10,0,int((self.__var_elm_acc_idx).shape[0]))
    self.__var_elm_acc_idx = _a_10
    _a_11=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__var_elm_acc_ofs,0,_a_11,0,int((self.__var_elm_acc_ofs).shape[0]))
    self.__var_elm_acc_ofs = _a_11
   self.__var_block_acc_id[_a_2] = (- 1)
   fragments._c_closure_10(_a_0,_a_1,self.__var_elm_acc_idx) 
   return numpy.int32(_a_2)
  def _make_1continuous_alt__3J(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _1_res = self._make_1continuous__3J(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _make_1continuous__3J(self,_a_0):
   _a_1=0
   _a_1 = fragments._c_closure_11(_a_1,_a_0)
   _a_1 = numpy.int32(_a_1) # postprocess
   _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
   _a_3=0
   _a_3 = fragments._c_closure_12(_a_0,_a_3,_a_2)
   _a_3 = numpy.int32(_a_3) # postprocess
   self._task_1var_1putcontlist__3I(_a_2)
  def _make_1integer_alt__3J(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _1_res = self._make_1integer__3J(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _make_1integer__3J(self,_a_0):
   _a_1=0
   _a_1 = fragments._c_closure_13(_a_1,_a_0)
   _a_1 = numpy.int32(_a_1) # postprocess
   _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
   _a_3=0
   _a_3 = fragments._c_closure_14(_a_0,_a_3,_a_2)
   _a_3 = numpy.int32(_a_3) # postprocess
   self._task_1var_1putintlist__3I(_a_2)
  @staticmethod
  def _match_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Z__(_a_0))
  @staticmethod
  def _match_alt_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Z__(_a_0))
  @staticmethod
  def _putlicensewait_alt_Z(_t__a_0):
    return mosek_fusion_Model._putlicensewait_Z(_a_0)
  @staticmethod
  def _putlicensewait_Z(_a_0):
   mosek.fusion.BaseModel._env_1putlicensewait_Z(_a_0)
  @staticmethod
  def _match_putlicensepath_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_putlicensepath_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  @staticmethod
  def _putlicensepath_alt_S(_t__a_0):
    return mosek_fusion_Model._putlicensepath_S(_a_0)
  @staticmethod
  def _putlicensepath_S(_a_0):
   mosek.fusion.BaseModel._env_1putlicensepath_S(_a_0)
  @staticmethod
  def _match_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _putlicensecode_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Model._putlicensecode__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _putlicensecode__3I(_a_0):
   mosek.fusion.BaseModel._env_1putlicensecode__3I(_a_0)
  @staticmethod
  def _match_dispose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dispose_(*args):
    if len(args) != 0: return False
    return True
  def _dispose_alt_(self,):
    return self._dispose_()
  def _dispose_(self,):
   for _a_0 in range(0,int((self.__vars).shape[0])):
    self.__vars[_a_0] = None
   for _a_1 in range(0,int((self.__cons).shape[0])):
    self.__cons[_a_1] = None
   for _a_2 in range(0,int((self.__acons).shape[0])):
    self.__acons[_a_2] = None
   for _a_3 in range(0,int((self.__barvars).shape[0])):
    self.__barvars[_a_3] = None
   if (self.__parameters is not None):
    for _a_4 in range(0,int((self.__parameters).shape[0])):
     self.__parameters[_a_4] = None
   mosek_fusion_BaseModel._dispose_(self)
  @staticmethod
  def _match_getTask_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getTask_(*args):
    if len(args) != 0: return False
    return True
  def _getTask_alt_(self,):
    return self._getTask_()
  def _getTask_(self,):
   return (self._task_1get_())
  @staticmethod
  def _match_getConstraintDuals_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Z__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_getConstraintDuals_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Z__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match_I__(_a_3))
  def _getConstraintDuals_alt_Z_3I_3DI(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.int32(_t__a_3)
   _1_res = self._getConstraintDuals_Z_3I_3DI(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getConstraintDuals_Z_3I_3DI(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_1).shape[0])
   _a_5=self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _a_6=self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   for _a_7 in range(0,_a_4):
    if (_a_1[_a_7] >= 0):
     if _a_0:
      _a_2[(_a_3 + _a_7)] = _a_5[_a_1[_a_7]]
     else:
      _a_2[(_a_3 + _a_7)] = (- _a_6[_a_1[_a_7]])
    else:
     raise mosek_fusion_SolutionError._ctor_S("Requested invalid solution item")
  @staticmethod
  def _match_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Z__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Z__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match_I__(_a_3))
  def _getConstraintValues_alt_Z_3I_3DI(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.int32(_t__a_3)
   _1_res = self._getConstraintValues_Z_3I_3DI(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getConstraintValues_Z_3I_3DI(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_1).shape[0])
   if _a_0:
    _a_5=self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_6=self._getSolution_1accx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_7=self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_15(_a_7,_a_6,self.__acon_elm_accid,self.__acon_elm_ofs,self.__acon_elm_scale,_a_4,_a_1,_a_3,_a_2,_a_5) 
   else:
    _a_8=self._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_9=self._getSolution_1accy_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_10=self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_16(_a_10,_a_9,self.__acon_elm_accid,self.__acon_elm_ofs,self.__acon_elm_scale,_a_4,_a_1,_a_3,_a_2,_a_8) 
  @staticmethod
  def _match_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Z__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3D__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Z__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match_I__(_a_3))
  def _getVariableDuals_alt_Z_3J_3DI(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.int32(_t__a_3)
   _1_res = self._getVariableDuals_Z_3J_3DI(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getVariableDuals_Z_3J_3DI(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_1).shape[0])
   if _a_0:
    _a_5=self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_17(_a_4,_a_1,_a_3,_a_2,_a_5) 
   else:
    _a_6=self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_18(_a_4,_a_1,_a_3,_a_2,_a_6) 
  @staticmethod
  def _match_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Z__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3D__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Z__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match_I__(_a_3))
  def _getVariableValues_alt_Z_3J_3DI(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.int32(_t__a_3)
   _1_res = self._getVariableValues_Z_3J_3DI(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getVariableValues_Z_3J_3DI(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_1).shape[0])
   self.__barvar_num = self._task_1numbarvar_()
   if _a_0:
    _a_5=self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_6=(self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if ((self.__barvar_num > 0) ) else None)
    fragments._c_closure_19(_a_6,_a_4,_a_1,_a_3,_a_2,_a_5) 
   else:
    _a_7=self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_8=(self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if ((self.__barvar_num > 0) ) else None)
    _a_9=self._getSolution_1accy_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _a_10=self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_20(_a_10,_a_9,_a_8,_a_4,_a_1,_a_3,_a_2,self.__var_elm_acc_idx,self.__var_elm_acc_ofs,_a_7) 
  @staticmethod
  def _match_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Z__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Z__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3D__(_a_2))
  def _setVariableValues_alt_Z_3J_3D(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setVariableValues_Z_3J_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setVariableValues_Z_3J_3D(self,_a_0,_a_1,_a_2):
   if _a_0:
    _a_3=0
    _a_3 = fragments._c_closure_21(_a_1,_a_3)
    _a_3 = numpy.int32(_a_3) # postprocess
    _a_4=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
    _a_6=0
    _a_6 = fragments._c_closure_22(_a_6,_a_1,_a_4,_a_5,_a_2)
    _a_6 = numpy.int32(_a_6) # postprocess
    self._setSolution_1xx__3I_3D(_a_4,_a_5)
   else:
    pass
  @staticmethod
  def _match_writeTaskNoFlush_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_writeTaskNoFlush_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _writeTaskNoFlush_alt_S(self,_t__a_0):
    return self._writeTaskNoFlush_S(_a_0)
  def _writeTaskNoFlush_S(self,_a_0):
   self._task_1write_S(_a_0)
  @staticmethod
  def _match_writeTaskStream_SLSystem_4DataStream_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_LSystem_4DataStream_2__(_a_1))
  @staticmethod
  def _match_alt_writeTaskStream_SLSystem_4DataStream_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_LSystem_4DataStream_2__(_a_1))
  def _writeTaskStream_alt_SLSystem_4DataStream_2(self,_t__a_0,_t__a_1):
    return self._writeTaskStream_SLSystem_4DataStream_2(_a_0,_a_1)
  def _writeTaskStream_SLSystem_4DataStream_2(self,_a_0,_a_1):
   self.__flush_1parameters_()
   self._task_1write_1stream_SLSystem_4DataStream_2(_a_0,_a_1)
  @staticmethod
  def _match_dataReport_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dataReport_(*args):
    if len(args) != 0: return False
    return True
  def _dataReport_alt_(self,):
    return self._dataReport_()
  def _dataReport_(self,):
   self._dataReport_I(10)
  @staticmethod
  def _match_dataReport_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_dataReport_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _dataReport_alt_I(self,_t__a_0):
    return self._dataReport_I(numpy.int32(__a_0))
  def _dataReport_I(self,_a_0):
   self.__flush_1parameters_()
   self._task_1analyze_1problem_I(_a_0)
  @staticmethod
  def _match_writeTask_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_writeTask_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _writeTask_alt_S(self,_t__a_0):
    return self._writeTask_S(_a_0)
  def _writeTask_S(self,_a_0):
   self.__flush_1parameters_()
   self._task_1write_S(_a_0)
  @staticmethod
  def _match_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _getSolverLIntInfo_alt_S(self,_t__a_0):
    return self._getSolverLIntInfo_S(_a_0)
  def _getSolverLIntInfo_S(self,_a_0):
   return numpy.int64(self._task_1get_1liinf_S(_a_0))
  @staticmethod
  def _match_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _getSolverIntInfo_alt_S(self,_t__a_0):
    return self._getSolverIntInfo_S(_a_0)
  def _getSolverIntInfo_S(self,_a_0):
   return numpy.int32(self._task_1get_1iinf_S(_a_0))
  @staticmethod
  def _match_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _getSolverDoubleInfo_alt_S(self,_t__a_0):
    return self._getSolverDoubleInfo_S(_a_0)
  def _getSolverDoubleInfo_S(self,_a_0):
   return numpy.float64(self._task_1get_1dinf_S(_a_0))
  @staticmethod
  def _match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_LSystem_4CallbackHandler_2__(_a_0))
  @staticmethod
  def _match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_LSystem_4CallbackHandler_2__(_a_0))
  def _setCallbackHandler_alt_LSystem_4CallbackHandler_2(self,_t__a_0):
    return self._setCallbackHandler_LSystem_4CallbackHandler_2(_a_0)
  def _setCallbackHandler_LSystem_4CallbackHandler_2(self,_a_0):
   self._task_1setCallbackHandler_LSystem_4CallbackHandler_2(_a_0)
  @staticmethod
  def _match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_LSystem_4DataCallbackHandler_2__(_a_0))
  @staticmethod
  def _match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_LSystem_4DataCallbackHandler_2__(_a_0))
  def _setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(self,_t__a_0):
    return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_a_0)
  def _setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,_a_0):
   self._task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_a_0)
  @staticmethod
  def _match_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_LSystem_4StreamWriter_2__(_a_0))
  @staticmethod
  def _match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_LSystem_4StreamWriter_2__(_a_0))
  def _setLogHandler_alt_LSystem_4StreamWriter_2(self,_t__a_0):
    return self._setLogHandler_LSystem_4StreamWriter_2(_a_0)
  def _setLogHandler_LSystem_4StreamWriter_2(self,_a_0):
   self._task_1setLogHandler_LSystem_4StreamWriter_2(_a_0)
  @staticmethod
  def _match_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_D__(_a_1))
  def _setSolverParam_alt_SD(self,_t__a_0,_t__a_1):
    return self._setSolverParam_SD(_a_0,numpy.float64(__a_1))
  def _setSolverParam_SD(self,_a_0,_a_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SD(self,_a_0,_a_1)
  @staticmethod
  def _match_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _setSolverParam_alt_SI(self,_t__a_0,_t__a_1):
    return self._setSolverParam_SI(_a_0,numpy.int32(__a_1))
  def _setSolverParam_SI(self,_a_0,_a_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SI(self,_a_0,_a_1)
  @staticmethod
  def _match_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_S__(_a_1))
  @staticmethod
  def _match_alt_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_S__(_a_1))
  def _setSolverParam_alt_SS(self,_t__a_0,_t__a_1):
    return self._setSolverParam_SS(_a_0,_a_1)
  def _setSolverParam_SS(self,_a_0,_a_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SS(self,_a_0,_a_1)
  @staticmethod
  def _match_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  def _breakSolver_alt_(self,):
    return self._breakSolver_()
  def _breakSolver_(self,):
   self._task_1break_1solve_()
  @staticmethod
  def _match_optserverHost_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_optserverHost_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _optserverHost_alt_S(self,_t__a_0):
    return self._optserverHost_S(_a_0)
  def _optserverHost_S(self,_a_0):
   self._task_1putoptserver_1host_S(_a_0)
  def _report_1solution_alt_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8,_t__a_9,_t__a_10,_t__a_11,_t__a_12):
    return self._report_1solution_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(__a_0,__a_1,__a_2,__a_3,numpy.float64(__a_4),numpy.float64(__a_5),numpy.int32(__a_6),numpy.int32(__a_7),numpy.int32(__a_8),numpy.int32(__a_9),numpy.int32(__a_10),_a_11,_a_12)
  def _report_1solution_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(self,_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9,_a_10,_a_11,_a_12):
   if (_a_0==mosek.fusion.SolutionType.Interior):
    _a_13 = self.__sol_itr
   elif (_a_0==mosek.fusion.SolutionType.Basic):
    _a_13 = self.__sol_bas
   elif (_a_0==mosek.fusion.SolutionType.Integer):
    _a_13 = self.__sol_itg
   else:
    _a_13 = None
   if (_a_13 is None):
    _a_13 = mosek_fusion_SolutionStruct._ctor_IIIII(_a_6,_a_7,_a_8,_a_9,_a_10)
   else:
    _a_13._resize_IIIII(_a_6,_a_7,_a_8,_a_9,_a_10)
   (_a_13.pobj) = _a_4
   (_a_13.dobj) = _a_5
   (_a_13.pstatus) = _a_2
   (_a_13.dstatus) = _a_3
   (_a_13.probstatus) = _a_1
   if (_a_6 > 0):
    if _a_11:
     self._report_1solution_1get_1xx__3D((_a_13.xx))
    if _a_12:
     self._report_1solution_1get_1slx__3D((_a_13.slx))
     self._report_1solution_1get_1sux__3D((_a_13.sux))
     _a_14=(_a_13.yx)
     _a_15=(_a_13.slx)
     _a_16=(_a_13.sux)
     fragments._c_closure_23(_a_6,_a_15,_a_16,_a_14) 
   if (_a_7 > 0):
    if _a_11:
     self._report_1solution_1get_1xc__3D((_a_13.xc))
    if _a_12:
     self._report_1solution_1get_1slc__3D((_a_13.slc))
     self._report_1solution_1get_1suc__3D((_a_13.suc))
     _a_17=(_a_13.y)
     _a_18=(_a_13.slc)
     _a_19=(_a_13.suc)
     fragments._c_closure_24(_a_7,_a_18,_a_19,_a_17) 
   if (_a_8 > 0):
    if _a_11:
     self._report_1solution_1get_1barx__3D((_a_13.barx))
    if _a_12:
     self._report_1solution_1get_1bars__3D((_a_13.bars))
   if (self._task_1numacc_() > 0):
    self._report_1solution_1get_1accptr__3I((_a_13.accptr))
    if _a_11:
     self._report_1solution_1get_1accx__3D((_a_13.accx))
    if _a_12:
     self._report_1solution_1get_1accy__3D((_a_13.accy))
   if (_a_0==mosek.fusion.SolutionType.Interior):
    self.__sol_itr = _a_13
   elif (_a_0==mosek.fusion.SolutionType.Basic):
    self.__sol_bas = _a_13
   elif (_a_0==mosek.fusion.SolutionType.Integer):
    self.__sol_itg = _a_13
  def _clear_1solutions_alt_(self,):
    return self._clear_1solutions_()
  def _clear_1solutions_(self,):
   self.__sol_itr = None
   self.__sol_itg = None
   self.__sol_bas = None
  @staticmethod
  def _match_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Z__(_a_0) and __arg_match_D__(_a_1) and __arg_match_I__(_a_2) and __arg_match__3Lmosek_4fusion_4Model_2__(_a_3))
  @staticmethod
  def _match_alt_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Z__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match__3Lmosek_4fusion_4Model_2__(_a_3))
  @staticmethod
  def _solveBatch_alt_ZDI_3Lmosek_4fusion_4Model_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=_t__a_0
   _a_1=numpy.float64(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Model._solveBatch_ZDI_3Lmosek_4fusion_4Model_2(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _solveBatch_ZDI_3Lmosek_4fusion_4Model_2(_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_3).shape[0])
   for _a_5 in range(0,_a_4):
    if (_a_3[_a_5] is None):
     raise mosek_fusion_OptimizeError._ctor_S("One of the models is a null object")
   for _a_6 in range(0,_a_4):
    _a_3[_a_6]._flushSolutions_()
    _a_3[_a_6].__flush_1parameters_()
   _a_7=mosek.fusion.BaseModel._env_1solve_1batch_ZDI_3Lmosek_4fusion_4Model_2(_a_0,_a_1,_a_2,_a_3)
   for _a_8 in range(0,_a_4):
    _a_3[_a_8]._task_1post_1solve_()
   return (_a_7)
  @staticmethod
  def _match_solve_SS(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_S__(_a_1))
  @staticmethod
  def _match_alt_solve_SS(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_S__(_a_1))
  def _solve_alt_SS(self,_t__a_0,_t__a_1):
    return self._solve_SS(_a_0,_a_1)
  def _solve_SS(self,_a_0,_a_1):
   self._flushSolutions_()
   self.__flush_1parameters_()
   self._task_1solve_ZSS(True,_a_0,_a_1)
   self._task_1post_1solve_()
  @staticmethod
  def _match_solve_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_solve_(*args):
    if len(args) != 0: return False
    return True
  def _solve_alt_(self,):
    return self._solve_()
  def _solve_(self,):
   self._flushSolutions_()
   self.__flush_1parameters_()
   self._task_1solve_ZSS(False,"","")
   self._task_1post_1solve_()
  def __flush_1parameters_alt_(self,):
    return self.__flush_1parameters_()
  def __flush_1parameters_(self,):
   _a_0=self.__con_blocks._num_1parameterized_()
   _a_1=self.__afe_blocks._num_1parameterized_()
   _a_2=self.__obj_blocks._num_1parameterized_()
   if (_a_0 > 0):
    _a_3=numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
    _a_4=numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
    _a_5=numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.float64))
    self.__con_blocks._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self.__xs,self.__param_value,_a_3,_a_4,_a_5)
    self._task_1putaijlist__3I_3I_3DJ(_a_3,_a_4,_a_5,_a_0)
   if (_a_1 > 0):
    _a_6=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    _a_7=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    _a_8=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.float64))
    self.__afe_blocks._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self.__xs,self.__param_value,_a_6,_a_7,_a_8)
    self._task_1putafefijlist__3I_3I_3D(_a_6,_a_7,_a_8)
   if (_a_2 > 0):
    _a_9=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    _a_10=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    _a_11=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.float64))
    self.__obj_blocks._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self.__xs,self.__param_value,_a_9,_a_10,_a_11)
    self._task_1putclist__3I_3D(_a_10,_a_11)
  @staticmethod
  def _match_flushParameters_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushParameters_(*args):
    if len(args) != 0: return False
    return True
  def _flushParameters_alt_(self,):
    return self._flushParameters_()
  def _flushParameters_(self,):
   self.__flush_1parameters_()
  def __evaluate_1parameterized_alt_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3I_3D_3I_3D(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8,_t__a_9,_t__a_10):
   _a_0=_t__a_0
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int64))
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.array(_t__a_6,dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.array(_t__a_7,dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.array(_t__a_8,dtype=numpy.dtype(numpy.float64))
   _a_9=numpy.array(_t__a_9,dtype=numpy.dtype(numpy.int32))
   _a_10=numpy.array(_t__a_10,dtype=numpy.dtype(numpy.float64))
   _1_res = self.__evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3I_3D_3I_3D(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9,_a_10)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_6[:] = _a_6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_7[:] = _a_7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_8[:] = _a_8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_9[:] = _a_9
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_10[:] = _a_10
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3I_3D_3I_3D(self,_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9,_a_10):
   _a_11=_a_0._allocf64_I(int((_a_7).shape[0]))
   _a_12=0
   _a_13=(_a_0.f64)
   _a_14=0
   _a_14,_a_12 = fragments._c_closure_25(_a_8,_a_7,_a_4,_a_5,_a_6,_a_14,_a_1,self.__param_value,_a_2,_a_3,_a_11,_a_12,_a_9,_a_10,_a_13)
   _a_14 = numpy.int32(_a_14) # postprocess
   _a_12 = numpy.int32(_a_12) # postprocess
   _a_0._popf64_I(int((_a_7).shape[0]))
  @staticmethod
  def _match_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  def _flushSolutions_alt_(self,):
    return self._flushSolutions_()
  def _flushSolutions_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
  def __flush_1initsol_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(__a_0)
  def __flush_1initsol_Emosek_4fusion_4SolutionType_2(self,_a_0):
   if (self.__initsol_xx is not None):
    _a_1=self._task_1numvar_()
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.float64))
    try:
     _a_3=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,True)
     if ((_a_3.xx) is not None):
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_a_3.xx),0,_a_2,0,(int(((_a_3.xx)).shape[0]) if ((int(((_a_3.xx)).shape[0]) <= _a_1) ) else _a_1))
    except mosek_fusion_SolutionError as _a_4:
     pass
    _a_5=(int((self.__initsol_xx).shape[0]) if ((int((self.__initsol_xx).shape[0]) <= _a_1) ) else _a_1)
    for _a_6 in range(0,_a_5):
     if self.__initsol_xx_flag[_a_6]:
      _a_2[_a_6] = self.__initsol_xx[_a_6]
    _a_2[self.__bfixidx] = 1.0
    self._task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(_a_0,0,_a_1,_a_2)
  @staticmethod
  def _match_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getDualSolutionStatus_alt_(self,):
    return self._getDualSolutionStatus_()
  def _getDualSolutionStatus_(self,):
   return (self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getProblemStatus_alt_(self,):
    return self._getProblemStatus_()
  def _getProblemStatus_(self,):
   return (self._getProblemStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getPrimalSolutionStatus_alt_(self,):
    return self._getPrimalSolutionStatus_()
  def _getPrimalSolutionStatus_(self,):
   return (self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _dualObjValue_alt_(self,):
    return self._dualObjValue_()
  def _dualObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,False).dobj))
  @staticmethod
  def _match_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _primalObjValue_alt_(self,):
    return self._primalObjValue_()
  def _primalObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,True).pobj))
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2ZZ(self,_t__a_0,_t__a_1,_t__a_2):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(__a_0,_a_1,_a_2)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(self,_a_0,_a_1,_a_2):
   _a_3=None
   _a_4=_a_0
   if (_a_4==mosek.fusion.SolutionType.Default):
    _a_4 = self.__solutionptr
   if (_a_4==mosek.fusion.SolutionType.Default):
    if (self.__sol_itg is not None):
     _a_3 = self.__sol_itg
    elif (self.__sol_bas is not None):
     _a_3 = self.__sol_bas
    else:
     _a_3 = self.__sol_itr
   elif (_a_4==mosek.fusion.SolutionType.Interior):
    _a_3 = self.__sol_itr
   elif (_a_4==mosek.fusion.SolutionType.Basic):
    _a_3 = self.__sol_bas
   elif (_a_4==mosek.fusion.SolutionType.Integer):
    _a_3 = self.__sol_itg
   if (_a_3 is None):
    raise mosek_fusion_SolutionError._ctor_S("Solution not available")
   else:
    if (_a_2 or ((_a_1 and _a_3._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)) or ((not _a_1) and _a_3._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)))):
     return (_a_3)
    elif ((_a_3 is self.__sol_itg) and (not _a_1)):
     raise mosek_fusion_SolutionError._ctor_S("Dual solution does not exists for mixed-integer problems.")
    else:
     _a_5=mosek.fusion.Utils.StringBuffer()
     _a_6=(_a_3.pstatus)
     _a_7=(_a_3.probstatus)
     if (not _a_1):
      _a_6 = (_a_3.dstatus)
     _a_5._a_S("Solution status is ")
     if (_a_6==mosek.fusion.SolutionStatus.Undefined):
      _a_5._a_S("Undefined")
     elif (_a_6==mosek.fusion.SolutionStatus.Unknown):
      _a_5._a_S("Unknown")
     elif (_a_6==mosek.fusion.SolutionStatus.Optimal):
      _a_5._a_S("Optimal")
     elif (_a_6==mosek.fusion.SolutionStatus.Feasible):
      _a_5._a_S("Feasible")
     elif (_a_6==mosek.fusion.SolutionStatus.Certificate):
      _a_5._a_S("Certificate")
     elif (_a_6==mosek.fusion.SolutionStatus.IllposedCert):
      _a_5._a_S("IllposedCert")
     _a_5._a_S(" but ")
     if (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Anything):
      _a_5._a_S("Anything")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Optimal):
      _a_5._a_S("Optimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Feasible):
      _a_5._a_S("at least Feasible")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Certificate):
      _a_5._a_S("Certificate")
     _a_5._a_S(" is expected. Reason: Accessing ")
     if (_a_3 is self.__sol_itr):
      _a_5._a_S("interior-point solution")
     elif (_a_3 is self.__sol_bas):
      _a_5._a_S("basic solution")
     elif (_a_3 is self.__sol_itg):
      _a_5._a_S("integer solution")
     _a_5._a_S(" whose problem status is ")
     if (_a_7==mosek.fusion.ProblemStatus.Unknown):
      _a_5._a_S("Unknown")
     elif (_a_7==mosek.fusion.ProblemStatus.PrimalAndDualFeasible):
      _a_5._a_S("PrimalAndDualFeasible")
     elif (_a_7==mosek.fusion.ProblemStatus.PrimalFeasible):
      _a_5._a_S("PrimalFeasible")
     elif (_a_7==mosek.fusion.ProblemStatus.DualFeasible):
      _a_5._a_S("DualFeasible")
     elif (_a_7==mosek.fusion.ProblemStatus.PrimalInfeasible):
      _a_5._a_S("PrimalInfeasible")
     elif (_a_7==mosek.fusion.ProblemStatus.DualInfeasible):
      _a_5._a_S("DualInfeasible")
     elif (_a_7==mosek.fusion.ProblemStatus.PrimalAndDualInfeasible):
      _a_5._a_S("PrimalAndDualInfeasible")
     elif (_a_7==mosek.fusion.ProblemStatus.IllPosed):
      _a_5._a_S("IllPosed")
     elif (_a_7==mosek.fusion.ProblemStatus.PrimalInfeasibleOrUnbounded):
      _a_5._a_S("PrimalInfeasibleOrUnbounded")
     _a_5._a_S(".")
     raise mosek_fusion_SolutionError._ctor_S(_a_5._toString_())
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__a_0,_t__a_1):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(__a_0,_a_1)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(self,_a_0,_a_1):
   return (self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_a_0,_a_1,False))
  def _setSolution_1xx_alt__3I_3D(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setSolution_1xx__3I_3D(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setSolution_1xx__3I_3D(self,_a_0,_a_1):
   self._ensure_1initsol_1xx_()
   for _a_2 in range(0,int((_a_0).shape[0])):
    self.__initsol_xx[_a_0[_a_2]] = _a_1[_a_2]
    self.__initsol_xx_flag[_a_0[_a_2]] = True
  def _ensure_1initsol_1xx_alt_(self,):
    return self._ensure_1initsol_1xx_()
  def _ensure_1initsol_1xx_(self,):
   _a_0=self._task_1numvar_()
   if (self.__initsol_xx is None):
    self.__initsol_xx = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.array([False for _a_1 in range(0,_a_0)], dtype=numpy.dtype(bool))
   elif (int((self.__initsol_xx).shape[0]) < _a_0):
    _a_2=self.__initsol_xx
    _a_3=self.__initsol_xx_flag
    self.__initsol_xx = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.zeros((_a_0,), dtype=numpy.dtype(bool))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_2,0,self.__initsol_xx,0,int((_a_2).shape[0]))
    for _a_4 in range(0,int((_a_2).shape[0])):
     self.__initsol_xx_flag[_a_4] = _a_3[_a_4]
  def _getSolution_1accptr_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1accptr_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_a_0,True,True).accptr))
  def _getSolution_1accy_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1accy_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1accy_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).accy))
  def _getSolution_1accx_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1accx_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1accx_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,True).accx))
  def _getSolution_1bars_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1bars_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).bars))
  def _getSolution_1barx_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1barx_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,True).barx))
  def _getSolution_1y_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1y_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1y_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).y))
  def _getSolution_1xc_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1xc_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,True).xc))
  def _getSolution_1suc_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1suc_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).suc))
  def _getSolution_1slc_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1slc_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).slc))
  def _getSolution_1sux_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1sux_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).sux))
  def _getSolution_1slx_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1slx_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).slx))
  def _getSolution_1yx_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1yx_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,False).yx))
  def _getSolution_1xx_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getSolution_1xx_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_a_0,True).xx))
  @staticmethod
  def _match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  @staticmethod
  def _match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  def _selectedSolution_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._selectedSolution_Emosek_4fusion_4SolutionType_2(__a_0)
  def _selectedSolution_Emosek_4fusion_4SolutionType_2(self,_a_0):
   self.__solutionptr = _a_0
  @staticmethod
  def _match_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getAcceptedSolutionStatus_alt_(self,):
    return self._getAcceptedSolutionStatus_()
  def _getAcceptedSolutionStatus_(self,):
   return (self.__acceptable_sol)
  @staticmethod
  def _match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_a_0))
  @staticmethod
  def _match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_a_0))
  def _acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__a_0):
    return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(__a_0)
  def _acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(self,_a_0):
   self.__acceptable_sol = _a_0
  @staticmethod
  def _match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  @staticmethod
  def _match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  def _getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getProblemStatus_Emosek_4fusion_4SolutionType_2(self,_a_0):
   _a_1=None
   if (_a_0==mosek.fusion.SolutionType.Default):
    if (self.__sol_itg is not None):
     _a_1 = self.__sol_itg
    elif (self.__sol_bas is not None):
     _a_1 = self.__sol_bas
    else:
     _a_1 = self.__sol_itr
   elif (_a_0==mosek.fusion.SolutionType.Interior):
    _a_1 = self.__sol_itr
   elif (_a_0==mosek.fusion.SolutionType.Basic):
    _a_1 = self.__sol_bas
   elif (_a_0==mosek.fusion.SolutionType.Integer):
    _a_1 = self.__sol_itg
   if (_a_1 is None):
    return (mosek.fusion.ProblemStatus.Unknown)
   else:
    return ((_a_1.probstatus))
  @staticmethod
  def _match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  @staticmethod
  def _match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  def _getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_a_0,False))
  @staticmethod
  def _match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_a_0))
  def _getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__a_0):
    return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(__a_0)
  def _getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_a_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_a_0,True))
  def _getSolutionStatus_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__a_0,_t__a_1):
    return self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(__a_0,_a_1)
  def _getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(self,_a_0,_a_1):
   try:
    _a_2=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_a_0,_a_1,True)
    if _a_1:
     return ((_a_2.pstatus))
    else:
     return ((_a_2.dstatus))
   except mosek_fusion_SolutionError as _a_3:
    return (mosek.fusion.SolutionStatus.Undefined)
  def _update_alt__3ILmosek_4fusion_4Expression_2(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=_t__a_1
   _1_res = self._update__3ILmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _update__3ILmosek_4fusion_4Expression_2(self,_a_0,_a_1):
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_1)))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   _a_2=(self.__ws.nd)
   _a_3=(self.__ws.shape_base)
   _a_4=(self.__ws.nelem)
   _a_5=(self.__ws.nnz)
   _a_6=(self.__ws.hassp)
   _a_7=(self.__ws.ncodeatom)
   _a_8=(self.__ws.ptr_base)
   _a_9=(self.__ws.sp_base)
   _a_10=(self.__ws.nidxs_base)
   _a_11=(self.__ws.cof_base)
   _a_12=(self.__ws.code_base)
   _a_13=(self.__ws.codeptr_base)
   _a_14=(self.__ws.cconst_base)
   _a_15=(self.__ws.i32)
   _a_16=(self.__ws.i64)
   _a_17=(self.__ws.f64)
   _a_18=0
   _a_18 = fragments._c_closure_26(_a_0,_a_4,_a_18)
   _a_18 = numpy.int32(_a_18) # postprocess
   _a_19=(_a_4 - _a_18)
   if (_a_18==_a_4):
    self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_a_0,self.__ws,_a_4,_a_5,_a_8,_a_10,_a_11)
    if (_a_7 > 0):
     self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_a_0,_a_8,_a_10,_a_13,_a_12,_a_14)
    else:
     self.__con_blocks._clear_1row_1code__3I(_a_0)
   elif (_a_19==_a_4):
    self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(numpy.array([(- (1 + _a_0[_a_20])) for _a_20 in range(0,_a_4)], dtype=numpy.dtype(numpy.int32)),0,self.__ws,_a_4,_a_5,_a_8,_a_10,_a_11)
    if (_a_7 > 0):
     self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([(- (1 + _a_0[_a_21])) for _a_21 in range(0,_a_4)], dtype=numpy.dtype(numpy.int32)),_a_8,_a_10,_a_13,_a_12,_a_14)
    else:
     self.__afe_blocks._clear_1row_1code__3I(numpy.array([(- (1 + _a_0[_a_22])) for _a_22 in range(0,_a_4)], dtype=numpy.dtype(numpy.int32)))
   else:
    _a_23=0
    _a_24=0
    _a_25=0
    _a_26=0
    _a_25,_a_26 = fragments._c_closure_27(_a_25,_a_0,_a_26,_a_4,_a_8,_a_15)
    _a_25 = numpy.int32(_a_25) # postprocess
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_27=self.__xs._alloci32_I(_a_18)
    _a_28=self.__xs._alloci32_I(_a_19)
    _a_29=self.__xs._alloci32_I((_a_18 + 1))
    _a_30=self.__xs._alloci32_I((_a_19 + 1))
    _a_31=self.__xs._alloci64_I(_a_26)
    _a_32=self.__xs._alloci64_I(_a_25)
    _a_33=self.__xs._allocf64_I(_a_26)
    _a_34=self.__xs._allocf64_I(_a_25)
    _a_35=(self.__xs.f64)
    _a_36=(self.__xs.i64)
    _a_37=(self.__xs.i32)
    _a_37[_a_29] = 0
    _a_37[_a_30] = 0
    _a_38=0
    _a_39=0
    _a_40=0
    _a_41=0
    for _a_42 in range(0,_a_4):
     _a_43=_a_15[(_a_8 + _a_42)]
     _a_44=_a_15[((_a_8 + _a_42) + 1)]
     if (_a_0[_a_42] >= 0):
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_16,(_a_10 + _a_43),_a_36,(_a_31 + _a_41),(_a_44 - _a_43))
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_17,(_a_11 + _a_43),_a_35,(_a_33 + _a_41),(_a_44 - _a_43))
      _a_41 += (_a_44 - _a_43)
      _a_37[(_a_27 + _a_39)] = _a_0[_a_42]
      _a_37[((_a_29 + _a_39) + 1)] = _a_41
      _a_39 += 1
     else:
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_16,(_a_10 + _a_43),_a_36,(_a_32 + _a_40),(_a_44 - _a_43))
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_17,(_a_11 + _a_43),_a_35,(_a_34 + _a_40),(_a_44 - _a_43))
      _a_40 += (_a_44 - _a_43)
      _a_37[(_a_28 + _a_38)] = (- (1 + _a_0[_a_42]))
      _a_37[((_a_30 + _a_38) + 1)] = _a_40
      _a_38 += 1
    self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(numpy.array([_a_37[(_a_27 + _a_45)] for _a_45 in range(0,_a_18)], dtype=numpy.dtype(numpy.int32)),self.__xs,_a_18,_a_26,_a_29,_a_31,_a_33)
    self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_a_37,_a_28,self.__xs,_a_19,_a_25,_a_30,_a_32,_a_34)
    if (_a_7 > 0):
     _a_23,_a_24 = fragments._c_closure_28(_a_23,_a_13,_a_0,_a_24,_a_4,_a_8,_a_15)
     _a_23 = numpy.int32(_a_23) # postprocess
     _a_24 = numpy.int32(_a_24) # postprocess
     _a_46=self.__xs._alloci32_I((_a_26 + 1))
     _a_47=self.__xs._alloci32_I((_a_25 + 1))
     _a_48=self.__xs._alloci32_I(_a_24)
     _a_49=self.__xs._alloci32_I(_a_23)
     _a_50=self.__xs._allocf64_I(_a_24)
     _a_51=self.__xs._allocf64_I(_a_23)
     _a_37[_a_46] = 0
     _a_37[_a_47] = 0
     _a_52=0
     _a_53=0
     _a_54=0
     _a_55=0
     for _a_56 in range(0,_a_4):
      _a_57=_a_15[(_a_8 + _a_56)]
      _a_58=_a_15[((_a_8 + _a_56) + 1)]
      if (_a_0[_a_56] >= 0):
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_15,(_a_12 + _a_15[(_a_13 + _a_57)]),_a_37,(_a_48 + _a_53),(_a_15[(_a_13 + _a_58)] - _a_15[(_a_13 + _a_57)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_17,(_a_14 + _a_15[(_a_13 + _a_57)]),_a_35,(_a_50 + _a_53),(_a_15[(_a_13 + _a_58)] - _a_15[(_a_13 + _a_57)]))
       _a_53,_a_55 = fragments._c_closure_29(_a_13,_a_53,_a_46,_a_55,_a_57,_a_58,_a_15,_a_37)
       _a_53 = numpy.int32(_a_53) # postprocess
       _a_55 = numpy.int32(_a_55) # postprocess
      else:
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_15,(_a_12 + _a_15[(_a_13 + _a_57)]),_a_37,(_a_49 + _a_52),(_a_15[(_a_13 + _a_58)] - _a_15[(_a_13 + _a_57)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_17,(_a_14 + _a_15[(_a_13 + _a_57)]),_a_35,(_a_51 + _a_52),(_a_15[(_a_13 + _a_58)] - _a_15[(_a_13 + _a_57)]))
       _a_52,_a_40 = fragments._c_closure_30(_a_52,_a_47,_a_40,_a_13,_a_57,_a_58,_a_15,_a_37)
       _a_52 = numpy.int32(_a_52) # postprocess
       _a_40 = numpy.int32(_a_40) # postprocess
     self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,numpy.array([_a_37[(_a_27 + _a_59)] for _a_59 in range(0,_a_18)], dtype=numpy.dtype(numpy.int32)),_a_29,_a_31,_a_46,_a_48,_a_50)
     self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,numpy.array([numpy.int32(_a_36[(_a_28 + _a_60)]) for _a_60 in range(0,_a_19)], dtype=numpy.dtype(numpy.int32)),_a_30,_a_32,_a_47,_a_49,_a_51)
    else:
     self.__con_blocks._clear_1row_1code__3I(numpy.array([_a_37[(_a_27 + _a_61)] for _a_61 in range(0,_a_18)], dtype=numpy.dtype(numpy.int32)))
     self.__afe_blocks._clear_1row_1code__3I(numpy.array([numpy.int32(_a_36[(_a_28 + _a_62)]) for _a_62 in range(0,_a_19)], dtype=numpy.dtype(numpy.int32)))
   self.__xs._clear_()
  def _update_alt__3ILmosek_4fusion_4Expression_2_3I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=_t__a_1
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = self._update__3ILmosek_4fusion_4Expression_2_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _update__3ILmosek_4fusion_4Expression_2_3I(self,_a_0,_a_1,_a_2):
   for _a_3 in range(0,int((_a_0).shape[0])):
    if ((_a_0[_a_3] >= 0) and self.__con_blocks._row_1is_1parameterized_I(_a_3)):
     raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
    elif ((_a_0[_a_3] < 0) and self.__con_blocks._row_1is_1parameterized_I((- (_a_3 + 1)))):
     raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_1))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   _a_4=(self.__ws.nd)
   _a_5=(self.__ws.nelem)
   _a_6=(self.__ws.nnz)
   _a_7=(self.__ws.hassp)
   _a_8=(self.__ws.ncodeatom)
   _a_9=(self.__ws.shape_base)
   _a_10=(self.__ws.ptr_base)
   _a_11=(self.__ws.sp_base)
   _a_12=(self.__ws.nidxs_base)
   _a_13=(self.__ws.cof_base)
   _a_14=(self.__ws.code_base)
   _a_15=(self.__ws.codeptr_base)
   _a_16=(self.__ws.cconst_base)
   _a_17=(self.__ws.i32)
   _a_18=(self.__ws.i64)
   _a_19=(self.__ws.f64)
   _a_20=0
   _a_20 = fragments._c_closure_31(_a_0,_a_5,_a_20)
   _a_20 = numpy.int32(_a_20) # postprocess
   _a_21=(_a_5 - _a_20)
   if ((_a_20==_a_5) or (_a_21==_a_5)):
    _a_22=(int((_a_0).shape[0]) * int((_a_2).shape[0]))
    _a_23=numpy.zeros((_a_22,), dtype=numpy.dtype(numpy.float64))
    _a_24=0
    _a_24 = fragments._c_closure_32(_a_23,_a_13,_a_5,_a_12,_a_24,_a_10,_a_2,_a_19,_a_17,_a_18)
    _a_24 = numpy.int32(_a_24) # postprocess
    _a_25=numpy.array([_a_2[_a_27] for _a_26 in range(0,_a_5) for _a_27 in range(0,int((_a_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
    if (_a_20==_a_5):
     _a_28=numpy.array([_a_0[_a_29] for _a_29 in range(0,_a_5) for _a_30 in range(0,int((_a_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
     self._task_1putaijlist__3I_3I_3DJ(_a_28,_a_25,_a_23,_a_24)
     if (_a_8 > 0):
      self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_a_0,_a_10,_a_12,_a_15,_a_14,_a_16)
    else:
     _a_31=numpy.array([(- (_a_0[_a_32] + 1)) for _a_32 in range(0,_a_5) for _a_33 in range(0,int((_a_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
     self._task_1putafefijlist__3I_3I_3D(_a_31,_a_25,_a_23)
     if (_a_8 > 0):
      self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([(- (1 + _a_0[_a_34])) for _a_34 in range(0,_a_5)], dtype=numpy.dtype(numpy.int32)),_a_10,_a_12,_a_15,_a_14,_a_16)
   else:
    _a_35=(_a_21 * int((_a_2).shape[0]))
    _a_36=(_a_20 * int((_a_2).shape[0]))
    _a_37=numpy.zeros((_a_36,), dtype=numpy.dtype(numpy.float64))
    _a_38=numpy.zeros((_a_35,), dtype=numpy.dtype(numpy.float64))
    _a_39=numpy.array([_a_2[_a_41] for _a_40 in range(0,_a_20) for _a_41 in range(0,int((_a_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _a_42=numpy.array([_a_2[_a_44] for _a_43 in range(0,_a_21) for _a_44 in range(0,int((_a_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _a_45=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int32))
    _a_46=numpy.zeros((_a_21,), dtype=numpy.dtype(numpy.int32))
    _a_47=0
    _a_48=0
    _a_49=0
    _a_50=0
    _a_51=0
    _a_52=0
    _a_51,_a_52 = fragments._c_closure_33(_a_38,_a_51,_a_13,_a_0,_a_46,_a_37,_a_52,_a_45,_a_5,_a_12,_a_10,_a_2,_a_19,_a_17,_a_18)
    _a_51 = numpy.int32(_a_51) # postprocess
    _a_52 = numpy.int32(_a_52) # postprocess
    self._task_1putaijlist__3I_3I_3DJ(_a_45,_a_39,_a_37,_a_52)
    self._task_1putafefijlist__3I_3I_3D(_a_46,_a_42,_a_38)
    if (_a_8 > 0):
     _a_51,_a_52 = fragments._c_closure_34(_a_51,_a_0,_a_52,_a_5,_a_10,_a_17)
     _a_51 = numpy.int32(_a_51) # postprocess
     _a_52 = numpy.int32(_a_52) # postprocess
     _a_53=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int32))
     _a_54=numpy.zeros((_a_21,), dtype=numpy.dtype(numpy.int32))
     _a_55=self.__xs._alloci32_I((_a_20 + 1))
     _a_56=self.__xs._alloci32_I((_a_21 + 1))
     _a_57=self.__xs._alloci64_I(_a_52)
     _a_58=self.__xs._alloci64_I(_a_51)
     _a_59=(self.__xs.f64)
     _a_60=(self.__xs.i64)
     _a_61=(self.__xs.i32)
     _a_61[_a_55] = 0
     _a_61[_a_56] = 0
     _a_62=0
     _a_63=0
     _a_64=0
     _a_65=0
     _a_62,_a_64,_a_63,_a_65 = fragments._c_closure_35(_a_62,_a_64,_a_0,_a_56,_a_54,_a_63,_a_65,_a_55,_a_53,_a_5,_a_10,_a_17,_a_61)
     _a_62 = numpy.int32(_a_62) # postprocess
     _a_64 = numpy.int32(_a_64) # postprocess
     _a_63 = numpy.int32(_a_63) # postprocess
     _a_65 = numpy.int32(_a_65) # postprocess
     _a_49,_a_50 = fragments._c_closure_36(_a_49,_a_15,_a_0,_a_50,_a_5,_a_10,_a_17)
     _a_49 = numpy.int32(_a_49) # postprocess
     _a_50 = numpy.int32(_a_50) # postprocess
     _a_66=self.__xs._alloci32_I((_a_52 + 1))
     _a_67=self.__xs._alloci32_I((_a_51 + 1))
     _a_68=self.__xs._alloci32_I(_a_50)
     _a_69=self.__xs._alloci32_I(_a_49)
     _a_70=self.__xs._allocf64_I(_a_50)
     _a_71=self.__xs._allocf64_I(_a_49)
     _a_61[_a_66] = 0
     _a_61[_a_67] = 0
     _a_72=0
     _a_73=0
     _a_74=0
     _a_75=0
     for _a_76 in range(0,_a_5):
      _a_77=_a_17[(_a_10 + _a_76)]
      _a_78=_a_17[((_a_10 + _a_76) + 1)]
      if (_a_0[_a_76] >= 0):
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_17,(_a_14 + _a_17[(_a_15 + _a_77)]),_a_61,(_a_68 + _a_73),(_a_17[(_a_15 + _a_78)] - _a_17[(_a_15 + _a_77)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_19,(_a_16 + _a_17[(_a_15 + _a_77)]),_a_59,(_a_70 + _a_73),(_a_17[(_a_15 + _a_78)] - _a_17[(_a_15 + _a_77)]))
       _a_73,_a_75 = fragments._c_closure_37(_a_15,_a_73,_a_66,_a_75,_a_77,_a_78,_a_17,_a_61)
       _a_73 = numpy.int32(_a_73) # postprocess
       _a_75 = numpy.int32(_a_75) # postprocess
      else:
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_17,(_a_14 + _a_17[(_a_15 + _a_77)]),_a_61,(_a_69 + _a_72),(_a_17[(_a_15 + _a_78)] - _a_17[(_a_15 + _a_77)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_19,(_a_16 + _a_17[(_a_15 + _a_77)]),_a_59,(_a_71 + _a_72),(_a_17[(_a_15 + _a_78)] - _a_17[(_a_15 + _a_77)]))
       _a_72,_a_64 = fragments._c_closure_38(_a_72,_a_67,_a_64,_a_15,_a_77,_a_78,_a_17,_a_61)
       _a_72 = numpy.int32(_a_72) # postprocess
       _a_64 = numpy.int32(_a_64) # postprocess
     self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,_a_53,_a_55,_a_57,_a_66,_a_68,_a_70)
     self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,_a_54,_a_56,_a_58,_a_67,_a_69,_a_71)
    else:
     _a_79=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int32))
     _a_80=numpy.zeros((_a_21,), dtype=numpy.dtype(numpy.int32))
     _a_81=0
     _a_82=0
     _a_81,_a_82 = fragments._c_closure_39(_a_81,_a_0,_a_80,_a_82,_a_79,_a_5)
     _a_81 = numpy.int32(_a_81) # postprocess
     _a_82 = numpy.int32(_a_82) # postprocess
     self.__con_blocks._clear_1row_1code__3I(_a_79)
     self.__afe_blocks._clear_1row_1code__3I(_a_80)
   self.__xs._clear_()
  @staticmethod
  def _match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  def _updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__a_0,_t__a_1):
    return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  def _updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_a_0,_a_1):
   if (_a_0._getSize_()!=1):
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression size for objective")
   if ((self.__obj_blocks.code_used) > 0):
    raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
   _a_2=_a_1._numInst_()
   _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   if (_a_2 < _a_1._getSize_()):
    _a_4=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    _a_1._inst_I_3JI_3J(0,_a_4,0,_a_3)
   else:
    _a_1._inst_I_3J(0,_a_3)
   for _a_5 in range(0,_a_2):
    if (_a_3[_a_5] < 0):
     raise mosek_fusion_UpdateError._ctor_S("Updating semidefinite terms is currently not possible")
   _a_6=True
   _a_6 = fragments._c_closure_40(_a_2,_a_3,_a_6)
   _a_7=None
   if _a_6:
    _a_7 = numpy.array([numpy.int32(_a_3[_a_8]) for _a_8 in range(0,_a_2)], dtype=numpy.dtype(numpy.int32))
   else:
    _a_9=numpy.array([_a_10 for _a_10 in range((- 1),_a_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_9,_a_3,None,0,_a_2)
    _a_7 = numpy.array([numpy.int32(_a_3[_a_9[_a_11]]) for _a_11 in range(0,_a_2)], dtype=numpy.dtype(numpy.int32))
   _a_12=int((_a_7).shape[0])
   _a_13=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.float64))
   _a_14=_a_7
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_0))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   pass
   _a_15=(self.__ws.nd)
   _a_16=(self.__ws.nelem)
   _a_17=(self.__ws.nnz)
   _a_18=(self.__ws.hassp)
   _a_19=(self.__ws.ncodeatom)
   _a_20=(self.__ws.shape_base)
   _a_21=(self.__ws.ptr_base)
   _a_22=(self.__ws.sp_base)
   _a_23=(self.__ws.nidxs_base)
   _a_24=(self.__ws.cof_base)
   _a_25=(self.__ws.code_base)
   _a_26=(self.__ws.codeptr_base)
   _a_27=(self.__ws.cconst_base)
   pass
   if (_a_19 > 0):
    raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized objective")
   _a_28=(self.__ws.i32)
   _a_29=(self.__ws.i64)
   _a_30=(self.__ws.f64)
   _a_31=0
   _a_31 = fragments._c_closure_41(_a_13,_a_24,_a_31,_a_16,_a_23,_a_21,_a_7,_a_30,_a_28,_a_29)
   _a_31 = numpy.int32(_a_31) # postprocess
   self._task_1putclist__3I_3D(_a_14,_a_13)
   if (_a_19 > 0):
    self.__obj_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([0], dtype=numpy.dtype(numpy.int32)),_a_21,_a_23,_a_26,_a_25,_a_27)
  def __parameter_1unchecked_alt_S_3I_3J(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _1_res = self.__parameter_1unchecked_S_3I_3J(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __parameter_1unchecked_S_3I_3J(self,_a_0,_a_1,_a_2):
   if ((int(len(_a_0)) > 0) and self.__par_map._hasItem_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S("Duplicate parameter name")
   _a_3=mosek.fusion.Set._size__3I(_a_1)
   _a_4=(int((_a_2).shape[0]) if ((_a_2 is not None) ) else numpy.int32(_a_3))
   if (self.__param_value is None):
    self.__param_value = numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   else:
    if ((self.__param_num + _a_4) > int((self.__param_value).shape[0])):
     _a_5=self.__param_value
     _a_6=((2 * int((_a_5).shape[0])) if (((2 * int((_a_5).shape[0])) > (int((_a_5).shape[0]) + _a_4)) ) else (int((_a_5).shape[0]) + _a_4))
     self.__param_value = numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.float64))
     if (self.__param_num > 0):
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_5,0,self.__param_value,0,self.__param_num)
   _a_7=mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self,_a_1,_a_2,numpy.array([(self.__param_num + _a_8) for _a_8 in range(0,numpy.int32(_a_4))], dtype=numpy.dtype(numpy.int32)))
   self.__param_num += _a_4
   if (int(len(_a_0)) > 0):
    if ((self.__parameters is None) or (self.__numparameter==int((self.__parameters).shape[0]))):
     _a_9=self.__parameters
     self.__parameters = numpy.array([None for _a_10 in range(0,((self.__numparameter * 2) + 64))], dtype=numpy.dtype(object))
     for _a_11 in range(0,self.__numparameter):
      self.__parameters[_a_11] = _a_9[_a_11]
    self.__parameters[self.__numparameter] = _a_7
    self.__par_map._setItem_SI(_a_0,self.__numparameter)
    self.__numparameter += 1
   return (_a_7)
  def __parameter_1_alt_S_3I_3J(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _1_res = self.__parameter_1_S_3I_3J(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __parameter_1_S_3I_3J(self,_a_0,_a_1,_a_2):
   _a_3=True
   _a_4=int((_a_1).shape[0])
   if ((_a_2 is not None) and (int((_a_2).shape[0]) > 0)):
    _a_5=(_a_2[(int((_a_2).shape[0]) - 1)] < mosek.fusion.Set._size__3I(_a_1))
    _a_5 = fragments._c_closure_42(_a_5,_a_2)
    if (not _a_5):
     raise mosek_fusion_IndexError._ctor_S("Unordered sparsity pattern")
   return (self.__parameter_1unchecked_S_3I_3J(_a_0,_a_1,_a_2))
  def __parameter_1_alt_S_3I_3_5I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,ndmin=_monty.checkShape(_t__a_2,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self.__parameter_1_S_3I_3_5I(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __parameter_1_S_3I_3_5I(self,_a_0,_a_1,_a_2):
   _a_3=int((_a_2).shape[0])
   _a_4=int((_a_2).shape[1])
   if (int((_a_1).shape[0])!=_a_4):
    raise mosek_fusion_LengthError._ctor_S("Invalid sparsity")
   if (_a_2 is None):
    return (self.__parameter_1unchecked_S_3I_3J(_a_0,_a_1,None))
   else:
    _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
    _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int64))
    _a_6[(_a_4 - 1)] = 1
    fragments._c_closure_43(_a_4,_a_1,_a_6) 
    fragments._c_closure_44(_a_4,_a_3,_a_5,_a_2,_a_6) 
    return (self.__parameter_1_S_3I_3J(_a_0,_a_1,_a_5))
  @staticmethod
  def _match_parameter_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_parameter_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _parameter_alt_S(self,_t__a_0):
    return self._parameter_S(_a_0)
  def _parameter_S(self,_a_0):
   _a_1=None
   return (self.__parameter_1_S_3I_3J(_a_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),_a_1))
  @staticmethod
  def _match_parameter_SIII(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_parameter_SIII(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_I__(_a_3))
  def _parameter_alt_SIII(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return self._parameter_SIII(_a_0,numpy.int32(__a_1),numpy.int32(__a_2),numpy.int32(__a_3))
  def _parameter_SIII(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=None
   return (self.__parameter_1_S_3I_3J(_a_0,numpy.array([_a_1,_a_2,_a_3], dtype=numpy.dtype(numpy.int32)),_a_4))
  @staticmethod
  def _match_parameter_SII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_parameter_SII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _parameter_alt_SII(self,_t__a_0,_t__a_1,_t__a_2):
    return self._parameter_SII(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  def _parameter_SII(self,_a_0,_a_1,_a_2):
   _a_3=None
   return (self.__parameter_1_S_3I_3J(_a_0,numpy.array([_a_1,_a_2], dtype=numpy.dtype(numpy.int32)),_a_3))
  @staticmethod
  def _match_parameter_SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_parameter_SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _parameter_alt_SI(self,_t__a_0,_t__a_1):
    return self._parameter_SI(_a_0,numpy.int32(__a_1))
  def _parameter_SI(self,_a_0,_a_1):
   _a_2=None
   return (self.__parameter_1_S_3I_3J(_a_0,numpy.array([_a_1], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_parameter_S_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_parameter_S_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _parameter_alt_S_3I(self,_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._parameter_S_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _parameter_S_3I(self,_a_0,_a_1):
   _a_2=None
   return (self.__parameter_1_S_3I_3J(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_parameter_S_3I_3J(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3J__(_a_2))
  @staticmethod
  def _match_alt_parameter_S_3I_3J(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3J__(_a_2))
  def _parameter_alt_S_3I_3J(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _1_res = self._parameter_S_3I_3J(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _parameter_S_3I_3J(self,_a_0,_a_1,_a_2):
   return (self.__parameter_1_S_3I_3J(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_parameter_S_3I_3_5I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3_5I__(_a_2))
  @staticmethod
  def _match_alt_parameter_S_3I_3_5I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3_5I__(_a_2))
  def _parameter_alt_S_3I_3_5I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,ndmin=_monty.checkShape(_t__a_2,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._parameter_S_3I_3_5I(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _parameter_S_3I_3_5I(self,_a_0,_a_1,_a_2):
   return (self.__parameter_1_S_3I_3_5I(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_parameter_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_parameter_(*args):
    if len(args) != 0: return False
    return True
  def _parameter_alt_(self,):
    return self._parameter_()
  def _parameter_(self,):
   _a_0=None
   return (self.__parameter_1_S_3I_3J("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),_a_0))
  @staticmethod
  def _match_parameter_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_parameter_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _parameter_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._parameter_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _parameter_III(self,_a_0,_a_1,_a_2):
   _a_3=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32)),_a_3))
  @staticmethod
  def _match_parameter_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_parameter_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _parameter_alt_II(self,_t__a_0,_t__a_1):
    return self._parameter_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _parameter_II(self,_a_0,_a_1):
   _a_2=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_parameter_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_parameter_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _parameter_alt_I(self,_t__a_0):
    return self._parameter_I(numpy.int32(__a_0))
  def _parameter_I(self,_a_0):
   _a_1=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),_a_1))
  @staticmethod
  def _match_parameter__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_parameter__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _parameter_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._parameter__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _parameter__3I(self,_a_0):
   _a_1=None
   return (self.__parameter_1_S_3I_3J("",_a_0,_a_1))
  @staticmethod
  def _match_parameter__3I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3J__(_a_1))
  @staticmethod
  def _match_alt_parameter__3I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3J__(_a_1))
  def _parameter_alt__3I_3J(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _1_res = self._parameter__3I_3J(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _parameter__3I_3J(self,_a_0,_a_1):
   return (self.__parameter_1_S_3I_3J("",_a_0,_a_1))
  @staticmethod
  def _match_parameter__3I_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3_5I__(_a_1))
  @staticmethod
  def _match_alt_parameter__3I_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3_5I__(_a_1))
  def _parameter_alt__3I_3_5I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._parameter__3I_3_5I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _parameter__3I_3_5I(self,_a_0,_a_1):
   return (self.__parameter_1_S_3I_3_5I("",_a_0,_a_1))
  def __objective_1_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_a_0,__a_1,_a_2)
  def __objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_a_0,_a_1,_a_2):
   self._task_1putobjectivename_S(_a_0)
   _a_3=mosek_fusion_WorkStack._ctor_()
   _a_4=mosek_fusion_WorkStack._ctor_()
   _a_5=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_2)))
   _a_5._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_3,_a_4,self.__xs)
   _a_3._pop_1expr_()
   _a_6=(_a_3.i32)
   _a_7=(_a_3.i64)
   _a_8=(_a_3.f64)
   _a_9=(_a_3.nd)
   _a_10=(_a_3.nelem)
   _a_11=(_a_3.nnz)
   _a_12=(_a_3.hassp)
   _a_13=(_a_3.ncodeatom)
   _a_14=(_a_3.ptr_base)
   _a_15=(_a_3.shape_base)
   _a_16=(_a_3.nidxs_base)
   _a_17=(_a_3.cof_base)
   _a_18=(_a_3.code_base)
   _a_19=(_a_3.codeptr_base)
   _a_20=(_a_3.cconst_base)
   _a_21=1
   _a_9 = fragments._c_closure_45(_a_9,_a_6,_a_15)
   _a_9 = numpy.int32(_a_9) # postprocess
   if (_a_21!=1):
    raise mosek_fusion_LengthError._ctor_S("Invalid expression size for objective")
   if (_a_10!=1):
    raise mosek_fusion_LengthError._ctor_S("Invalid expression for objective")
   _a_22=0
   _a_23=0
   _a_22,_a_23 = fragments._c_closure_46(_a_22,_a_16,_a_11,_a_23,_a_7)
   _a_22 = numpy.int32(_a_22) # postprocess
   _a_23 = numpy.int32(_a_23) # postprocess
   _a_24=numpy.zeros((_a_22,), dtype=numpy.dtype(numpy.int32))
   _a_25=numpy.zeros((_a_22,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_47(_a_25,_a_17,_a_16,_a_11,_a_8,_a_7,_a_24) 
   self._task_1putobjective_Z_3I_3DD((_a_1==mosek.fusion.ObjectiveSense.Maximize),_a_24,_a_25,0.0)
   if (_a_23 > 0):
    _a_26=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.int32))
    _a_27=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.int32))
    _a_28=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.int32))
    _a_29=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_48(self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,_a_17,_a_16,_a_23,_a_8,_a_7,_a_26,_a_27,_a_28,_a_29) 
    self._task_1putbarc__3I_3I_3I_3D(_a_26,_a_27,_a_28,_a_29)
   if (_a_13 > 0):
    self.__obj_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(_a_3,numpy.array([0], dtype=numpy.dtype(numpy.int32)),_a_14,_a_16,_a_19,_a_18,_a_20)
  @staticmethod
  def _match_objective_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_objective_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  def _objective_alt_D(self,_t__a_0):
    return self._objective_D(numpy.float64(__a_0))
  def _objective_D(self,_a_0):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_a_0))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_a_0) and __arg_alt_match_D__(_a_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2D(self,_t__a_0,_t__a_1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2D(__a_0,numpy.float64(__a_1))
  def _objective_Emosek_4fusion_4ObjectiveSense_2D(self,_a_0,_a_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_a_0,mosek.fusion.Expr._constTerm_D(_a_1))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__a_0,_t__a_1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(__a_0,_a_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_a_0,_a_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_a_0,_a_1)
  @staticmethod
  def _match_objective_SD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_objective_SD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_D__(_a_1))
  def _objective_alt_SD(self,_t__a_0,_t__a_1):
    return self._objective_SD(_a_0,numpy.float64(__a_1))
  def _objective_SD(self,_a_0,_a_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_a_0,mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_a_1))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_a_1) and __arg_alt_match_D__(_a_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(self,_t__a_0,_t__a_1,_t__a_2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(_a_0,__a_1,numpy.float64(__a_2))
  def _objective_SEmosek_4fusion_4ObjectiveSense_2D(self,_a_0,_a_1,_a_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,mosek.fusion.Expr._constTerm_D(_a_2))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_a_0,__a_1,_a_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_a_0,_a_1,_a_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(_a_0))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprRangeDomain_2__(_a_0))
  def _constraint_alt_Lmosek_4fusion_4ExprRangeDomain_2(self,_t__a_0):
    return self._constraint_Lmosek_4fusion_4ExprRangeDomain_2(_a_0)
  def _constraint_Lmosek_4fusion_4ExprRangeDomain_2(self,_a_0):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",(_a_0.expr),(_a_0.dom)))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4ExprRangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ExprRangeDomain_2__(_a_1))
  def _constraint_alt_SLmosek_4fusion_4ExprRangeDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_SLmosek_4fusion_4ExprRangeDomain_2(_a_0,_a_1)
  def _constraint_SLmosek_4fusion_4ExprRangeDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,(_a_1.expr),(_a_1.dom)))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1,_a_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4ExprConicDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprConicDomain_2__(_a_0))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4ExprConicDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprConicDomain_2__(_a_0))
  def _constraint_alt_Lmosek_4fusion_4ExprConicDomain_2(self,_t__a_0):
    return self._constraint_Lmosek_4fusion_4ExprConicDomain_2(_a_0)
  def _constraint_Lmosek_4fusion_4ExprConicDomain_2(self,_a_0):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2("",(_a_0.expr),(_a_0.dom)))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4ExprConicDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4ExprConicDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4ExprConicDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ExprConicDomain_2__(_a_1))
  def _constraint_alt_SLmosek_4fusion_4ExprConicDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_SLmosek_4fusion_4ExprConicDomain_2(_a_0,_a_1)
  def _constraint_SLmosek_4fusion_4ExprConicDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_a_0,(_a_1.expr),(_a_1.dom)))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_a_0,_a_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_a_0,_a_1,_a_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(_a_0))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprLinearDomain_2__(_a_0))
  def _constraint_alt_Lmosek_4fusion_4ExprLinearDomain_2(self,_t__a_0):
    return self._constraint_Lmosek_4fusion_4ExprLinearDomain_2(_a_0)
  def _constraint_Lmosek_4fusion_4ExprLinearDomain_2(self,_a_0):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",(_a_0.expr),(_a_0.dom)))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4ExprLinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ExprLinearDomain_2__(_a_1))
  def _constraint_alt_SLmosek_4fusion_4ExprLinearDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_SLmosek_4fusion_4ExprLinearDomain_2(_a_0,_a_1)
  def _constraint_SLmosek_4fusion_4ExprLinearDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,(_a_1.expr),(_a_1.dom)))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1,_a_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4ExprPSDDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ExprPSDDomain_2__(_a_0))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4ExprPSDDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ExprPSDDomain_2__(_a_0))
  def _constraint_alt_Lmosek_4fusion_4ExprPSDDomain_2(self,_t__a_0):
    return self._constraint_Lmosek_4fusion_4ExprPSDDomain_2(_a_0)
  def _constraint_Lmosek_4fusion_4ExprPSDDomain_2(self,_a_0):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",(_a_0.expr),(_a_0.dom)))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4ExprPSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4ExprPSDDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4ExprPSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ExprPSDDomain_2__(_a_1))
  def _constraint_alt_SLmosek_4fusion_4ExprPSDDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_SLmosek_4fusion_4ExprPSDDomain_2(_a_0,_a_1)
  def _constraint_SLmosek_4fusion_4ExprPSDDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_a_0,(_a_1.expr),(_a_1.dom)))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_a_0,_a_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_a_0,_a_1,_a_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_0))
  def _variable_alt_Lmosek_4fusion_4PSDDomain_2(self,_t__a_0):
    return self._variable_Lmosek_4fusion_4PSDDomain_2(_a_0)
  def _variable_Lmosek_4fusion_4PSDDomain_2(self,_a_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",(_a_0._shape),_a_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  def _variable_alt_IILmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._variable_IILmosek_4fusion_4PSDDomain_2(numpy.int32(__a_0),numpy.int32(__a_1),_a_2)
  def _variable_IILmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_a_1,_a_0,_a_0], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_1))
  def _variable_alt_ILmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_ILmosek_4fusion_4PSDDomain_2(numpy.int32(__a_0),_a_1)
  def _variable_ILmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_a_0,_a_0], dtype=numpy.dtype(numpy.int32)),_a_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_1))
  def _variable_alt_SLmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_SLmosek_4fusion_4PSDDomain_2(_a_0,_a_1)
  def _variable_SLmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_a_0,None,_a_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_3))
  def _variable_alt_SIILmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return self._variable_SIILmosek_4fusion_4PSDDomain_2(_a_0,numpy.int32(__a_1),numpy.int32(__a_2),_a_3)
  def _variable_SIILmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2,_a_3):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_a_0,numpy.array([_a_2,_a_1,_a_1], dtype=numpy.dtype(numpy.int32)),_a_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  def _variable_alt_SILmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._variable_SILmosek_4fusion_4PSDDomain_2(_a_0,numpy.int32(__a_1),_a_2)
  def _variable_SILmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_a_0,numpy.array([_a_1,_a_1], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_a_2))
  def _variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self._variable_S_3ILmosek_4fusion_4PSDDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable_S_3ILmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_0))
  def _variable_alt_Lmosek_4fusion_4ConeDomain_2(self,_t__a_0):
    return self._variable_Lmosek_4fusion_4ConeDomain_2(_a_0)
  def _variable_Lmosek_4fusion_4ConeDomain_2(self,_a_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",None,_a_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_0))
  def _variable_alt_Lmosek_4fusion_4RangeDomain_2(self,_t__a_0):
    return self._variable_Lmosek_4fusion_4RangeDomain_2(_a_0)
  def _variable_Lmosek_4fusion_4RangeDomain_2(self,_a_0):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",None,_a_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_0))
  def _variable_alt_Lmosek_4fusion_4LinearDomain_2(self,_t__a_0):
    return self._variable_Lmosek_4fusion_4LinearDomain_2(_a_0)
  def _variable_Lmosek_4fusion_4LinearDomain_2(self,_a_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",None,_a_0))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  def _variable_alt__3ILmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=_t__a_1
   _1_res = self._variable__3ILmosek_4fusion_4ConeDomain_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable__3ILmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  def _variable_alt__3ILmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=_t__a_1
   _1_res = self._variable__3ILmosek_4fusion_4RangeDomain_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable__3ILmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  def _variable_alt__3ILmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=_t__a_1
   _1_res = self._variable__3ILmosek_4fusion_4LinearDomain_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable__3ILmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_a_0,_a_1))
  @staticmethod
  def _match_variable__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_variable__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _variable_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._variable__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable__3I(self,_a_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_a_0,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  def _variable_alt_ILmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_ILmosek_4fusion_4ConeDomain_2(numpy.int32(__a_0),_a_1)
  def _variable_ILmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),_a_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  def _variable_alt_ILmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_ILmosek_4fusion_4RangeDomain_2(numpy.int32(__a_0),_a_1)
  def _variable_ILmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),_a_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  def _variable_alt_ILmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_ILmosek_4fusion_4LinearDomain_2(numpy.int32(__a_0),_a_1)
  def _variable_ILmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),_a_1))
  @staticmethod
  def _match_variable_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_variable_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _variable_alt_I(self,_t__a_0):
    return self._variable_I(numpy.int32(__a_0))
  def _variable_I(self,_a_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_variable_(*args):
    if len(args) != 0: return False
    return True
  def _variable_alt_(self,):
    return self._variable_()
  def _variable_(self,):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_1))
  def _variable_alt_SLmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_SLmosek_4fusion_4ConeDomain_2(_a_0,_a_1)
  def _variable_SLmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_a_0,None,_a_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_1))
  def _variable_alt_SLmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_SLmosek_4fusion_4RangeDomain_2(_a_0,_a_1)
  def _variable_SLmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_a_0,None,_a_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_1))
  def _variable_alt_SLmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1):
    return self._variable_SLmosek_4fusion_4LinearDomain_2(_a_0,_a_1)
  def _variable_SLmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,None,_a_1))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_2))
  def _variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self._variable_S_3ILmosek_4fusion_4ConeDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable_S_3ILmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_2))
  def _variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self._variable_S_3ILmosek_4fusion_4RangeDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self._variable_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable_S_3ILmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_variable_S_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_variable_S_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _variable_alt_S_3I(self,_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._variable_S_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _variable_S_3I(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,_a_1,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_2))
  def _variable_alt_SILmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._variable_SILmosek_4fusion_4ConeDomain_2(_a_0,numpy.int32(__a_1),_a_2)
  def _variable_SILmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_a_0,numpy.array([_a_1], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_2))
  def _variable_alt_SILmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._variable_SILmosek_4fusion_4RangeDomain_2(_a_0,numpy.int32(__a_1),_a_2)
  def _variable_SILmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_a_0,numpy.array([_a_1], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_2))
  def _variable_alt_SILmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._variable_SILmosek_4fusion_4LinearDomain_2(_a_0,numpy.int32(__a_1),_a_2)
  def _variable_SILmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1,_a_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,numpy.array([_a_1], dtype=numpy.dtype(numpy.int32)),_a_2))
  @staticmethod
  def _match_variable_SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_variable_SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _variable_alt_SI(self,_t__a_0,_t__a_1):
    return self._variable_SI(_a_0,numpy.int32(__a_1))
  def _variable_SI(self,_a_0,_a_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,numpy.array([_a_1], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_variable_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _variable_alt_S(self,_t__a_0):
    return self._variable_S(_a_0)
  def _variable_S(self,_a_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  def _removeConstraintBlock_alt_I(self,_t__a_0):
    return self._removeConstraintBlock_I(numpy.int32(__a_0))
  def _removeConstraintBlock_I(self,_a_0):
   if (_a_0 >= 0):
    self.__con_1release_I(_a_0)
   else:
    self.__acon_1release_I((- (1 + _a_0)))
  def _removeVariableBlock_alt_J(self,_t__a_0):
    return self._removeVariableBlock_J(numpy.int64(__a_0))
  def _removeVariableBlock_J(self,_a_0):
   if (self.__con_blocks._is_1parameterized_() or self.__afe_blocks._is_1parameterized_()):
    raise mosek_fusion_DeletionError._ctor_S("Cannot remove variables in parameterized model")
   if (_a_0 < 0):
    raise mosek_fusion_DeletionError._ctor_S("PSD variables cannot be removed")
   else:
    _a_1=numpy.int32(_a_0)
    _a_2=self.__var_block_map._blocksize_I(_a_1)
    _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    self.__var_block_map._get_I_3II(_a_1,_a_3,0)
    self.__var_block_map._free_I(_a_1)
    _a_4=self.__var_block_acc_id[_a_1]
    if (_a_4 >= 0):
     self._removeConstraintBlock_I(_a_4)
    self._task_1var_1putboundlist_1fr__3I(_a_3)
    self._task_1clearacollist__3I(_a_3)
  def __ranged_1variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1,_a_2):
   if ((int(len(_a_0)) > 0) and self._hasVariable_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_a_0)._a_S("'")._toString_())
   _a_3=_a_2._finalize_1and_1validate__3I(_a_1)
   _a_4=(_a_3._shape)
   _a_5=int((_a_4).shape[0])
   _a_6=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_49(_a_5,_a_4,_a_6) 
   _a_7=1
   _a_7 = fragments._c_closure_50(_a_7,_a_4)
   _a_7 = numpy.int32(_a_7) # postprocess
   _a_8=None
   _a_9=None
   _a_10=None
   _a_11=None
   _a_12=None
   _a_13=None
   if ((int(len(_a_0)) > 0) and ((_a_3._indexnames) is not None)):
    _a_14=mosek.fusion.Utils.StringBuffer()
    _a_15=mosek.fusion.Utils.StringBuffer()
    _a_16=0
    _a_17=0
    _a_18=0
    if (int(((_a_3._indexnames)).shape[0])!=_a_5):
     raise mosek_fusion_DomainError._ctor_S("Invalid index name definition")
    for _a_19 in range(0,int(((_a_3._indexnames)).shape[0])):
     if ((_a_3._indexnames)[_a_19] is not None):
      if (_a_4[_a_19]!=int(((_a_3._indexnames)[_a_19]).shape[0])):
       raise mosek_fusion_DomainError._ctor_S("Invalid index name definition")
      _a_18 += _a_4[_a_19]
    _a_9 = numpy.zeros(((_a_18 + 1),), dtype=numpy.dtype(numpy.int64))
    _a_8 = numpy.array([(- 1) for _a_20 in range(0,_a_5)], dtype=numpy.dtype(numpy.int32))
    for _a_21 in range(0,int(((_a_3._indexnames)).shape[0])):
     if ((_a_3._indexnames)[_a_21] is not None):
      _a_8[_a_21] = _a_16
      for _a_22 in range(0,_a_4[_a_21]):
       _a_14._a_S((_a_3._indexnames)[_a_21][_a_22])
       _a_16 += 1
       _a_17 += int(len((_a_3._indexnames)[_a_21][_a_22]))
       _a_9[_a_16] = _a_17
    _a_10 = _a_14
    _a_13 = _a_15
   _a_23=None
   _a_24=None
   if (_a_3._empty):
    _a_23 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   elif ((_a_3._sparsity) is not None):
    if (int(((_a_3._sparsity)).shape[1])!=_a_5):
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _a_25=int(((_a_3._sparsity)).shape[0])
    _a_23 = numpy.zeros((_a_25,), dtype=numpy.dtype(numpy.int64))
    _a_26=False
    _a_27=(_a_3._sparsity)
    _a_26 = fragments._c_closure_51(_a_26,_a_25,_a_4,_a_27,_a_23,_a_6)
    if _a_26:
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is out of bounds")
    _a_28=(_a_3._sparsity)
    _a_29=0
    _a_29 = fragments._c_closure_52(_a_29,_a_5,_a_4)
    _a_29 = numpy.int32(_a_29) # postprocess
    _a_30=numpy.zeros((_a_25,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_53(_a_30,_a_25) 
    _a_31=numpy.zeros((_a_25,), dtype=numpy.dtype(numpy.int32))
    _a_32=numpy.zeros(((_a_29 + 1),), dtype=numpy.dtype(numpy.int32))
    for _a_33 in range(0,_a_5):
     fragments._c_closure_54(_a_30,_a_33,_a_28,_a_25,_a_5,_a_32,_a_4,_a_31) 
     _a_34=_a_30
     _a_30 = _a_31
     _a_31 = _a_34
    fragments._c_closure_55(_a_30,_a_28,_a_25,_a_5,_a_23,_a_6) 
   _a_35=(int((_a_23).shape[0]) if ((_a_23 is not None) ) else _a_7)
   _a_36=numpy.zeros((_a_35,), dtype=numpy.dtype(numpy.int32))
   _a_37=self.__linearvar_1alloc_I_3I(_a_35,_a_36)
   if (int(len(_a_0)) > 0):
    self.__var_map._setItem_SI(_a_0,_a_37)
    _a_38=mosek.fusion.Utils.StringBuffer()
    _a_38._a_S(_a_0)._a_S("[")
    if (_a_5 > 0):
     _a_38._a_S("%0")
     for _a_39 in range(1,_a_5):
      _a_38._a_S(",%")._a_I(_a_39)
    _a_38._a_S("]")
    if ((_a_3._indexnames) is not None):
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_a_36,_a_38._toString_(),_a_4,_a_23,(_a_3._indexnames))
    else:
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_a_36,_a_38._toString_(),_a_4,_a_23,None)
   if (_a_3._scalable):
    _a_40 = numpy.array([(_a_3._lb)[0] for _a_42 in range(0,_a_35)], dtype=numpy.dtype(numpy.float64))
    _a_41 = numpy.array([(_a_3._ub)[0] for _a_43 in range(0,_a_35)], dtype=numpy.dtype(numpy.float64))
   else:
    _a_40 = (_a_3._lb)
    _a_41 = (_a_3._ub)
   self._task_1var_1putboundlist_1ra__3I_3D_3D(_a_36,_a_40,_a_41)
   _a_44=mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_a_0,_a_37,_a_4,_a_23,_a_36)
   if (_a_3._cardinal_flag):
    self._task_1var_1putintlist__3I(_a_36)
   self.__vars[_a_37] = _a_44
   return (_a_44)
  def __variable_1_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __variable_1_S_3ILmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1,_a_2):
   _a_3=_a_2._finalize_1and_1validate__3I(_a_1)
   if ((int(len(_a_0)) > 0) and self._hasVariable_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_a_0)._a_S("'")._toString_())
   _a_4=(_a_3._shape)
   _a_5=int((_a_4).shape[0])
   _a_6=_a_3._getAxis_()
   _a_7=_a_4[_a_6]
   _a_8=1
   _a_9=1
   _a_10=1
   _a_10 = fragments._c_closure_56(_a_10,_a_5,_a_4)
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_9 = fragments._c_closure_57(_a_6,_a_9,_a_4)
   _a_9 = numpy.int32(_a_9) # postprocess
   _a_8 = fragments._c_closure_58(_a_6,_a_8,_a_5,_a_4)
   _a_8 = numpy.int32(_a_8) # postprocess
   _a_11=(_a_9 * _a_8)
   if ((_a_3._key)==mosek.fusion.QConeKey.InQCone):
    if (_a_7 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for quadratic cone")._toString_())
    _a_12 = self._task_1append_1domain_1quad_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.InRotatedQCone):
    if (_a_7 < 3):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for rotated quadratic cone")._toString_())
    _a_12 = self._task_1append_1domain_1rquad_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.InPExpCone):
    if (_a_7!=3):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for exponential cone")._toString_())
    _a_12 = self._task_1append_1domain_1pexp_()
   elif ((_a_3._key)==mosek.fusion.QConeKey.InPPowCone):
    if (_a_7 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for power cone")._toString_())
    _a_12 = self._task_1append_1domain_1ppow_I_3D(_a_7,(_a_3._alpha))
   elif ((_a_3._key)==mosek.fusion.QConeKey.InDExpCone):
    if (_a_7!=3):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for dual exponential cone")._toString_())
    _a_12 = self._task_1append_1domain_1dexp_()
   elif ((_a_3._key)==mosek.fusion.QConeKey.InDPowCone):
    if (_a_7 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for dual power cone")._toString_())
    _a_12 = self._task_1append_1domain_1dpow_I_3D(_a_7,(_a_3._alpha))
   elif ((_a_3._key)==mosek.fusion.QConeKey.InPGeoMeanCone):
    if (_a_7 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for primal geometric mean cone")._toString_())
    _a_12 = self._task_1append_1domain_1pgeomean_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.InDGeoMeanCone):
    if (_a_7 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for dual geometric mean cone")._toString_())
    _a_12 = self._task_1append_1domain_1dgeomean_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.Positive):
    _a_12 = self._task_1append_1domain_1rpos_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.InSVecPSDCone):
    _a_13=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _a_7))) - 1) / 2))
    if (((_a_13 * (_a_13 + 1)) // 2)!=_a_7):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for vector positive semidefinite cone")._toString_())
    _a_12 = self._task_1append_1domain_1svec_1psd_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.Negative):
    _a_12 = self._task_1append_1domain_1rneg_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.Unbounded):
    _a_12 = self._task_1append_1domain_1r_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.Zero):
    _a_12 = self._task_1append_1domain_1rzero_I(_a_7)
   elif ((_a_3._key)==mosek.fusion.QConeKey.InPSDCone):
    if (_a_7 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for positive semidefinite cone")._toString_())
    else:
     _a_14=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _a_7))) - 1) / 2))
     if (((_a_14 * (_a_14 + 1)) // 2)!=_a_7):
      raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_7)._a_S(") for positive semidefinite cone")._toString_())
    _a_12 = self._task_1append_1domain_1svec_1psd_I(_a_7)
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid cone type")
   _a_15=numpy.zeros(((_a_11 * _a_7),), dtype=numpy.dtype(numpy.int32))
   _a_16=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
   _a_17=self.__conicvar_1alloc_JII_3I_3I(_a_12,_a_7,_a_11,_a_16,_a_15)
   self._task_1var_1putboundlist_1fr__3I(_a_15)
   if (_a_3._int_flag):
    self._task_1var_1putintlist__3I(_a_15)
   _a_18=_a_15
   if (_a_6 < (int((_a_4).shape[0]) - 1)):
    _a_18 = numpy.zeros((int((_a_15).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _a_19=0
    _a_19 = fragments._c_closure_59(_a_7,_a_9,_a_8,_a_15,_a_19,_a_18)
    _a_19 = numpy.int32(_a_19) # postprocess
   _a_20=mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4Model_2SI_3I_3I(self,_a_0,_a_17,_a_4,_a_15)
   self.__vars[_a_17] = _a_20
   if (int(len(_a_0)) > 0):
    _a_21=mosek.fusion.Utils.StringBuffer()
    _a_21._a_S(_a_0)._a_S("[")
    if (_a_5 > 0):
     _a_21._a_S("%0")
     for _a_22 in range(1,_a_5):
      _a_21._a_S(",%")._a_I(_a_22)
    _a_21._a_S("]")
    if ((_a_3._indexnames) is not None):
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_a_18,_a_21._toString_(),_a_4,None,(_a_3._indexnames))
    else:
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_a_18,_a_21._toString_(),_a_4,None,None)
    _a_23=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
    self.__acc_block_map._get_I_3II(self.__var_block_acc_id[_a_17],_a_23,0)
    _a_24=numpy.zeros(((int((_a_4).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_60(_a_24,_a_6,_a_4) 
    fragments._c_closure_61(_a_24,_a_6,_a_5,_a_4) 
    _a_25=mosek.fusion.Utils.StringBuffer()
    _a_25._a_S(_a_0)._a_S("[")
    if ((_a_5 - 1) > 0):
     _a_25._a_S("%0")
     for _a_26 in range(1,(_a_5 - 1)):
      _a_25._a_S(",%")._a_I(_a_26)
    _a_25._a_S("]")
    if ((_a_3._indexnames) is not None):
     _a_27=numpy.ndarray(((_a_5 - 1),), dtype=numpy.dtype(object))
     for _a_28 in range(0,_a_6):
      _a_27[_a_28] = (_a_3._indexnames)[_a_28]
     for _a_29 in range((_a_6 + 1),_a_5):
      _a_27[(_a_29 - 1)] = (_a_3._indexnames)[_a_29]
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([numpy.int64(_a_23[_a_30]) for _a_30 in range(0,_a_11)], dtype=numpy.dtype(numpy.int64)),_a_25._toString_(),_a_24,_a_27)
    else:
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([numpy.int64(_a_23[_a_31]) for _a_31 in range(0,_a_11)], dtype=numpy.dtype(numpy.int64)),_a_25._toString_(),_a_24,None)
    self.__var_map._setItem_SI(_a_0,_a_17)
   return (_a_20)
  def __variable_1_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __variable_1_S_3ILmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1,_a_2):
   if ((int(len(_a_0)) > 0) and self._hasVariable_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_a_0)._a_S("'")._toString_())
   _a_3=_a_2._finalize_1and_1validate__3I(_a_1)
   _a_4=(_a_3._shape)
   _a_5=int((_a_4).shape[0])
   _a_6=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_62(_a_5,_a_4,_a_6) 
   _a_7=1
   _a_7 = fragments._c_closure_63(_a_7,_a_4)
   _a_7 = numpy.int32(_a_7) # postprocess
   _a_8=None
   _a_9=None
   _a_10=None
   _a_11=None
   _a_12=None
   _a_13=None
   if ((int(len(_a_0)) > 0) and ((_a_3._indexnames) is not None)):
    _a_14=mosek.fusion.Utils.StringBuffer()
    _a_15=mosek.fusion.Utils.StringBuffer()
    _a_16=0
    _a_17=0
    _a_18=0
    if (int(((_a_3._indexnames)).shape[0])!=_a_5):
     raise mosek_fusion_DomainError._ctor_S("Invalid index name definition")
    for _a_19 in range(0,int(((_a_3._indexnames)).shape[0])):
     if ((_a_3._indexnames)[_a_19] is not None):
      if (_a_4[_a_19]!=int(((_a_3._indexnames)[_a_19]).shape[0])):
       raise mosek_fusion_DomainError._ctor_S("Invalid index name definition")
      _a_18 += _a_4[_a_19]
    _a_9 = numpy.zeros(((_a_18 + 1),), dtype=numpy.dtype(numpy.int64))
    _a_8 = numpy.array([(- 1) for _a_20 in range(0,_a_5)], dtype=numpy.dtype(numpy.int32))
    for _a_21 in range(0,int(((_a_3._indexnames)).shape[0])):
     if ((_a_3._indexnames)[_a_21] is not None):
      _a_8[_a_21] = _a_16
      for _a_22 in range(0,_a_4[_a_21]):
       _a_14._a_S((_a_3._indexnames)[_a_21][_a_22])
       _a_16 += 1
       _a_17 += int(len((_a_3._indexnames)[_a_21][_a_22]))
       _a_9[_a_16] = _a_17
    _a_10 = _a_14
    _a_13 = _a_15
   _a_23=None
   _a_24=None
   if (_a_3._empty):
    _a_23 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   elif ((_a_3._sparsity) is not None):
    if (int(((_a_3._sparsity)).shape[1])!=_a_5):
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _a_25=int(((_a_3._sparsity)).shape[0])
    _a_23 = numpy.zeros((_a_25,), dtype=numpy.dtype(numpy.int64))
    _a_26=False
    _a_27=(_a_3._sparsity)
    _a_26 = fragments._c_closure_64(_a_26,_a_25,_a_4,_a_27,_a_23,_a_6)
    if _a_26:
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is out of bounds")
    _a_28=(_a_3._sparsity)
    _a_29=0
    _a_29 = fragments._c_closure_65(_a_29,_a_5,_a_4)
    _a_29 = numpy.int32(_a_29) # postprocess
    _a_30=numpy.zeros((_a_25,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_66(_a_30,_a_25) 
    _a_31=numpy.zeros((_a_25,), dtype=numpy.dtype(numpy.int32))
    _a_32=numpy.zeros(((_a_29 + 1),), dtype=numpy.dtype(numpy.int32))
    for _a_33 in range(0,_a_5):
     fragments._c_closure_67(_a_30,_a_33,_a_28,_a_25,_a_5,_a_32,_a_4,_a_31) 
     _a_34=_a_30
     _a_30 = _a_31
     _a_31 = _a_34
    fragments._c_closure_68(_a_30,_a_28,_a_25,_a_5,_a_23,_a_6) 
   _a_35=(int((_a_23).shape[0]) if ((_a_23 is not None) ) else _a_7)
   _a_36=numpy.zeros((_a_35,), dtype=numpy.dtype(numpy.float64))
   if ((_a_3._bnd) is not None):
    if (int(((_a_3._bnd)).shape[0])==1):
     for _a_37 in range(0,_a_35):
      _a_36[_a_37] = (_a_3._bnd)[0]
    elif (int(((_a_3._bnd)).shape[0])==_a_35):
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_a_3._bnd),0,_a_36,0,_a_35)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Invalid right hand side shape in domain")
   _a_38=numpy.zeros((_a_35,), dtype=numpy.dtype(numpy.int32))
   _a_39=self.__linearvar_1alloc_I_3I(_a_35,_a_38)
   if ((_a_3._key)==mosek.fusion.RelationKey.IsFree):
    self._task_1var_1putboundlist_1fr__3I(_a_38)
   if ((_a_3._key)==mosek.fusion.RelationKey.LessThan):
    self._task_1var_1putboundlist_1up__3I_3D(_a_38,_a_36)
   elif ((_a_3._key)==mosek.fusion.RelationKey.GreaterThan):
    self._task_1var_1putboundlist_1lo__3I_3D(_a_38,_a_36)
   elif ((_a_3._key)==mosek.fusion.RelationKey.EqualsTo):
    self._task_1var_1putboundlist_1fx__3I_3D(_a_38,_a_36)
   _a_40=mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_a_0,_a_39,_a_4,_a_23,_a_38)
   self.__vars[_a_39] = _a_40
   if (int(len(_a_0)) > 0):
    _a_41=mosek.fusion.Utils.StringBuffer()
    _a_41._a_S(_a_0)._a_S("[")
    if (_a_5 > 0):
     _a_41._a_S("%0")
     for _a_42 in range(1,_a_5):
      _a_41._a_S(",%")._a_I(_a_42)
    _a_41._a_S("]")
    if ((_a_3._indexnames) is not None):
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_a_38,_a_41._toString_(),_a_4,_a_23,(_a_3._indexnames))
    else:
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_a_38,_a_41._toString_(),_a_4,_a_23,None)
    self.__var_map._setItem_SI(_a_0,_a_39)
   if (_a_3._cardinal_flag):
    self._task_1var_1putintlist__3I(_a_38)
   return (_a_40)
  def __variable_1_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=_t__a_2
   _1_res = self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __variable_1_S_3ILmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2):
   if ((int(len(_a_0)) > 0) and self._hasVariable_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_a_0)._a_S("'")._toString_())
   _a_3=_a_2._finalize_1and_1validate__3I(_a_1)
   _a_4=(_a_3._shape)
   _a_5=(_a_3._conedim1)
   _a_6=(_a_3._conedim2)
   _a_7=int((_a_4).shape[0])
   _a_8=_a_4[_a_5]
   if (_a_5 > _a_6):
    _a_9=_a_5
    _a_5 = _a_6
    _a_6 = _a_9
   if ((_a_5==_a_6) or ((_a_5 < 0) or (_a_6 >= _a_7))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone order dimensions for semidefinite variables")
   if (_a_4[_a_5]!=_a_4[_a_6]):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape in cone order dimensions")
   _a_10=1
   _a_10 = fragments._c_closure_69(_a_5,_a_10,_a_4)
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_10 = fragments._c_closure_70(_a_5,_a_6,_a_10,_a_4)
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_10 = fragments._c_closure_71(_a_6,_a_7,_a_10,_a_4)
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_11=(((_a_10 * _a_8) * (_a_8 + 1)) // 2)
   _a_12=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
   _a_13=numpy.zeros((_a_10,), dtype=numpy.dtype(numpy.int32))
   _a_14=self.__barvar_1alloc_II_3I_3J(_a_8,_a_10,_a_13,_a_12)
   _a_15=mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(self,_a_0,_a_14,_a_4,(_a_3._conedim1),(_a_3._conedim2),_a_13,_a_12)
   if (int(len(_a_0)) > 0):
    _a_16=numpy.zeros(((_a_7 - 2),), dtype=numpy.dtype(numpy.int32))
    _a_17=(_a_5 if ((_a_5 < _a_6) ) else _a_6)
    _a_18=(_a_6 if ((_a_5 < _a_6) ) else _a_5)
    fragments._c_closure_72(_a_17,_a_16,_a_4) 
    fragments._c_closure_73(_a_17,_a_18,_a_16,_a_4) 
    fragments._c_closure_74(_a_18,_a_16,_a_7,_a_4) 
    _a_19=mosek.fusion.Utils.StringBuffer()
    _a_19._a_S(_a_0)._a_S("[")
    if ((_a_7 - 2) > 0):
     _a_19._a_S("%0")
     for _a_20 in range(1,(_a_7 - 2)):
      _a_19._a_S(",%")._a_I(_a_20)
    _a_19._a_S("]")
    if ((_a_3._indexnames) is not None):
     _a_21=numpy.ndarray(((_a_7 - 2),), dtype=numpy.dtype(object))
     for _a_22 in range(0,_a_17):
      _a_21[_a_22] = (_a_3._indexnames)[_a_22]
     for _a_23 in range((_a_17 + 1),_a_18):
      _a_21[(_a_23 - 1)] = (_a_3._indexnames)[_a_23]
     for _a_24 in range((_a_18 + 1),_a_7):
      _a_21[(_a_24 - 2)] = (_a_3._indexnames)[_a_24]
     self._task_1format_1barvar_1names__3IS_3I_3_3S(_a_13,_a_19._toString_(),_a_16,_a_21)
    else:
     self._task_1format_1barvar_1names__3IS_3I_3_3S(_a_13,_a_19._toString_(),_a_16,None)
   self.__barvars[_a_14] = _a_15
   if (int(len(_a_0)) > 0):
    self.__var_map._setItem_SI(_a_0,(- (_a_14 + 1)))
   return (_a_15)
  def __putfrows_alt__3IILmosek_4fusion_4WorkStack_2IIIII(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _a_2=_t__a_2
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.int32(_t__a_5)
   _a_6=numpy.int32(_t__a_6)
   _a_7=numpy.int32(_t__a_7)
   _1_res = self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(self,_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7):
   _a_8=(_a_2.i32)
   _a_9=(_a_2.i64)
   _a_10=(_a_2.f64)
   _a_11=0
   _a_12=0
   _a_13=0
   _a_12,_a_11,_a_13 = fragments._c_closure_75(_a_12,self.__barvar_block_elm_barj,_a_11,_a_3,_a_6,_a_5,_a_8,_a_9,_a_13)
   _a_12 = numpy.int32(_a_12) # postprocess
   _a_11 = numpy.int32(_a_11) # postprocess
   _a_13 = numpy.int32(_a_13) # postprocess
   if (_a_3 > (int((_a_0).shape[0]) - _a_1)):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Mismatching sizes")
   _a_14=_a_3
   _a_15=numpy.zeros(((_a_14 + 1),), dtype=numpy.dtype(numpy.int32))
   _a_16=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
   _a_17=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.float64))
   _a_18=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_76(_a_18,_a_17,_a_7,_a_3,_a_6,_a_5,_a_15,_a_10,_a_8,_a_9,_a_16) 
   self._task_1putafeflist__3J_3I_3I_3D_3D(numpy.array([_a_0[(_a_19 + _a_1)] for _a_19 in range(0,_a_3)], dtype=numpy.dtype(numpy.int64)),_a_15,_a_16,_a_17,_a_18)
   if (_a_12 > 0):
    _a_20=_a_0
    _a_21=numpy.zeros(((_a_14 + 1),), dtype=numpy.dtype(numpy.int32))
    _a_22=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    _a_23=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    _a_24=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int64))
    _a_25=numpy.array([(- 1) for _a_26 in range(0,_a_13)], dtype=numpy.dtype(numpy.int32))
    _a_27=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
    _a_28=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.float64))
    _a_29=0
    _a_30=0
    _a_30,_a_29 = fragments._c_closure_77(_a_30,_a_29,_a_22,self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,self.__barvar_dim,_a_7,_a_28,_a_23,_a_24,_a_25,_a_27,_a_6,_a_14,_a_21,_a_5,_a_10,_a_8,_a_9)
    _a_30 = numpy.int32(_a_30) # postprocess
    _a_29 = numpy.int32(_a_29) # postprocess
    _a_31=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_a_23,_a_24,_a_25,_a_27,_a_28)
    self._task_1putafebarfrowlist__3I_3I_3I_3J(_a_20,_a_21,_a_22,_a_31)
  def __putarows_alt__3ILmosek_4fusion_4WorkStack_2IIIII(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=_t__a_1
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.int32(_t__a_5)
   _a_6=numpy.int32(_t__a_6)
   _1_res = self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __putarows__3ILmosek_4fusion_4WorkStack_2IIIII(self,_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6):
   _a_7=(_a_1.i32)
   _a_8=(_a_1.i64)
   _a_9=(_a_1.f64)
   _a_10=0
   _a_11=0
   _a_12=0
   _a_11,_a_10,_a_12 = fragments._c_closure_78(_a_11,self.__barvar_block_elm_barj,_a_6,_a_10,_a_2,_a_5,_a_4,_a_9,_a_7,_a_8,_a_12)
   _a_11 = numpy.int32(_a_11) # postprocess
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_12 = numpy.int32(_a_12) # postprocess
   _a_13=int((_a_0).shape[0])
   _a_14=numpy.zeros(((_a_13 + 1),), dtype=numpy.dtype(numpy.int64))
   _a_15=numpy.zeros((_a_10,), dtype=numpy.dtype(numpy.int32))
   _a_16=numpy.zeros((_a_10,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_79(_a_16,_a_6,_a_2,_a_5,_a_4,_a_14,_a_9,_a_7,_a_8,_a_15) 
   self._task_1putarowlist__3I_3J_3I_3D(_a_0,_a_14,_a_15,_a_16)
   if (_a_11 > 0):
    _a_17=_a_0
    _a_18=numpy.zeros(((_a_13 + 1),), dtype=numpy.dtype(numpy.int64))
    _a_19=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
    _a_20=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
    _a_21=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
    _a_22=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    _a_23=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
    _a_24=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.float64))
    _a_25=0
    _a_26=0
    _a_26,_a_25 = fragments._c_closure_80(_a_26,_a_25,_a_19,self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,self.__barvar_dim,_a_6,_a_24,_a_20,_a_21,_a_22,_a_23,_a_5,_a_13,_a_18,_a_4,_a_9,_a_7,_a_8)
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_25 = numpy.int32(_a_25) # postprocess
    _a_27=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_a_20,_a_21,_a_22,_a_23,_a_24)
    self._task_1putbararowlist__3I_3J_3I_3J(_a_17,_a_18,_a_19,_a_27)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_a_0,_a_1,_a_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_a_0,_a_1,_a_2):
   if (((self.__rs.pi32)!=0) or (((self.__rs.pi64)!=0) or ((self.__rs.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack rs not clean")
   if (((self.__ws.pi32)!=0) or (((self.__ws.pi64)!=0) or ((self.__ws.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack ws not clean")
   self.__xs._clear_()
   if ((int(len(_a_0)) > 0) and self._hasConstraint_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_a_0)._a_S("'")._toString_())
   if (_a_2._cardinal_flag):
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _a_3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_1)))
   _a_3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _a_4=(self.__rs.i32)
   _a_5=(self.__rs.i64)
   _a_6=(self.__rs.f64)
   _a_7=(self.__rs.nd)
   _a_8=(self.__rs.shape_base)
   _a_9=(self.__rs.nelem)
   _a_10=(self.__rs.nnz)
   _a_11=(self.__rs.ncodeatom)
   _a_12=(self.__rs.hassp)
   _a_13=(self.__rs.ptr_base)
   _a_14=(self.__rs.nidxs_base)
   _a_15=(self.__rs.cof_base)
   _a_16=(self.__rs.codeptr_base)
   _a_17=(self.__rs.code_base)
   _a_18=(self.__rs.cconst_base)
   _a_19=numpy.array([_a_4[(_a_8 + _a_20)] for _a_20 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
   _a_21=_a_2._finalize_1and_1validate__3I(_a_19)
   if ((_a_21._shape) is not None):
    if (int(((_a_21._shape)).shape[0])!=_a_7):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
    else:
     for _a_22 in range(0,_a_7):
      if ((_a_21._shape)[_a_22]!=_a_4[(_a_8 + _a_22)]):
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _a_23=1
   _a_23 = fragments._c_closure_81(_a_7,_a_23,_a_4,_a_8)
   _a_23 = numpy.int32(_a_23) # postprocess
   _a_24=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.int32))
   _a_25=self.__con_1allocate__3I(_a_24)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_a_24,self.__rs,_a_9,_a_10,_a_13,_a_14,_a_15)
   self.__xs._clear_()
   _a_26=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.float64))
   _a_27=numpy.zeros((_a_23,), dtype=numpy.dtype(numpy.float64))
   _a_28=(_a_21._lb)
   _a_29=(_a_21._ub)
   _a_30=(_a_21._empty)
   _a_31=(_a_21._scalable)
   _a_32=(_a_21._sparsity)
   fragments._c_closure_82(_a_26,_a_27,_a_30,_a_28,_a_31,_a_32,_a_29,_a_7,_a_23,_a_4,_a_8) 
   self._task_1con_1putboundlist_1ra__3I_3D_3D(_a_24,_a_26,_a_27)
   if (_a_11 > 0):
    self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_a_24,_a_13,_a_14,_a_16,_a_17,_a_18)
   if (int(len(_a_0)) > 0):
    _a_33=mosek.fusion.Utils.StringBuffer()
    _a_33._a_S(_a_0)._a_S("[")
    if (int((_a_19).shape[0]) > 0):
     _a_33._a_S("%0")
    for _a_34 in range(1,int((_a_19).shape[0])):
     _a_33._a_S(",%")._a_I(_a_34)
    _a_33._a_S("]")
    if ((_a_21._indexnames) is not None):
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_a_24,_a_33._toString_(),_a_19,None,(_a_21._indexnames))
    else:
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_a_24,_a_33._toString_(),_a_19,None,None)
   _a_35=mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4Model_2S_3I_3II(self,_a_0,numpy.array([_a_4[(_a_8 + _a_36)] for _a_36 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32)),_a_24,_a_25)
   self.__cons[_a_25] = _a_35
   if (int(len(_a_0)) > 0):
    self.__con_map._setItem_SI(_a_0,_a_25)
   return (_a_35)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_a_0,_a_1,_a_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_a_0,_a_1,_a_2):
   if (((self.__rs.pi32)!=0) or (((self.__rs.pi64)!=0) or ((self.__rs.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack rs not clean")
   if (((self.__ws.pi32)!=0) or (((self.__ws.pi64)!=0) or ((self.__ws.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack ws not clean")
   self.__xs._clear_()
   _a_3=_a_1._getShape_()
   _a_4=_a_2._finalize_1and_1validate__3I(_a_3)
   _a_5=((_a_4._conedim1) < (_a_4._conedim2))
   _a_6=((_a_4._conedim2) if (((_a_4._conedim1) < (_a_4._conedim2)) ) else (_a_4._conedim1))
   _a_7=((_a_4._conedim1) if (((_a_4._conedim1) < (_a_4._conedim2)) ) else (_a_4._conedim2))
   _a_8=mosek_fusion_ExprDenseTril._ctor_IILmosek_4fusion_4Expression_2(_a_7,_a_6,mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprScaleVecPSD._ctor_IILmosek_4fusion_4Expression_2(_a_7,_a_6,mosek_fusion_ExprDenseTril._ctor_IILmosek_4fusion_4Expression_2(_a_7,_a_6,(mosek_fusion_ExprSymmetrize._ctor_IILmosek_4fusion_4Expression_2(_a_7,_a_6,_a_1) if (((_a_4._key)==mosek.fusion.PSDKey.IsSymPSD) ) else _a_1))))))
   _a_8._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _a_9=(self.__rs.i32)
   _a_10=(self.__rs.i64)
   _a_11=(self.__rs.f64)
   _a_12=(self.__rs.nd)
   _a_13=(self.__rs.nelem)
   _a_14=(self.__rs.nnz)
   _a_15=(self.__rs.hassp)
   _a_16=(self.__rs.ncodeatom)
   _a_17=(self.__rs.shape_base)
   _a_18=(self.__rs.ptr_base)
   _a_19=(self.__rs.nidxs_base)
   _a_20=(self.__rs.sp_base)
   _a_21=(self.__rs.cof_base)
   _a_22=(self.__rs.codeptr_base)
   _a_23=(self.__rs.code_base)
   _a_24=(self.__rs.cconst_base)
   _a_25=_a_3[_a_6]
   _a_26=((_a_25 * (_a_25 + 1)) // 2)
   _a_27=1
   _a_27 = fragments._c_closure_83(_a_7,_a_6,_a_12,_a_27,_a_3)
   _a_27 = numpy.int32(_a_27) # postprocess
   _a_28=self._task_1append_1domain_1svec_1psd_I(_a_26)
   _a_29=(_a_26 * _a_27)
   _a_30=numpy.zeros((_a_29,), dtype=numpy.dtype(numpy.int32))
   _a_31=numpy.zeros((_a_27,), dtype=numpy.dtype(numpy.int32))
   _a_32=numpy.zeros((_a_29,), dtype=numpy.dtype(numpy.int32))
   _a_33=numpy.zeros((_a_29,), dtype=numpy.dtype(numpy.float64))
   _a_34=self.__acon_1allocate_JII_3D_3I_3I(_a_28,_a_26,_a_27,_a_33,_a_30,_a_31)
   _a_35=numpy.zeros((_a_29,), dtype=numpy.dtype(numpy.int32))
   self.__acon_block_map._get_I_3II(_a_34,_a_35,0)
   _a_36=1
   _a_37=_a_3[_a_6]
   _a_38=1
   _a_39=_a_3[_a_7]
   _a_40=1
   _a_40 = fragments._c_closure_84(_a_7,_a_40,_a_3)
   _a_40 = numpy.int64(_a_40) # postprocess
   _a_38 = fragments._c_closure_85(_a_7,_a_6,_a_38,_a_3)
   _a_38 = numpy.int64(_a_38) # postprocess
   _a_36 = fragments._c_closure_86(_a_6,_a_36,_a_12,_a_3)
   _a_36 = numpy.int64(_a_36) # postprocess
   _a_41=0
   _a_42=(1.0 / mosek.fusion.Utils.Tools._sqrt_D(2))
   _a_41 = fragments._c_closure_87(self.__acon_elm_scale,_a_35,_a_40,_a_39,_a_38,_a_37,_a_36,_a_41,_a_42)
   _a_41 = numpy.int32(_a_41) # postprocess
   _a_43=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
   _a_44=0
   _a_44 = fragments._c_closure_88(_a_30,_a_43,_a_26,_a_40,_a_39,_a_38,_a_37,_a_36,_a_44,_a_5)
   _a_44 = numpy.int32(_a_44) # postprocess
   self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_a_43,0,self.__rs,_a_13,_a_14,_a_18,_a_19,_a_21)
   if (_a_16 > 0):
    self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_a_43,_a_18,_a_19,_a_22,_a_23,_a_24)
   else:
    pass
   _a_45=numpy.zeros((((_a_27 * _a_39) * _a_39),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_89(_a_30,_a_26,_a_40,_a_39,_a_38,_a_37,_a_36,_a_45,_a_5) 
   if (int(len(_a_0)) > 0):
    _a_46=numpy.zeros(((int((_a_3).shape[0]) - 2),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_90(_a_7,_a_46,_a_3) 
    fragments._c_closure_91(_a_7,_a_6,_a_46,_a_3) 
    fragments._c_closure_92(_a_6,_a_46,_a_12,_a_3) 
    _a_47=mosek.fusion.Utils.StringBuffer()
    _a_47._a_S(_a_0)._a_S("[")
    if (_a_12 > 2):
     _a_47._a_S("%0")
     for _a_48 in range(1,(_a_12 - 2)):
      _a_47._a_S(",%")._a_I(_a_48)
    _a_47._a_S("]")
    if ((_a_4._indexnames) is not None):
     _a_49=(_a_4._indexnames)
     _a_50=numpy.ndarray(((_a_12 - 2),), dtype=numpy.dtype(object))
     for _a_51 in range(0,_a_7):
      _a_50[_a_51] = _a_49[_a_51]
     for _a_52 in range((_a_7 + 1),_a_6):
      _a_50[(_a_52 - 1)] = _a_49[_a_52]
     for _a_53 in range((_a_6 + 1),_a_12):
      _a_50[(_a_53 - 2)] = _a_49[_a_53]
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_a_31[_a_54] for _a_54 in range(0,int((_a_31).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_47._toString_(),_a_46,_a_50)
    else:
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_a_31[_a_55] for _a_55 in range(0,int((_a_31).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_47._toString_(),_a_46,None)
   _a_56=mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,_a_0,None,_a_3,_a_34,_a_45,None)
   self.__acons[_a_34] = _a_56
   if (int(len(_a_0)) > 0):
    self.__con_map._setItem_SI(_a_0,(- (1 + _a_34)))
   return (_a_56)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_a_0,_a_1,_a_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_a_0,_a_1,_a_2):
   if (((self.__rs.pi32)!=0) or (((self.__rs.pi64)!=0) or ((self.__rs.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack rs not clean")
   if (((self.__ws.pi32)!=0) or (((self.__ws.pi64)!=0) or ((self.__ws.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack ws not clean")
   self.__xs._clear_()
   if ((int(len(_a_0)) > 0) and self._hasConstraint_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_a_0)._a_S("'")._toString_())
   if ((int(len(_a_0)) > 0) and self._hasConstraint_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_a_0)._a_S("'")._toString_())
   if (_a_2._int_flag):
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _a_3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_1)))
   _a_3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _a_4=(self.__rs.i32)
   _a_5=(self.__rs.i64)
   _a_6=(self.__rs.f64)
   _a_7=(self.__rs.nd)
   _a_8=(self.__rs.shape_base)
   _a_9=(self.__rs.nelem)
   _a_10=(self.__rs.nnz)
   _a_11=(self.__rs.ncodeatom)
   _a_12=(self.__rs.hassp)
   _a_13=(self.__rs.ptr_base)
   _a_14=(self.__rs.nidxs_base)
   _a_15=(self.__rs.cof_base)
   _a_16=(self.__rs.code_base)
   _a_17=(self.__rs.codeptr_base)
   _a_18=(self.__rs.cconst_base)
   _a_19=numpy.array([_a_4[(_a_8 + _a_20)] for _a_20 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
   _a_21=_a_2._finalize_1and_1validate__3I(_a_19)
   _a_22=(_a_21._getAxis_() if (_a_21._axisIsSet_() ) else (_a_7 - 1))
   _a_23=_a_19[_a_22]
   _a_24=1
   _a_25=1
   _a_26=1
   _a_26 = fragments._c_closure_93(_a_26,_a_7,_a_19)
   _a_26 = numpy.int32(_a_26) # postprocess
   _a_25 = fragments._c_closure_94(_a_22,_a_25,_a_19)
   _a_25 = numpy.int32(_a_25) # postprocess
   _a_24 = fragments._c_closure_95(_a_22,_a_24,_a_7,_a_19)
   _a_24 = numpy.int32(_a_24) # postprocess
   _a_27=(_a_25 * _a_24)
   if ((_a_21._key)==mosek.fusion.QConeKey.InQCone):
    if (_a_23 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for quadratic cone")._toString_())
    _a_28 = self._task_1append_1domain_1quad_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.InRotatedQCone):
    if (_a_23 < 3):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for rotated quadratic cone")._toString_())
    _a_28 = self._task_1append_1domain_1rquad_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.InPExpCone):
    if (_a_23!=3):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for exponential cone")._toString_())
    _a_28 = self._task_1append_1domain_1pexp_()
   elif ((_a_21._key)==mosek.fusion.QConeKey.InPPowCone):
    if (_a_23 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for power cone")._toString_())
    if (int(((_a_21._alpha)).shape[0]) < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Power cone requires at least two parameters")._toString_())
    _a_28 = self._task_1append_1domain_1ppow_I_3D(_a_23,(_a_21._alpha))
   elif ((_a_21._key)==mosek.fusion.QConeKey.InDExpCone):
    if (_a_23!=3):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for dual exponential cone")._toString_())
    _a_28 = self._task_1append_1domain_1dexp_()
   elif ((_a_21._key)==mosek.fusion.QConeKey.InDPowCone):
    if (_a_23 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for dual power cone")._toString_())
    if (int(((_a_21._alpha)).shape[0]) < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Power cone requires at least two parameters")._toString_())
    _a_28 = self._task_1append_1domain_1dpow_I_3D(_a_23,(_a_21._alpha))
   elif ((_a_21._key)==mosek.fusion.QConeKey.InPGeoMeanCone):
    if (_a_23 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for primal geometric mean cone")._toString_())
    _a_28 = self._task_1append_1domain_1pgeomean_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.InDGeoMeanCone):
    if (_a_23 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for dual geometric mean cone")._toString_())
    _a_28 = self._task_1append_1domain_1dgeomean_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.InSVecPSDCone):
    _a_29=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _a_23))) - 1) / 2))
    if (((_a_29 * (_a_29 + 1)) // 2)!=_a_23):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for vector positive semidefinite cone")._toString_())
    _a_28 = self._task_1append_1domain_1svec_1psd_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.Positive):
    _a_28 = self._task_1append_1domain_1rpos_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.Negative):
    _a_28 = self._task_1append_1domain_1rneg_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.Unbounded):
    _a_28 = self._task_1append_1domain_1r_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.Zero):
    _a_28 = self._task_1append_1domain_1rzero_I(_a_23)
   elif ((_a_21._key)==mosek.fusion.QConeKey.InPSDCone):
    if (_a_23 < 2):
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for positive semidefinite cone")._toString_())
    else:
     _a_30=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _a_23))) - 1) / 2))
     if (((_a_30 * (_a_30 + 1)) // 2)!=_a_23):
      raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_a_23)._a_S(") for positive semidefinite cone")._toString_())
    _a_28 = self._task_1append_1domain_1svec_1psd_I(_a_23)
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid cone type")
   _a_31=numpy.zeros((_a_26,), dtype=numpy.dtype(numpy.float64))
   _a_32=numpy.zeros((_a_26,), dtype=numpy.dtype(numpy.int32))
   _a_33=numpy.zeros((_a_27,), dtype=numpy.dtype(numpy.int32))
   _a_34=self.__acon_1allocate_JII_3D_3I_3I(_a_28,_a_23,_a_27,_a_31,_a_32,_a_33)
   _a_35=numpy.zeros((_a_26,), dtype=numpy.dtype(numpy.int32))
   _a_36=0
   _a_37=(_a_21._domofs)
   _a_36 = fragments._c_closure_96(_a_23,_a_25,_a_24,_a_26,_a_31,_a_36,_a_37,_a_35)
   _a_36 = numpy.int32(_a_36) # postprocess
   _a_38=numpy.array([_a_32[_a_35[_a_39]] for _a_39 in range(0,_a_26)], dtype=numpy.dtype(numpy.int32))
   self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_a_38,0,self.__rs,_a_9,_a_10,_a_13,_a_14,_a_15)
   if (_a_11 > 0):
    self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_a_38,_a_13,_a_14,_a_17,_a_16,_a_18)
   if (int(len(_a_0)) > 0):
    _a_40=numpy.zeros(((int((_a_19).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_97(_a_40,_a_22,_a_19) 
    fragments._c_closure_98(_a_40,_a_22,_a_7,_a_19) 
    _a_41=mosek.fusion.Utils.StringBuffer()
    _a_41._a_S(_a_0)._a_S("[")
    if (_a_7 > 1):
     _a_41._a_S("%0")
     for _a_42 in range(1,(_a_7 - 1)):
      _a_41._a_S(",%")._a_I(_a_42)
    _a_41._a_S("]")
    if ((_a_21._indexnames) is not None):
     _a_43=(_a_21._indexnames)
     _a_44=numpy.ndarray(((_a_7 - 1),), dtype=numpy.dtype(object))
     for _a_45 in range(0,_a_22):
      _a_44[_a_45] = _a_43[_a_45]
     for _a_46 in range((_a_22 + 1),_a_7):
      _a_44[(_a_46 - 1)] = _a_43[_a_46]
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_a_33[_a_47] for _a_47 in range(0,int((_a_33).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_41._toString_(),_a_40,_a_44)
    else:
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_a_33[_a_48] for _a_48 in range(0,int((_a_33).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_41._toString_(),_a_40,None)
   _a_49=mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,_a_0,_a_21,_a_19,_a_34,_a_32,(_a_21._indexnames))
   self.__acons[_a_34] = _a_49
   if (int(len(_a_0)) > 0):
    self.__con_map._setItem_SI(_a_0,(- (_a_34 + 1)))
   return (_a_49)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_a_0,_a_1,_a_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_a_0,_a_1,_a_2):
   if (((self.__rs.pi32)!=0) or (((self.__rs.pi64)!=0) or ((self.__rs.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack rs not clean")
   if (((self.__ws.pi32)!=0) or (((self.__ws.pi64)!=0) or ((self.__ws.pf64)!=0))):
    raise mosek_fusion_UnexpectedError._ctor_S("Stack ws not clean")
   self.__xs._clear_()
   if ((int(len(_a_0)) > 0) and self._hasConstraint_S(_a_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_a_0)._a_S("'")._toString_())
   if (_a_2._cardinal_flag):
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _a_3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_a_1)))
   _a_3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _a_4=(self.__rs.i32)
   _a_5=(self.__rs.i64)
   _a_6=(self.__rs.f64)
   _a_7=(self.__rs.nd)
   _a_8=(self.__rs.nelem)
   _a_9=(self.__rs.nnz)
   _a_10=(self.__rs.hassp)
   _a_11=(self.__rs.ncodeatom)
   _a_12=(self.__rs.shape_base)
   _a_13=(self.__rs.ptr_base)
   _a_14=(self.__rs.nidxs_base)
   _a_15=(self.__rs.cof_base)
   _a_16=(self.__rs.codeptr_base)
   _a_17=(self.__rs.code_base)
   _a_18=(self.__rs.cconst_base)
   _a_19=numpy.array([_a_4[(_a_12 + _a_20)] for _a_20 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
   _a_21=_a_2._finalize_1and_1validate__3I(_a_19)
   _a_22=(_a_21._domsize)
   _a_23=(_a_21._indexnames)
   _a_25=numpy.zeros((_a_22,), dtype=numpy.dtype(numpy.int32))
   _a_26=self.__con_1allocate__3I(_a_25)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_a_25,self.__rs,_a_8,_a_9,_a_13,_a_14,_a_15)
   _a_27=(_a_21._sparsity)
   _a_28=(_a_21._empty)
   _a_29=(_a_21._bnd)
   _a_30=(_a_21._scalable)
   if (_a_29 is None):
    _a_24 = numpy.zeros((int((_a_25).shape[0]),), dtype=numpy.dtype(numpy.float64))
   elif _a_30:
    _a_24 = numpy.array([_a_29[0] for _a_31 in range(0,int((_a_25).shape[0]))], dtype=numpy.dtype(numpy.float64))
   elif (_a_27 is not None):
    _a_32=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int32))
    _a_32[(_a_7 - 1)] = 1
    fragments._c_closure_99(_a_7,_a_19,_a_32) 
    _a_24 = numpy.zeros((int((_a_25).shape[0]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_100(_a_24,_a_29,_a_27,_a_7,_a_32) 
   elif _a_28:
    _a_24 = numpy.zeros((int((_a_25).shape[0]),), dtype=numpy.dtype(numpy.float64))
   else:
    _a_24 = numpy.array([_a_29[_a_33] for _a_33 in range(0,int((_a_25).shape[0]))], dtype=numpy.dtype(numpy.float64))
   if ((_a_21._key)==mosek.fusion.RelationKey.IsFree):
    self._task_1con_1putboundlist_1fr__3I(_a_25)
   if ((_a_21._key)==mosek.fusion.RelationKey.LessThan):
    self._task_1con_1putboundlist_1up__3I_3D(_a_25,_a_24)
   elif ((_a_21._key)==mosek.fusion.RelationKey.GreaterThan):
    self._task_1con_1putboundlist_1lo__3I_3D(_a_25,_a_24)
   elif ((_a_21._key)==mosek.fusion.RelationKey.EqualsTo):
    self._task_1con_1putboundlist_1fx__3I_3D(_a_25,_a_24)
   if (_a_11 > 0):
    self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_a_25,_a_13,_a_14,_a_16,_a_17,_a_18)
   if (int(len(_a_0)) > 0):
    _a_34=mosek.fusion.Utils.StringBuffer()
    _a_34._a_S(_a_0)._a_S("[")
    if (int((_a_19).shape[0]) > 0):
     _a_34._a_S("%0")
    for _a_35 in range(1,int((_a_19).shape[0])):
     _a_34._a_S(",%")._a_I(_a_35)
    _a_34._a_S("]")
    if ((_a_21._indexnames) is not None):
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_a_25,_a_34._toString_(),_a_19,None,(_a_21._indexnames))
    else:
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_a_25,_a_34._toString_(),_a_19,None,None)
   _a_36=mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(self,_a_0,_a_26,_a_19,_a_25,_a_23)
   self.__cons[_a_26] = _a_36
   if (int(len(_a_0)) > 0):
    self.__con_map._setItem_SI(_a_0,_a_26)
   return (_a_36)
  @staticmethod
  def _match_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _getVersion_alt_():
    return mosek_fusion_Model._getVersion_()
  @staticmethod
  def _getVersion_():
   return (mosek.fusion.BaseModel._env_1getversion_())
  @staticmethod
  def _match_hasParameter_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_hasParameter_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _hasParameter_alt_S(self,_t__a_0):
    return self._hasParameter_S(_a_0)
  def _hasParameter_S(self,_a_0):
   return (self.__par_map._hasItem_S(_a_0))
  @staticmethod
  def _match_hasConstraint_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_hasConstraint_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _hasConstraint_alt_S(self,_t__a_0):
    return self._hasConstraint_S(_a_0)
  def _hasConstraint_S(self,_a_0):
   return (self.__con_map._hasItem_S(_a_0))
  @staticmethod
  def _match_hasVariable_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_hasVariable_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _hasVariable_alt_S(self,_t__a_0):
    return self._hasVariable_S(_a_0)
  def _hasVariable_S(self,_a_0):
   return (self.__var_map._hasItem_S(_a_0))
  @staticmethod
  def _match_getParameter_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_getParameter_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _getParameter_alt_S(self,_t__a_0):
    return self._getParameter_S(_a_0)
  def _getParameter_S(self,_a_0):
   return ((self.__parameters[self.__par_map._getItem_S(_a_0)] if (self.__par_map._hasItem_S(_a_0) ) else None))
  @staticmethod
  def _match_getConstraint_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getConstraint_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getConstraint_alt_I(self,_t__a_0):
    return self._getConstraint_I(numpy.int32(__a_0))
  def _getConstraint_I(self,_a_0):
   if (_a_0 >= 0):
    _a_1 = self.__cons[_a_0]
   else:
    _a_1 = self.__acons[(- (1 + _a_0))]
   return (_a_1)
  @staticmethod
  def _match_getConstraint_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_getConstraint_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _getConstraint_alt_S(self,_t__a_0):
    return self._getConstraint_S(_a_0)
  def _getConstraint_S(self,_a_0):
   _a_1=None
   if self.__con_map._hasItem_S(_a_0):
    _a_2=self.__con_map._getItem_S(_a_0)
    if (_a_2 >= 0):
     _a_1 = self.__cons[_a_2]
    else:
     _a_1 = self.__acons[(- (1 + _a_2))]
   return (_a_1)
  @staticmethod
  def _match_getVariable_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getVariable_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getVariable_alt_I(self,_t__a_0):
    return self._getVariable_I(numpy.int32(__a_0))
  def _getVariable_I(self,_a_0):
   return (self.__vars[_a_0])
  @staticmethod
  def _match_getVariable_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_S__(_a_0))
  @staticmethod
  def _match_alt_getVariable_S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_S__(_a_0))
  def _getVariable_alt_S(self,_t__a_0):
    return self._getVariable_S(_a_0)
  def _getVariable_S(self,_a_0):
   if self.__var_map._hasItem_S(_a_0):
    _a_1=self.__var_map._getItem_S(_a_0)
    if (_a_1 < 0):
     return (self.__barvars[(- (_a_1 + 1))])
    else:
     return (self.__vars[_a_1])
   else:
    return (None)
  @staticmethod
  def _match_getName_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getName_(*args):
    if len(args) != 0: return False
    return True
  def _getName_alt_(self,):
    return self._getName_()
  def _getName_(self,):
   return (self.__model_name)
  def _getParameterValue_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._getParameterValue__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getParameterValue__3I(self,_a_0):
   _a_1=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_101(_a_0,self.__param_value,_a_1) 
   return (_a_1)
  def _setParameterValue_alt__3I_3D(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setParameterValue__3I_3D(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setParameterValue__3I_3D(self,_a_0,_a_1):
   fragments._c_closure_102(_a_0,self.__param_value,_a_1) 
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_Model._ctor_Lmosek_4fusion_4Model_2(self))
 return Model
mosek_fusion_Model=__mk_mosek_fusion_Model()
del __mk_mosek_fusion_Model
def __mk_mosek_fusion_Debug():
  import sys
  class Debug:
    @staticmethod
    def _o_(): return Debug()
    def p(self,v):
      sys.stdout.write(str(v))
      return self
    _p_S = p
    _p_I = p
    _p_J = p
    _p_D = p
    _p_Z = p
  
    def p_array (self,v):
      if v is None:
          sys.stdout.write('None')
      else:
          sys.stdout.write('[ %s ]' % ','.join([str(i) for i in v]))
      return self
  
    _p__3I = p_array
    _p__3J = p_array
    _p__3D = p_array
  
    def _lf_(self):
      sys.stdout.write("\n")
      return self
  return Debug
mosek_fusion_Debug=__mk_mosek_fusion_Debug()
#BEFORE CLASS
def __mk_mosek_fusion_Sort():
 class Sort(object):
  @staticmethod
  def issorted(*args):
    '''
    Syntax
    ------

      mosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)
      mosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)
      mosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)
      mosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)

    Description
    -----------

    

    Parameters
    ----------

    check : bool
    first : int64
    idx : array(int64,ndim=1)
    last : int64
    vals1 : array(int64,ndim=1)
    vals2 : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Sort._match_issorted__3J_3IJJZ(*args):
      return mosek_fusion_Sort._issorted__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3IJJZ(*args):
      return mosek_fusion_Sort._issorted_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3JJJZ(*args):
      return mosek_fusion_Sort._issorted__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3JJJZ(*args):
      return mosek_fusion_Sort._issorted_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3I_3IJJZ(*args):
      return mosek_fusion_Sort._issorted__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3I_3IJJZ(*args):
      return mosek_fusion_Sort._issorted_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3J_3JJJZ(*args):
      return mosek_fusion_Sort._issorted__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3J_3JJJZ(*args):
      return mosek_fusion_Sort._issorted_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list issorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argTransposeSort(*args):
    '''
    Syntax
    ------

      mosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    m : int32
    n : int32
    p : int32
    perm : array(int64,ndim=1)
    ptrb : array(int64,ndim=1)
    val : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Sort._match_argTransposeSort__3J_3JIII_3J(*args):
      return mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(*args)
    elif mosek_fusion_Sort._match_alt_argTransposeSort__3J_3JIII_3J(*args):
      return mosek_fusion_Sort._argTransposeSort_alt__3J_3JIII_3J(*args)
    else:
      raise ValueError('Invalid argument list argTransposeSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))')
  @staticmethod
  def argbucketsort(*args):
    '''
    Syntax
    ------

      mosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)
      mosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)

    Description
    -----------

    

    Parameters
    ----------

    first : int64
    idx : array(int64,ndim=1)
    last : int64
    maxv : int64
    minv : int64
    vals : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Sort._match_argbucketsort__3J_3IJJII(*args):
      return mosek_fusion_Sort._argbucketsort__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3IJJII(*args):
      return mosek_fusion_Sort._argbucketsort_alt__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_argbucketsort__3J_3JJJJJ(*args):
      return mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3JJJJJ(*args):
      return mosek_fusion_Sort._argbucketsort_alt__3J_3JJJJJ(*args)
    else:
      raise ValueError('Invalid argument list argbucketsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)')
  @staticmethod
  def getminmax(*args):
    '''
    Syntax
    ------

      mosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))
      mosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    first : int64
    idx : array(int64,ndim=1)
    last : int64
    res : array(int64,ndim=1)
    vals1 : array(int64,ndim=1)
    vals2 : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Sort._match_getminmax__3J_3I_3IJJ_3I(*args):
      return mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3I_3IJJ_3I(*args):
      return mosek_fusion_Sort._getminmax_alt__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_getminmax__3J_3J_3JJJ_3J(*args):
      return mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3J_3JJJ_3J(*args):
      return mosek_fusion_Sort._getminmax_alt__3J_3J_3JJJ_3J(*args)
    else:
      raise ValueError('Invalid argument list getminmax('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))')
  @staticmethod
  def argsort(*args):
    '''
    Syntax
    ------

      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)
      mosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)

    Description
    -----------

    

    Parameters
    ----------

    check : bool
    first : int64
    idx : array(int64,ndim=1)
    last : int64
    vals1 : array(int64,ndim=1)
    vals2 : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Sort._match_argsort__3J_3J(*args):
      return mosek_fusion_Sort._argsort__3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I(*args):
      return mosek_fusion_Sort._argsort__3J_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3I(*args):
      return mosek_fusion_Sort._argsort__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3I(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3J(*args):
      return mosek_fusion_Sort._argsort__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3J(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJ(*args):
      return mosek_fusion_Sort._argsort__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJ(*args):
      return mosek_fusion_Sort._argsort__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJZ(*args):
      return mosek_fusion_Sort._argsort__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJZ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJ(*args):
      return mosek_fusion_Sort._argsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJ(*args):
      return mosek_fusion_Sort._argsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJZ(*args):
      return mosek_fusion_Sort._argsort__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJZ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJZ(*args):
      return mosek_fusion_Sort._argsort__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJZ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJZ(*args):
      return mosek_fusion_Sort._argsort__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJZ(*args):
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list argsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  def __repr__(self): return 'mosek.fusion.Sort'
  @staticmethod
  def _match_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_I__(_a_2) and __arg_match_I__(_a_3) and __arg_match_I__(_a_4) and __arg_match__3J__(_a_5))
  @staticmethod
  def _match_alt_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_I__(_a_3) and __arg_alt_match_I__(_a_4) and __arg_alt_match__3J__(_a_5))
  @staticmethod
  def _argTransposeSort_alt__3J_3JIII_3J(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argTransposeSort__3J_3JIII_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   fragments._c_closure_103(_a_2,_a_3,_a_4,_a_0,_a_1,_a_5) 
  @staticmethod
  def _match_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1))
  @staticmethod
  def _match_alt_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1))
  @staticmethod
  def _argsort_alt__3J_3J(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_Sort._argsort__3J_3J(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3J(_a_0,_a_1):
   mosek.fusion.Sort._argsort__3J_3JJJZ(_a_0,_a_1,0,int((_a_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _argsort_alt__3J_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Sort._argsort__3J_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3I(_a_0,_a_1):
   mosek.fusion.Sort._argsort__3J_3IJJZ(_a_0,_a_1,0,int((_a_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2))
  @staticmethod
  def _match_alt_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2))
  @staticmethod
  def _argsort_alt__3J_3J_3J(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_Sort._argsort__3J_3J_3J(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3J_3J(_a_0,_a_1,_a_2):
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_a_0,_a_1,_a_2,0,int((_a_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _argsort_alt__3J_3I_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Sort._argsort__3J_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3I_3I(_a_0,_a_1,_a_2):
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_a_0,_a_1,_a_2,0,int((_a_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3))
  @staticmethod
  def _match_alt_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3))
  @staticmethod
  def _argsort_alt__3J_3JJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _1_res = mosek_fusion_Sort._argsort__3J_3JJJ(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3JJJ(_a_0,_a_1,_a_2,_a_3):
   mosek.fusion.Sort._argsort__3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,False)
  @staticmethod
  def _match_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3))
  @staticmethod
  def _match_alt_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3))
  @staticmethod
  def _argsort_alt__3J_3IJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _1_res = mosek_fusion_Sort._argsort__3J_3IJJ(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3IJJ(_a_0,_a_1,_a_2,_a_3):
   mosek.fusion.Sort._argsort__3J_3IJJZ(_a_0,_a_1,_a_2,_a_3,False)
  @staticmethod
  def _match_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _1_res = mosek_fusion_Sort._argsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4):
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,False)
  @staticmethod
  def _match_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _1_res = mosek_fusion_Sort._argsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4):
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,False)
  @staticmethod
  def _match_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_Z__(_a_4))
  @staticmethod
  def _match_alt_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_Z__(_a_4))
  @staticmethod
  def _argsort_alt__3J_3JJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _a_4=_t__a_4
   _1_res = mosek_fusion_Sort._argsort__3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4):
   if ((not _a_4) or ((_a_3 - _a_2) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_a_0,_a_1,_a_2,_a_3)
   elif (not mosek.fusion.Sort._issorted__3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4)):
    _a_5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _a_6=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_a_0,_a_1,None,_a_2,_a_3,_a_5)
    if ((_a_5[1] - _a_5[0]) < (_a_6 * (_a_3 - _a_2))):
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_a_0,_a_1,_a_2,_a_3,_a_5[0],_a_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_a_0,_a_1,_a_2,_a_3)
  @staticmethod
  def _match_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_Z__(_a_4))
  @staticmethod
  def _match_alt_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_Z__(_a_4))
  @staticmethod
  def _argsort_alt__3J_3IJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _a_4=_t__a_4
   _1_res = mosek_fusion_Sort._argsort__3J_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4):
   if ((not _a_4) or ((_a_3 - _a_2) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_a_0,_a_1,_a_2,_a_3)
   elif (not mosek.fusion.Sort._issorted__3J_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4)):
    _a_5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _a_6=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_a_0,_a_1,None,_a_2,_a_3,_a_5)
    if ((_a_5[1] - _a_5[0]) < (_a_6 * (_a_3 - _a_2))):
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_a_0,_a_1,_a_2,_a_3,_a_5[0],_a_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_a_0,_a_1,_a_2,_a_3)
  @staticmethod
  def _match_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match_Z__(_a_5))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match_Z__(_a_5))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=_t__a_5
   _1_res = mosek_fusion_Sort._argsort__3J_3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   if ((not _a_5) or ((_a_4 - _a_3) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
   elif (not mosek.fusion.Sort._issorted__3J_3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)):
    _a_6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _a_7=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_6)
    if (((_a_6[1] - _a_6[0]) < (_a_7 * (_a_4 - _a_3))) and ((_a_6[3] - _a_6[2]) < (_a_7 * (_a_4 - _a_3)))):
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_a_0,_a_2,_a_3,_a_4,_a_6[2],_a_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_a_0,_a_1,_a_3,_a_4,_a_6[0],_a_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
  @staticmethod
  def _match_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match_Z__(_a_5))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match_Z__(_a_5))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=_t__a_5
   _1_res = mosek_fusion_Sort._argsort__3J_3I_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argsort__3J_3I_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   if ((not _a_5) or ((_a_4 - _a_3) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
   elif (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)):
    _a_6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _a_7=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_a_0,_a_1,_a_2,_a_3,_a_4,_a_6)
    if (((_a_6[1] - _a_6[0]) < (_a_7 * (_a_4 - _a_3))) and ((_a_6[3] - _a_6[2]) < (_a_7 * (_a_4 - _a_3)))):
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_a_0,_a_2,_a_3,_a_4,_a_6[2],_a_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_a_0,_a_1,_a_3,_a_4,_a_6[0],_a_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
  @staticmethod
  def _match_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match_J__(_a_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match_J__(_a_5))
  @staticmethod
  def _argbucketsort_alt__3J_3JJJJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=numpy.int64(_t__a_5)
   _1_res = mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argbucketsort__3J_3JJJJJ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3JJJ(_a_0,_a_2,_a_3,_a_1,_a_4,_a_5)
  @staticmethod
  def _match_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_I__(_a_4) and __arg_match_I__(_a_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_I__(_a_4) and __arg_alt_match_I__(_a_5))
  @staticmethod
  def _argbucketsort_alt__3J_3IJJII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.int32(_t__a_5)
   _1_res = mosek_fusion_Sort._argbucketsort__3J_3IJJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argbucketsort__3J_3IJJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3III(_a_0,_a_2,_a_3,_a_1,_a_4,_a_5)
  @staticmethod
  def _match_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match__3J__(_a_5))
  @staticmethod
  def _match_alt_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match__3J__(_a_5))
  @staticmethod
  def _getminmax_alt__3J_3J_3JJJ_3J(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _getminmax__3J_3J_3JJJ_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   fragments._c_closure_104(_a_3,_a_0,_a_4,_a_5,_a_1,_a_2) 
  @staticmethod
  def _match_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match__3I__(_a_5))
  @staticmethod
  def _match_alt_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match__3I__(_a_5))
  @staticmethod
  def _getminmax_alt__3J_3I_3IJJ_3I(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _getminmax__3J_3I_3IJJ_3I(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   fragments._c_closure_105(_a_3,_a_0,_a_4,_a_5,_a_1,_a_2) 
  @staticmethod
  def _match_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_Z__(_a_4))
  @staticmethod
  def _match_alt_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_Z__(_a_4))
  @staticmethod
  def _issorted_alt__3J_3JJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _a_4=_t__a_4
   _1_res = mosek_fusion_Sort._issorted__3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _issorted__3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4):
   for _a_5 in range(_a_2,(_a_3 - 1)):
    if (_a_1[_a_0[_a_5]] > _a_1[_a_0[(_a_5 + 1)]]):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_Z__(_a_4))
  @staticmethod
  def _match_alt_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_Z__(_a_4))
  @staticmethod
  def _issorted_alt__3J_3IJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int64(_t__a_2)
   _a_3=numpy.int64(_t__a_3)
   _a_4=_t__a_4
   _1_res = mosek_fusion_Sort._issorted__3J_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _issorted__3J_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4):
   for _a_5 in range(_a_2,(_a_3 - 1)):
    if (_a_1[_a_0[_a_5]] > _a_1[_a_0[(_a_5 + 1)]]):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match_Z__(_a_5))
  @staticmethod
  def _match_alt_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match_Z__(_a_5))
  @staticmethod
  def _issorted_alt__3J_3J_3JJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=_t__a_5
   _1_res = mosek_fusion_Sort._issorted__3J_3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _issorted__3J_3J_3JJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   for _a_6 in range(_a_3,(_a_4 - 1)):
    if ((_a_1[_a_0[_a_6]] > _a_1[_a_0[(_a_6 + 1)]]) or ((_a_1[_a_0[(_a_6 + 1)]]==_a_1[_a_0[_a_6]]) and (_a_2[_a_0[_a_6]] > _a_2[_a_0[(_a_6 + 1)]]))):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4) and __arg_match_Z__(_a_5))
  @staticmethod
  def _match_alt_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4) and __arg_alt_match_Z__(_a_5))
  @staticmethod
  def _issorted_alt__3J_3I_3IJJZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _a_5=_t__a_5
   _1_res = mosek_fusion_Sort._issorted__3J_3I_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _issorted__3J_3I_3IJJZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   for _a_6 in range(_a_3,(_a_4 - 1)):
    if ((_a_1[_a_0[_a_6]] > _a_1[_a_0[(_a_6 + 1)]]) or ((_a_1[_a_0[_a_6]]==_a_1[_a_0[(_a_6 + 1)]]) and (_a_2[_a_0[_a_6]] > _a_2[_a_0[(_a_6 + 1)]]))):
     return (False)
   return (True)
 return Sort
mosek_fusion_Sort=__mk_mosek_fusion_Sort()
del __mk_mosek_fusion_Sort
#BEFORE CLASS
def __mk_mosek_fusion_IndexCounter():
 class IndexCounter(object):
  __slots__ = ['_IndexCounter__start','_IndexCounter__dims','_IndexCounter__strides','_IndexCounter__st','_IndexCounter__ii','_IndexCounter__n']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args):
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):
      self._ctor_alt_init__3I(*args)
    elif self.__match_ctor_J_3I_3I(*args):
      self._ctor_init_J_3I_3I(*args)
    elif self.__match_alt_ctor_J_3I_3I(*args):
      self._ctor_alt_init_J_3I_3I(*args)
    elif self.__match_ctor_J_3I_3J(*args):
      self._ctor_init_J_3I_3J(*args)
    elif self.__match_alt_ctor_J_3I_3J(*args):
      self._ctor_alt_init_J_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexCounter.ctor(array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int64,ndim=1))')
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.IndexCounter.get()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_IndexCounter._match_get_(*args):
      return self._get_(*args)
    elif mosek_fusion_IndexCounter._match_alt_get_(*args):
      return self._get_alt_(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.get()')
  def getIndex(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.IndexCounter.getIndex()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_IndexCounter._match_getIndex_(*args):
      return self._getIndex_(*args)
    elif mosek_fusion_IndexCounter._match_alt_getIndex_(*args):
      return self._getIndex_alt_(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.getIndex()')
  def next(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.IndexCounter.next()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_IndexCounter._match_next_(*args):
      return self._next_(*args)
    elif mosek_fusion_IndexCounter._match_alt_next_(*args):
      return self._next_alt_(*args)
    else:
      raise ValueError('Invalid argument list next('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.next()')
  def reset(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.IndexCounter.reset()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_IndexCounter._match_reset_(*args):
      return self._reset_(*args)
    elif mosek_fusion_IndexCounter._match_alt_reset_(*args):
      return self._reset_alt_(*args)
    else:
      raise ValueError('Invalid argument list reset('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.reset()')
  def inc(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.IndexCounter.inc()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_IndexCounter._match_inc_(*args):
      return self._inc_(*args)
    elif mosek_fusion_IndexCounter._match_alt_inc_(*args):
      return self._inc_alt_(*args)
    else:
      raise ValueError('Invalid argument list inc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.inc()')
  def atEnd(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.IndexCounter.atEnd()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_IndexCounter._match_atEnd_(*args):
      return self._atEnd_(*args)
    elif mosek_fusion_IndexCounter._match_alt_atEnd_(*args):
      return self._atEnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list atEnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.atEnd()')
  def __repr__(self): return 'mosek.fusion.IndexCounter'
  @staticmethod
  def _ctor__3I(shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   self.__n = int((shape).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   self.__start = 0
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = numpy.array([shape[_a_0] for _a_0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_J_3I_3I(start_,dims_,shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3I(start_,dims_,shape)
    return o
  @staticmethod
  def __match_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3I__(shape))
  def _ctor_alt_init_J_3I_3I(self,start_,dims_,shape):
    self._ctor_init_J_3I_3I(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_J_3I_3I(self,start_,dims_,shape):
   _a_0=int((shape).shape[0])
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_106(self.__n,self.__st,start_) 
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _ctor_J_3I_3J(start_,dims_,strides_):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3J(start_,dims_,strides_)
    return o
  @staticmethod
  def __match_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_J_3I_3J(self,start_,dims_,strides_):
    self._ctor_init_J_3I_3J(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_J_3I_3J(self,start_,dims_,strides_):
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_107(self.__n,self.__st,start_) 
   self.__strides = strides_
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _match_atEnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_atEnd_(*args):
    if len(args) != 0: return False
    return True
  def _atEnd_alt_(self,):
    return self._atEnd_()
  def _atEnd_(self,):
   return ((self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)]))
  @staticmethod
  def _match_getIndex_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getIndex_(*args):
    if len(args) != 0: return False
    return True
  def _getIndex_alt_(self,):
    return self._getIndex_()
  def _getIndex_(self,):
   return (self.__ii)
  @staticmethod
  def _match_next_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_next_(*args):
    if len(args) != 0: return False
    return True
  def _next_alt_(self,):
    return self._next_()
  def _next_(self,):
   _a_0=self._get_()
   self._inc_()
   return numpy.int64(_a_0)
  @staticmethod
  def _match_get_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_(*args):
    if len(args) != 0: return False
    return True
  def _get_alt_(self,):
    return self._get_()
  def _get_(self,):
   return numpy.int64(self.__st[0])
  @staticmethod
  def _match_inc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inc_(*args):
    if len(args) != 0: return False
    return True
  def _inc_alt_(self,):
    return self._inc_()
  def _inc_(self,):
   fragments._c_closure_108(self.__dims,self.__ii,self.__n,self.__st,self.__strides) 
  @staticmethod
  def _match_reset_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_reset_(*args):
    if len(args) != 0: return False
    return True
  def _reset_alt_(self,):
    return self._reset_()
  def _reset_(self,):
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_109(self.__n,self.__st,self.__start) 
 return IndexCounter
mosek_fusion_IndexCounter=__mk_mosek_fusion_IndexCounter()
del __mk_mosek_fusion_IndexCounter
#BEFORE CLASS
def __mk_mosek_fusion_CommonTools():
 class CommonTools(object):
  @staticmethod
  def binarySearch(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.binarySearch(array(int64,ndim=1),int64)
      mosek.fusion.CommonTools.binarySearch(array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    target : int32
    values : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearch__3JJ(*args):
      return mosek_fusion_CommonTools._binarySearch__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3JJ(*args):
      return mosek_fusion_CommonTools._binarySearch_alt__3JJ(*args)
    elif mosek_fusion_CommonTools._match_binarySearch__3II(*args):
      return mosek_fusion_CommonTools._binarySearch__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3II(*args):
      return mosek_fusion_CommonTools._binarySearch_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list binarySearch('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearch(array(int64,ndim=1),int64)\n\tmosek.fusion.CommonTools.binarySearch(array(int32,ndim=1),int32)')
  @staticmethod
  def argQsort(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)
      mosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)

    Description
    -----------

    

    Parameters
    ----------

    first : int64
    idx : array(int64,ndim=1)
    last : int64
    vals1 : array(int64,ndim=1)
    vals2 : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_argQsort__3J_3I_3IJJ(*args):
      return mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3I_3IJJ(*args):
      return mosek_fusion_CommonTools._argQsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_argQsort__3J_3J_3JJJ(*args):
      return mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3J_3JJJ(*args):
      return mosek_fusion_CommonTools._argQsort_alt__3J_3J_3JJJ(*args)
    else:
      raise ValueError('Invalid argument list argQsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)')
  @staticmethod
  def argMSort(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    idx : array(int32,ndim=1)
    vals : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_argMSort__3I_3I(*args):
      return mosek_fusion_CommonTools._argMSort__3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_argMSort__3I_3I(*args):
      return mosek_fusion_CommonTools._argMSort_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list argMSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def binarySearchL(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.binarySearchL(array(int64,ndim=1),int64)

    Description
    -----------

    

    Parameters
    ----------

    target : int64
    values : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchL__3JJ(*args):
      return mosek_fusion_CommonTools._binarySearchL__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchL__3JJ(*args):
      return mosek_fusion_CommonTools._binarySearchL_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchL('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchL(array(int64,ndim=1),int64)')
  @staticmethod
  def ndIncr(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    first : array(int32,ndim=1)
    last : array(int32,ndim=1)
    ndidx : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_ndIncr__3I_3I_3I(*args):
      return mosek_fusion_CommonTools._ndIncr__3I_3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_ndIncr__3I_3I_3I(*args):
      return mosek_fusion_CommonTools._ndIncr_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list ndIncr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def transposeTriplets(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)
      mosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)

    Description
    -----------

    Matrix transpose similar to tripletSort.

    Parameters
    ----------

    dimi : int32
    dimj : int32
    nelm : int64
    subi : array(int32,ndim=1)
    subj : array(int32,ndim=1)
    tsubi_ : array(array(int64,ndim=1),ndim=1)
    tsubj_ : array(array(int64,ndim=1),ndim=1)
    tval_ : array(array(double,ndim=1),ndim=1)
    val : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list transposeTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def tripletSort(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)

    Description
    -----------

    Sort with two indexes by transposing data twice.

    Parameters
    ----------

    dimi : int32
    dimj : int32
    nelm : int64
    subi : array(int32,ndim=1)
    subj : array(int32,ndim=1)
    tsubi_ : array(array(int32,ndim=1),ndim=1)
    tsubj_ : array(array(int32,ndim=1),ndim=1)
    tval_ : array(array(double,ndim=1),ndim=1)
    val : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
      return mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
      return mosek_fusion_CommonTools._tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list tripletSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def binarySearchR(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.binarySearchR(array(int64,ndim=1),int64)

    Description
    -----------

    

    Parameters
    ----------

    target : int64
    values : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchR__3JJ(*args):
      return mosek_fusion_CommonTools._binarySearchR__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchR__3JJ(*args):
      return mosek_fusion_CommonTools._binarySearchR_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchR('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchR(array(int64,ndim=1),int64)')
  @staticmethod
  def resize(*args):
    '''
    Syntax
    ------

      mosek.fusion.CommonTools.resize(array(double,ndim=1),int32)
      mosek.fusion.CommonTools.resize(array(int32,ndim=1),int32)
      mosek.fusion.CommonTools.resize(array(int64,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    newsize : int32
    values : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_CommonTools._match_resize__3DI(*args):
      return mosek_fusion_CommonTools._resize__3DI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3DI(*args):
      return mosek_fusion_CommonTools._resize_alt__3DI(*args)
    elif mosek_fusion_CommonTools._match_resize__3II(*args):
      return mosek_fusion_CommonTools._resize__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3II(*args):
      return mosek_fusion_CommonTools._resize_alt__3II(*args)
    elif mosek_fusion_CommonTools._match_resize__3JI(*args):
      return mosek_fusion_CommonTools._resize__3JI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3JI(*args):
      return mosek_fusion_CommonTools._resize_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.resize(array(double,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int32,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int64,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.CommonTools'
  @staticmethod
  def _match_resize__3JI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_resize__3JI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _resize_alt__3JI(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_CommonTools._resize__3JI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _resize__3JI(_a_0,_a_1):
   if (_a_1==int((_a_0).shape[0])):
    return (_a_0)
   else:
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int64))
    if (_a_1 > int((_a_0).shape[0])):
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_0,0,_a_2,0,int((_a_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_0,0,_a_2,0,_a_1)
    return (_a_2)
  @staticmethod
  def _match_resize__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_resize__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _resize_alt__3II(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_CommonTools._resize__3II(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _resize__3II(_a_0,_a_1):
   if (_a_1==int((_a_0).shape[0])):
    return (_a_0)
   else:
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    if (_a_1 > int((_a_0).shape[0])):
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_0,0,_a_2,0,int((_a_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_0,0,_a_2,0,_a_1)
    return (_a_2)
  @staticmethod
  def _match_resize__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_resize__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _resize_alt__3DI(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_CommonTools._resize__3DI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _resize__3DI(_a_0,_a_1):
   if (_a_1==int((_a_0).shape[0])):
    return (_a_0)
   else:
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.float64))
    if (_a_1 > int((_a_0).shape[0])):
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_0,0,_a_2,0,int((_a_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_0,0,_a_2,0,_a_1)
    return (_a_2)
  @staticmethod
  def _match_binarySearch__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_binarySearch__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _binarySearch_alt__3II(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_CommonTools._binarySearch__3II(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _binarySearch__3II(_a_0,_a_1):
   _a_2=0
   _a_3=int((_a_0).shape[0])
   if (_a_0[_a_2]==_a_1):
    return numpy.int32(_a_2)
   elif (_a_0[(_a_3 - 1)]==_a_1):
    return numpy.int32((_a_3 - 1))
   while (_a_2 < (_a_3 - 1)):
    _a_4=((_a_3 - _a_2) // 2)
    if (_a_1 < _a_0[_a_4]):
     _a_2 = (_a_4 + 1)
    elif (_a_1 > _a_0[_a_4]):
     _a_3 = _a_4
    else:
     return numpy.int32(_a_4)
   return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match_J__(_a_1))
  @staticmethod
  def _match_alt_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match_J__(_a_1))
  @staticmethod
  def _binarySearch_alt__3JJ(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int64(_t__a_1)
   _1_res = mosek_fusion_CommonTools._binarySearch__3JJ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _binarySearch__3JJ(_a_0,_a_1):
   _a_2=mosek.fusion.CommonTools._binarySearchL__3JJ(_a_0,_a_1)
   if ((_a_2 < int((_a_0).shape[0])) and (_a_0[_a_2]==_a_1)):
    return numpy.int32(_a_2)
   else:
    return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match_J__(_a_1))
  @staticmethod
  def _match_alt_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match_J__(_a_1))
  @staticmethod
  def _binarySearchR_alt__3JJ(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int64(_t__a_1)
   _1_res = mosek_fusion_CommonTools._binarySearchR__3JJ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _binarySearchR__3JJ(_a_0,_a_1):
   _a_2=0
   _a_3=int((_a_0).shape[0])
   if (_a_0[_a_2] > _a_1):
    return numpy.int32(_a_2)
   _a_2,_a_3 = fragments._c_closure_110(_a_2,_a_3,_a_1,_a_0)
   _a_2 = numpy.int32(_a_2) # postprocess
   _a_3 = numpy.int32(_a_3) # postprocess
   return numpy.int32(_a_3)
  @staticmethod
  def _match_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match_J__(_a_1))
  @staticmethod
  def _match_alt_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match_J__(_a_1))
  @staticmethod
  def _binarySearchL_alt__3JJ(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int64(_t__a_1)
   _1_res = mosek_fusion_CommonTools._binarySearchL__3JJ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _binarySearchL__3JJ(_a_0,_a_1):
   _a_2=0
   _a_3=int((_a_0).shape[0])
   if (_a_1 <= _a_0[_a_2]):
    return numpy.int32(_a_2)
   _a_2,_a_3 = fragments._c_closure_111(_a_2,_a_3,_a_1,_a_0)
   _a_2 = numpy.int32(_a_2) # postprocess
   _a_3 = numpy.int32(_a_3) # postprocess
   return numpy.int32(_a_3)
  @staticmethod
  def _match_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _ndIncr_alt__3I_3I_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_CommonTools._ndIncr__3I_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _ndIncr__3I_3I_3I(_a_0,_a_1,_a_2):
   fragments._c_closure_112(_a_1,_a_2,_a_0) 
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2) and __arg_match__3_3J__(_a_3) and __arg_match__3_3J__(_a_4) and __arg_match__3_3D__(_a_5) and __arg_match_J__(_a_6) and __arg_match_I__(_a_7) and __arg_match_I__(_a_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match__3_3J__(_a_3) and __arg_alt_match__3_3J__(_a_4) and __arg_alt_match__3_3D__(_a_5) and __arg_alt_match_J__(_a_6) and __arg_alt_match_I__(_a_7) and __arg_alt_match_I__(_a_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=_monty.makeJaggedArray(_t__a_3,(1,1),numpy.dtype(numpy.int64))
   _a_4=_monty.makeJaggedArray(_t__a_4,(1,1),numpy.dtype(numpy.int64))
   _a_5=_monty.makeJaggedArray(_t__a_5,(1,1),numpy.dtype(numpy.float64))
   _a_6=numpy.int64(_t__a_6)
   _a_7=numpy.int32(_t__a_7)
   _a_8=numpy.int32(_t__a_8)
   _1_res = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8):
   _a_9=numpy.zeros(((_a_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _a_10=numpy.zeros(((_a_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_113(_a_10,_a_6,_a_9,_a_0,_a_1) 
   fragments._c_closure_114(_a_7,_a_9) 
   fragments._c_closure_115(_a_10,_a_8) 
   _a_11=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int64))
   _a_12=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int64))
   _a_13=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_116(_a_10,_a_7,_a_9,_a_1,_a_11,_a_12,_a_13,_a_2) 
   _a_3[0] = _a_12
   _a_4[0] = _a_11
   _a_5[0] = _a_13
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2) and __arg_match__3_3I__(_a_3) and __arg_match__3_3I__(_a_4) and __arg_match__3_3D__(_a_5) and __arg_match_J__(_a_6) and __arg_match_I__(_a_7) and __arg_match_I__(_a_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match__3_3I__(_a_3) and __arg_alt_match__3_3I__(_a_4) and __arg_alt_match__3_3D__(_a_5) and __arg_alt_match_J__(_a_6) and __arg_alt_match_I__(_a_7) and __arg_alt_match_I__(_a_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=_monty.makeJaggedArray(_t__a_3,(1,1),numpy.dtype(numpy.int32))
   _a_4=_monty.makeJaggedArray(_t__a_4,(1,1),numpy.dtype(numpy.int32))
   _a_5=_monty.makeJaggedArray(_t__a_5,(1,1),numpy.dtype(numpy.float64))
   _a_6=numpy.int64(_t__a_6)
   _a_7=numpy.int32(_t__a_7)
   _a_8=numpy.int32(_t__a_8)
   _1_res = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8):
   _a_9=numpy.zeros(((_a_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _a_10=numpy.zeros(((_a_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_117(_a_10,_a_6,_a_9,_a_0,_a_1) 
   fragments._c_closure_118(_a_7,_a_9) 
   fragments._c_closure_119(_a_10,_a_8) 
   _a_11=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
   _a_12=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
   _a_13=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_120(_a_10,_a_7,_a_9,_a_1,_a_11,_a_12,_a_13,_a_2) 
   _a_3[0] = _a_12
   _a_4[0] = _a_11
   _a_5[0] = _a_13
  @staticmethod
  def _match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2) and __arg_match__3_3I__(_a_3) and __arg_match__3_3I__(_a_4) and __arg_match__3_3D__(_a_5) and __arg_match_J__(_a_6) and __arg_match_I__(_a_7) and __arg_match_I__(_a_8))
  @staticmethod
  def _match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2) and __arg_alt_match__3_3I__(_a_3) and __arg_alt_match__3_3I__(_a_4) and __arg_alt_match__3_3D__(_a_5) and __arg_alt_match_J__(_a_6) and __arg_alt_match_I__(_a_7) and __arg_alt_match_I__(_a_8))
  @staticmethod
  def _tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=_monty.makeJaggedArray(_t__a_3,(1,1),numpy.dtype(numpy.int32))
   _a_4=_monty.makeJaggedArray(_t__a_4,(1,1),numpy.dtype(numpy.int32))
   _a_5=_monty.makeJaggedArray(_t__a_5,(1,1),numpy.dtype(numpy.float64))
   _a_6=numpy.int64(_t__a_6)
   _a_7=numpy.int32(_t__a_7)
   _a_8=numpy.int32(_t__a_8)
   _1_res = mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8):
   _a_9=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
   _a_10=numpy.zeros(((_a_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_121(_a_10,_a_6,_a_1) 
   fragments._c_closure_122(_a_10,_a_8) 
   fragments._c_closure_123(_a_9,_a_10,_a_6,_a_1) 
   _a_11=numpy.zeros(((_a_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _a_12=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_124(_a_6,_a_11,_a_0) 
   fragments._c_closure_125(_a_7,_a_11) 
   fragments._c_closure_126(_a_9,_a_10,_a_8,_a_12,_a_11,_a_0) 
   _a_13=1
   _a_13 = fragments._c_closure_127(_a_6,_a_13,_a_12,_a_0,_a_1)
   _a_13 = numpy.int32(_a_13) # postprocess
   _a_14=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
   _a_15=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
   _a_16=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.float64))
   _a_17=_a_12[0]
   _a_14[0] = _a_0[_a_17]
   _a_15[0] = _a_1[_a_17]
   _a_16[0] = _a_2[_a_17]
   _a_18=1
   _a_18 = fragments._c_closure_128(_a_18,_a_6,_a_12,_a_0,_a_1,_a_14,_a_15,_a_16,_a_2)
   _a_18 = numpy.int32(_a_18) # postprocess
   _a_3[0] = _a_14
   _a_4[0] = _a_15
   _a_5[0] = _a_16
  @staticmethod
  def _match_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _argMSort_alt__3I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_CommonTools._argMSort__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argMSort__3I_3I(_a_0,_a_1):
   _a_2=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _a_3=False
   _a_4=1
   while (_a_4 < int((_a_0).shape[0])):
    _a_3 = (not _a_3)
    for _a_5 in range(0,int((_a_0).shape[0]),(_a_4 * 2)):
     if _a_3:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_a_0,_a_2,_a_1,_a_5,(_a_5 + _a_4),(_a_5 + (2 * _a_4)))
     else:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_a_2,_a_0,_a_1,_a_5,(_a_5 + _a_4),(_a_5 + (2 * _a_4)))
    _a_4 *= 2
   if _a_3:
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_2,0,_a_0,0,int((_a_0).shape[0]))
  @staticmethod
  def __mergeInto_alt__3I_3I_3IIII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.int32(_t__a_5)
   _1_res = mosek_fusion_CommonTools.__mergeInto__3I_3I_3IIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __mergeInto__3I_3I_3IIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   _a_6=(int((_a_0).shape[0]) if ((_a_5 > int((_a_0).shape[0])) ) else _a_5)
   _a_7=(_a_6 if ((_a_4 > _a_6) ) else _a_4)
   if (_a_7==_a_6):
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_0,_a_3,_a_1,_a_3,(_a_7 - _a_3))
   else:
    fragments._c_closure_129(_a_3,_a_7,_a_6,_a_0,_a_1,_a_2) 
  @staticmethod
  def _match_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4))
  @staticmethod
  def _match_alt_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4))
  @staticmethod
  def _argQsort_alt__3J_3J_3JJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _1_res = mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argQsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4):
   if (_a_2 is None):
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_a_0,_a_1,_a_3,_a_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
  @staticmethod
  def _match_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match__3J__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match_J__(_a_3) and __arg_match_J__(_a_4))
  @staticmethod
  def _match_alt_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match_J__(_a_3) and __arg_alt_match_J__(_a_4))
  @staticmethod
  def _argQsort_alt__3J_3I_3IJJ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int64(_t__a_3)
   _a_4=numpy.int64(_t__a_4)
   _1_res = mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _argQsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4):
   if (_a_2 is None):
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_a_0,_a_1,_a_3,_a_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_a_0,_a_1,_a_2,_a_3,_a_4)
 return CommonTools
mosek_fusion_CommonTools=__mk_mosek_fusion_CommonTools()
del __mk_mosek_fusion_CommonTools
#BEFORE CLASS
def __mk_mosek_fusion_SolutionStruct():
 class SolutionStruct(object):
  __slots__ = ['accy','accx','accptr','yx','sux','slx','bars','barx','y','suc','slc','xx','xc','dobj','pobj','probstatus','dstatus','pstatus','sol_numbarvar','sol_numaccelm','sol_numacc','sol_numvar','sol_numcon']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
      self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_ctor_IIIII(*args):
      self._ctor_init_IIIII(*args)
    elif self.__match_alt_ctor_IIIII(*args):
      self._ctor_alt_init_IIIII(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionStruct.ctor(mosek.fusion.SolutionStruct)\n\tmosek.fusion.SolutionStruct.ctor(int32,int32,int32,int32,int32)')
  def clone(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SolutionStruct.clone()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SolutionStruct._match_clone_(*args):
      return self._clone_(*args)
    elif mosek_fusion_SolutionStruct._match_alt_clone_(*args):
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.clone()')
  def resize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SolutionStruct.resize(int32,int32,int32,int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    numacc : int32
    numaccelm : int32
    numbarvar : int32
    numcon : int32
    numvar : int32
    '''
    if False: pass
    elif mosek_fusion_SolutionStruct._match_resize_IIIII(*args):
      return self._resize_IIIII(*args)
    elif mosek_fusion_SolutionStruct._match_alt_resize_IIIII(*args):
      return self._resize_alt_IIIII(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.resize(int32,int32,int32,int32,int32)')
  def isPrimalAcceptable(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)

    Description
    -----------

    

    Parameters
    ----------

    acceptable_sol : mosek.fusion.AccSolutionStatus
    '''
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
      return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
      return self._isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isPrimalAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)')
  def isDualAcceptable(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)

    Description
    -----------

    

    Parameters
    ----------

    acceptable_sol : mosek.fusion.AccSolutionStatus
    '''
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
      return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
      return self._isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isDualAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)')
  def __repr__(self): return 'mosek.fusion.SolutionStruct'
  @staticmethod
  def _ctor_IIIII(numvar,numcon,numbarvar,numacc,numaccelm):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_IIIII(numvar,numcon,numbarvar,numacc,numaccelm)
    return o
  @staticmethod
  def __match_ctor_IIIII(*args):
    if len(args) != 5: return False
    numvar,numcon,numbarvar,numacc,numaccelm, = args
    return (__arg_match_I__(numvar) and __arg_match_I__(numcon) and __arg_match_I__(numbarvar) and __arg_match_I__(numacc) and __arg_match_I__(numaccelm))
  @staticmethod
  def __match_alt_ctor_IIIII(*args):
    if len(args) != 5: return False
    numvar,numcon,numbarvar,numacc,numaccelm, = args
    return (__arg_alt_match_I__(numvar) and __arg_alt_match_I__(numcon) and __arg_alt_match_I__(numbarvar) and __arg_alt_match_I__(numacc) and __arg_alt_match_I__(numaccelm))
  def _ctor_alt_init_IIIII(self,numvar,numcon,numbarvar,numacc,numaccelm):
    self._ctor_init_IIIII(numpy.int32(numvar),numpy.int32(numcon),numpy.int32(numbarvar),numpy.int32(numacc),numpy.int32(numaccelm))
  def _ctor_init_IIIII(self,numvar,numcon,numbarvar,numacc,numaccelm):
   self.pobj = 0.0
   self.dobj = 0.0
   self.pstatus = mosek.fusion.SolutionStatus.Unknown
   self.dstatus = mosek.fusion.SolutionStatus.Unknown
   self.probstatus = mosek.fusion.ProblemStatus.Unknown
   self.sol_numvar = numvar
   self.sol_numcon = numcon
   self.sol_numbarvar = numbarvar
   self.sol_numacc = numacc
   self.sol_numaccelm = numaccelm
   self.slx = None
   self.sux = None
   self.xx = None
   self.yx = None
   self.slc = None
   self.suc = None
   self.y = None
   self.xc = None
   self.barx = None
   self.bars = None
   self.accx = None
   self.accy = None
   self.accptr = None
   if (numvar > 0):
    self.slx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.sux = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.xx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.yx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
   if (numbarvar > 0):
    self.barx = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
    self.bars = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
   if (numcon > 0):
    self.slc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.suc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.y = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.xc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
   if (numacc > 0):
    self.accx = numpy.zeros((numaccelm,), dtype=numpy.dtype(numpy.float64))
    self.accy = numpy.zeros((numaccelm,), dtype=numpy.dtype(numpy.float64))
    self.accptr = numpy.zeros(((numacc + 1),), dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_Lmosek_4fusion_4SolutionStruct_2(that):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
    self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
  def _ctor_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
   self.sol_numcon = (that.sol_numcon)
   self.sol_numvar = (that.sol_numvar)
   self.sol_numbarvar = (that.sol_numbarvar)
   self.sol_numacc = (that.sol_numacc)
   self.sol_numaccelm = (that.sol_numaccelm)
   self.pstatus = (that.pstatus)
   self.dstatus = (that.dstatus)
   self.probstatus = (that.probstatus)
   self.pobj = (that.pobj)
   self.dobj = (that.dobj)
   self.xc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xc)) if (((that.xc) is not None) ) else None)
   self.xx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xx)) if (((that.xx) is not None) ) else None)
   self.yx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.yx)) if (((that.yx) is not None) ) else None)
   self.slc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slc)) if (((that.slc) is not None) ) else None)
   self.suc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.suc)) if (((that.suc) is not None) ) else None)
   self.y = (mosek.fusion.Utils.Tools._arraycopy__3D((that.y)) if (((that.y) is not None) ) else None)
   self.barx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.barx)) if (((that.barx) is not None) ) else None)
   self.bars = (mosek.fusion.Utils.Tools._arraycopy__3D((that.bars)) if (((that.bars) is not None) ) else None)
   self.slx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slx) is not None) ) else None)
   self.sux = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.sux) is not None) ) else None)
   self.accptr = (mosek.fusion.Utils.Tools._arraycopy__3I((that.accptr)) if (((that.accptr) is not None) ) else None)
   self.accx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.accx)) if (((that.accx) is not None) ) else None)
   self.accy = (mosek.fusion.Utils.Tools._arraycopy__3D((that.accy)) if (((that.accy) is not None) ) else None)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_SolutionStruct._ctor_Lmosek_4fusion_4SolutionStruct_2(self))
  @staticmethod
  def _match_resize_IIIII(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_I__(_a_3) and __arg_match_I__(_a_4))
  @staticmethod
  def _match_alt_resize_IIIII(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_I__(_a_3) and __arg_alt_match_I__(_a_4))
  def _resize_alt_IIIII(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
    return self._resize_IIIII(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2),numpy.int32(__a_3),numpy.int32(__a_4))
  def _resize_IIIII(self,_a_0,_a_1,_a_2,_a_3,_a_4):
   if (_a_3 <= 0):
    self.sol_numacc = 0
   elif (_a_3 <= (int((self.accptr).shape[0]) - 1)):
    self.sol_numacc = _a_3
   else:
    _a_5=((int((self.accptr).shape[0]) - 1) * 2)
    if (_a_5 < _a_3):
     _a_5 = _a_3
    _a_6=numpy.zeros(((_a_5 + 1),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.accptr,0,_a_6,0,(_a_3 + 1))
    self.accptr = _a_6
    self.sol_numacc = _a_3
   if (_a_4 <= 0):
    self.sol_numaccelm = 0
   elif (_a_4 > int((self.accx).shape[0])):
    self.sol_numaccelm = _a_4
   else:
    _a_7=(int((self.accx).shape[0]) * 2)
    if (_a_7 < _a_4):
     _a_7 = _a_4
    _a_8=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.float64))
    _a_9=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.accx,0,_a_8,0,_a_4)
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.accy,0,_a_9,0,_a_4)
    self.accx = _a_8
    self.accy = _a_9
    self.sol_numaccelm = _a_4
   if (_a_2 < 0):
    pass
   elif (_a_2 <= self.sol_numbarvar):
    self.sol_numbarvar = _a_2
   elif (_a_2 <= int((self.barx).shape[0])):
    pass
   else:
    if ((self.sol_numbarvar * 2) > (_a_2 + 100)):
     _a_10 = (self.sol_numbarvar * 2)
    else:
     _a_10 = (_a_2 + 100)
    self.barx = mosek.fusion.CommonTools._resize__3DI(self.barx,_a_10)
    self.bars = mosek.fusion.CommonTools._resize__3DI(self.bars,_a_10)
    self.sol_numbarvar = _a_10
   if (_a_0 < 0):
    pass
   elif (_a_0 <= self.sol_numvar):
    self.sol_numvar = _a_0
   elif (_a_0 <= int((self.xx).shape[0])):
    self.sol_numvar = fragments._c_closure_130(_a_0,self.slx,self.sol_numvar,self.sux,self.xx,self.yx)
    self.sol_numvar = numpy.int32(self.sol_numvar) # postprocess
   else:
    if ((self.sol_numvar * 2) > (_a_0 + 100)):
     _a_11 = (self.sol_numvar * 2)
    else:
     _a_11 = (_a_0 + 100)
    _a_12=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slx,0,_a_12,0,int((self.slx).shape[0]))
    self.slx = _a_12
    _a_13=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.sux,0,_a_13,0,int((self.sux).shape[0]))
    self.sux = _a_13
    _a_14=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xx,0,_a_14,0,int((self.xx).shape[0]))
    self.xx = _a_14
    _a_15=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.yx,0,_a_15,0,int((self.yx).shape[0]))
    self.yx = _a_15
    fragments._c_closure_131(_a_0,self.slx,self.sol_numvar,self.sux,self.xx) 
    self.sol_numvar = _a_0
   if (_a_1 < 0):
    pass
   elif (_a_1 <= self.sol_numcon):
    self.sol_numcon = _a_1
   elif (_a_1 <= int((self.xx).shape[0])):
    self.sol_numcon = fragments._c_closure_132(_a_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y)
    self.sol_numcon = numpy.int32(self.sol_numcon) # postprocess
   else:
    if ((self.sol_numcon * 2) > (_a_1 + 100)):
     _a_16 = (self.sol_numcon * 2)
    else:
     _a_16 = (_a_1 + 100)
    _a_17=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slc,0,_a_17,0,int((self.slc).shape[0]))
    self.slc = _a_17
    _a_18=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.suc,0,_a_18,0,int((self.suc).shape[0]))
    self.suc = _a_18
    _a_19=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xc,0,_a_19,0,int((self.xc).shape[0]))
    self.xc = _a_19
    _a_20=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.y,0,_a_20,0,int((self.y).shape[0]))
    self.y = _a_20
    fragments._c_closure_133(_a_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) 
    self.sol_numcon = _a_1
  @staticmethod
  def _match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_a_0))
  @staticmethod
  def _match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_a_0))
  def _isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__a_0):
    return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__a_0)
  def _isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_a_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.dstatus,_a_0))
  @staticmethod
  def _match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_a_0))
  @staticmethod
  def _match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_a_0))
  def _isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__a_0):
    return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__a_0)
  def _isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_a_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.pstatus,_a_0))
  def __isAcceptable_alt_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_t__a_0,_t__a_1):
    return self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(__a_0,__a_1)
  def __isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_a_0,_a_1):
   if (_a_1==mosek.fusion.AccSolutionStatus.Anything):
    return (True)
   elif (_a_1==mosek.fusion.AccSolutionStatus.Optimal):
    return ((_a_0==mosek.fusion.SolutionStatus.Optimal))
   elif (_a_1==mosek.fusion.AccSolutionStatus.Feasible):
    return (((_a_0==mosek.fusion.SolutionStatus.Optimal) or (_a_0==mosek.fusion.SolutionStatus.Feasible)))
   elif (_a_1==mosek.fusion.AccSolutionStatus.Certificate):
    return ((_a_0==mosek.fusion.SolutionStatus.Certificate))
   return (False)
 return SolutionStruct
mosek_fusion_SolutionStruct=__mk_mosek_fusion_SolutionStruct()
del __mk_mosek_fusion_SolutionStruct
#BEFORE CLASS
def __mk_mosek_fusion_RowBlockManager():
 class RowBlockManager(object):
  __slots__ = ['varidx_used','code_used','cconst','code','first_free_codeitem','param_code_sizes','param_varidx','first_free_entry','row_code_ptr','row_param_ptre','row_param_ptrb','blocks']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):
      self._ctor_init_Lmosek_4fusion_4RowBlockManager_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4RowBlockManager_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RowBlockManager.ctor()\n\tmosek.fusion.RowBlockManager.ctor(mosek.fusion.RowBlockManager)')
  def is_parameterized(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.is_parameterized()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_is_1parameterized_(*args):
      return self._is_1parameterized_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_is_1parameterized_(*args):
      return self._is_1parameterized_alt_(*args)
    else:
      raise ValueError('Invalid argument list is_parameterized('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.is_parameterized()')
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.get(int32,array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    id : int32
    offset : int32
    target : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_get_I_3II(*args):
      return self._get_I_3II(*args)
    elif mosek_fusion_RowBlockManager._match_alt_get_I_3II(*args):
      return self._get_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.get(int32,array(int32,ndim=1),int32)')
  def block_capacity(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.block_capacity()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_block_1capacity_(*args):
      return self._block_1capacity_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_block_1capacity_(*args):
      return self._block_1capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list block_capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.block_capacity()')
  def num_parameterized(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.num_parameterized()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_num_1parameterized_(*args):
      return self._num_1parameterized_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_num_1parameterized_(*args):
      return self._num_1parameterized_alt_(*args)
    else:
      raise ValueError('Invalid argument list num_parameterized('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.num_parameterized()')
  def row_is_parameterized(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.row_is_parameterized(int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_row_1is_1parameterized_I(*args):
      return self._row_1is_1parameterized_I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_row_1is_1parameterized_I(*args):
      return self._row_1is_1parameterized_alt_I(*args)
    else:
      raise ValueError('Invalid argument list row_is_parameterized('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.row_is_parameterized(int32)')
  def release(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.release(int32,array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    id : int32
    nativeidxs : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_release_I_3I(*args):
      return self._release_I_3I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_release_I_3I(*args):
      return self._release_alt_I_3I(*args)
    else:
      raise ValueError('Invalid argument list release('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.release(int32,array(int32,ndim=1))')
  def allocate(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.allocate(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    nativeidxs : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_allocate__3I(*args):
      return self._allocate__3I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_allocate__3I(*args):
      return self._allocate_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list allocate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.allocate(array(int32,ndim=1))')
  def blocksize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.blocksize(int32)

    Description
    -----------

    

    Parameters
    ----------

    id : int32
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_blocksize_I(*args):
      return self._blocksize_I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_blocksize_I(*args):
      return self._blocksize_alt_I(*args)
    else:
      raise ValueError('Invalid argument list blocksize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.blocksize(int32)')
  def clear_row_code(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.clear_row_code(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    nativeidxs : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_clear_1row_1code__3I(*args):
      return self._clear_1row_1code__3I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_clear_1row_1code__3I(*args):
      return self._clear_1row_1code_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list clear_row_code('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.clear_row_code(array(int32,ndim=1))')
  def capacity(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.capacity()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_capacity_(*args):
      return self._capacity_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_capacity_(*args):
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.capacity()')
  def replace_row_code(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.replace_row_code(mosek.fusion.WorkStack,array(int32,ndim=1),int32,int32,int32,int32,int32)

    Description
    -----------

    Replace the parameterization code in a set of rows 

    Parameters
    ----------

    cconst_p : int32
    code_p : int32
    codeptr : int32
    nativeidxs : array(int32,ndim=1)
    nidxs : int32
    ptr : int32
    rs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args):
      return self._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args)
    elif mosek_fusion_RowBlockManager._match_alt_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args):
      return self._replace_1row_1code_alt_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args)
    else:
      raise ValueError('Invalid argument list replace_row_code('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.replace_row_code(mosek.fusion.WorkStack,array(int32,ndim=1),int32,int32,int32,int32,int32)')
  def evaluate(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RowBlockManager.evaluate(mosek.fusion.WorkStack,array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    param_value : array(double,ndim=1)
    subi : array(int32,ndim=1)
    subj : array(int32,ndim=1)
    val : array(double,ndim=1)
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_RowBlockManager._match_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args):
      return self._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args)
    elif mosek_fusion_RowBlockManager._match_alt_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args):
      return self._evaluate_alt_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list evaluate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.evaluate(mosek.fusion.WorkStack,array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.RowBlockManager'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RowBlockManager_2(that):
    o = RowBlockManager.__new__(RowBlockManager)
    o._ctor_init_Lmosek_4fusion_4RowBlockManager_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4RowBlockManager_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4RowBlockManager_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4RowBlockManager_2(self,that):
    self._ctor_init_Lmosek_4fusion_4RowBlockManager_2(that)
  def _ctor_init_Lmosek_4fusion_4RowBlockManager_2(self,that):
   self.blocks = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((that.blocks))
   self.row_param_ptrb = (mosek.fusion.Utils.Tools._arraycopy__3I((that.row_param_ptrb)) if (((that.row_param_ptrb) is not None) ) else None)
   self.row_param_ptre = (mosek.fusion.Utils.Tools._arraycopy__3I((that.row_param_ptre)) if (((that.row_param_ptre) is not None) ) else None)
   self.row_code_ptr = (mosek.fusion.Utils.Tools._arraycopy__3I((that.row_code_ptr)) if (((that.row_code_ptr) is not None) ) else None)
   self.first_free_entry = (that.first_free_entry)
   self.param_varidx = (mosek.fusion.Utils.Tools._arraycopy__3J((that.param_varidx)) if (((that.param_varidx) is not None) ) else None)
   self.param_code_sizes = (mosek.fusion.Utils.Tools._arraycopy__3I((that.param_code_sizes)) if (((that.param_code_sizes) is not None) ) else None)
   self.first_free_codeitem = (that.first_free_codeitem)
   self.code = (mosek.fusion.Utils.Tools._arraycopy__3I((that.code)) if (((that.code) is not None) ) else None)
   self.cconst = (mosek.fusion.Utils.Tools._arraycopy__3D((that.cconst)) if (((that.cconst) is not None) ) else None)
   self.code_used = (that.code_used)
   self.varidx_used = (that.varidx_used)
  @staticmethod
  def _ctor_():
    o = RowBlockManager.__new__(RowBlockManager)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self.blocks = mosek_fusion_LinkedBlocks._ctor_()
   self.row_param_ptrb = None
   self.row_param_ptre = None
   self.row_code_ptr = None
   self.first_free_entry = 0
   self.param_varidx = None
   self.param_code_sizes = None
   self.first_free_codeitem = 0
   self.code = None
   self.cconst = None
   self.code_used = 0
   self.varidx_used = 0
  @staticmethod
  def _match_num_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_num_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  def _num_1parameterized_alt_(self,):
    return self._num_1parameterized_()
  def _num_1parameterized_(self,):
   return numpy.int32(self.varidx_used)
  @staticmethod
  def _match_is_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_is_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  def _is_1parameterized_alt_(self,):
    return self._is_1parameterized_()
  def _is_1parameterized_(self,):
   return ((self.code_used > 0))
  @staticmethod
  def _match_blocksize_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_blocksize_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _blocksize_alt_I(self,_t__a_0):
    return self._blocksize_I(numpy.int32(__a_0))
  def _blocksize_I(self,_a_0):
   return numpy.int32(self.blocks._blocksize_I(_a_0))
  @staticmethod
  def _match_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  def _block_1capacity_alt_(self,):
    return self._block_1capacity_()
  def _block_1capacity_(self,):
   return numpy.int32(self.blocks._block_1capacity_())
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(self.blocks._capacity_())
  @staticmethod
  def _match_get_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_get_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _get_alt_I_3II(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self._get_I_3II(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _get_I_3II(self,_a_0,_a_1,_a_2):
   self.blocks._get_I_3II(_a_0,_a_1,_a_2)
  @staticmethod
  def _match_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match__3D__(_a_1) and __arg_match__3I__(_a_2) and __arg_match__3I__(_a_3) and __arg_match__3D__(_a_4))
  @staticmethod
  def _match_alt_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match__3I__(_a_3) and __arg_alt_match__3D__(_a_4))
  def _evaluate_alt_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _1_res = self._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self,_a_0,_a_1,_a_2,_a_3,_a_4):
   _a_5=_a_0._allocf64_I(self.code_used)
   _a_6=0
   _a_7=(_a_0.f64)
   _a_8=0
   _a_8,_a_6 = fragments._c_closure_134(self.cconst,self.code,_a_8,self.param_code_sizes,_a_1,self.param_varidx,self.row_code_ptr,self.row_param_ptrb,self.row_param_ptre,_a_5,_a_6,_a_2,_a_3,_a_4,_a_7)
   _a_8 = numpy.int32(_a_8) # postprocess
   _a_6 = numpy.int32(_a_6) # postprocess
   _a_0._popf64_I(self.code_used)
  @staticmethod
  def _match_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args):
    if len(args) != 7: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_I__(_a_3) and __arg_match_I__(_a_4) and __arg_match_I__(_a_5) and __arg_match_I__(_a_6))
  @staticmethod
  def _match_alt_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args):
    if len(args) != 7: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_I__(_a_3) and __arg_alt_match_I__(_a_4) and __arg_alt_match_I__(_a_5) and __arg_alt_match_I__(_a_6))
  def _replace_1row_1code_alt_Lmosek_4fusion_4WorkStack_2_3IIIIII(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.int32(_t__a_5)
   _a_6=numpy.int32(_t__a_6)
   _1_res = self._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self,_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6):
   _a_7=int((_a_1).shape[0])
   _a_8=(_a_0.i32)
   _a_9=(_a_0.i64)
   _a_10=(_a_0.f64)
   _a_11=True
   _a_12=0
   _a_13=0
   _a_13,_a_12 = fragments._c_closure_135(_a_5,_a_4,_a_7,_a_13,_a_12,_a_2,_a_8)
   _a_13 = numpy.int32(_a_13) # postprocess
   _a_12 = numpy.int32(_a_12) # postprocess
   self._clear_1row_1code__3I(_a_1)
   self.__ensure_1code_1cap_II(_a_13,_a_12)
   self.code_used += _a_12
   self.varidx_used += _a_13
   if (self.first_free_codeitem > (self.code_used * 2)):
    self.__compress_()
   self.first_free_codeitem,self.first_free_entry = fragments._c_closure_136(_a_5,_a_4,self.first_free_codeitem,self.first_free_entry,_a_1,_a_7,_a_2,_a_8,self.row_code_ptr,self.row_param_ptrb,self.row_param_ptre)
   self.first_free_codeitem = numpy.int32(self.first_free_codeitem) # postprocess
   self.first_free_entry = numpy.int32(self.first_free_entry) # postprocess
   _a_11 = fragments._c_closure_137(self.cconst,_a_6,self.code,_a_5,_a_4,_a_1,_a_7,_a_3,_a_11,self.param_code_sizes,self.param_varidx,_a_2,_a_10,_a_8,_a_9,self.row_code_ptr,self.row_param_ptrb)
   if (not _a_11):
    raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
  @staticmethod
  def _match_clear_1row_1code__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_clear_1row_1code__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _clear_1row_1code_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._clear_1row_1code__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _clear_1row_1code__3I(self,_a_0):
   self.code_used,self.varidx_used = fragments._c_closure_138(self.code_used,_a_0,self.param_code_sizes,self.row_param_ptrb,self.row_param_ptre,self.varidx_used)
   self.code_used = numpy.int32(self.code_used) # postprocess
   self.varidx_used = numpy.int32(self.varidx_used) # postprocess
  def __compress_alt_(self,):
    return self.__compress_()
  def __compress_(self,):
   _a_0=numpy.zeros((self.code_used,), dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.zeros((self.code_used,), dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.zeros((self.first_free_entry,), dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.zeros((self.first_free_entry,), dtype=numpy.dtype(numpy.int32))
   _a_4=0
   _a_5=0
   for _a_6 in range(0,int((self.row_param_ptrb).shape[0])):
    _a_7=0
    _a_8=(self.row_param_ptre[_a_6] - self.row_param_ptrb[_a_6])
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.param_varidx,self.row_param_ptrb[_a_6],_a_2,_a_4,_a_8)
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.param_code_sizes,self.row_param_ptrb[_a_6],_a_3,_a_4,_a_8)
    _a_7 = fragments._c_closure_139(_a_7,_a_6,self.param_code_sizes,self.row_param_ptrb,self.row_param_ptre)
    _a_7 = numpy.int32(_a_7) # postprocess
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.code,self.row_code_ptr[_a_6],_a_0,_a_5,_a_7)
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.cconst,self.row_code_ptr[_a_6],_a_1,_a_5,_a_7)
    self.row_param_ptrb[_a_6] = _a_4
    self.row_param_ptre[_a_6] = (_a_4 + _a_8)
    self.row_code_ptr[_a_6] = _a_5
    _a_5 += _a_7
    _a_4 += _a_8
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_2,0,self.param_varidx,0,_a_4)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_3,0,self.param_code_sizes,0,_a_4)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_0,0,self.code,0,_a_5)
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_1,0,self.cconst,0,_a_5)
   self.first_free_codeitem = _a_5
   self.first_free_entry = _a_4
  def __ensure_1code_1cap_alt_II(self,_t__a_0,_t__a_1):
    return self.__ensure_1code_1cap_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def __ensure_1code_1cap_II(self,_a_0,_a_1):
   if (self.row_code_ptr is None):
    _a_2=128
    _a_2 = fragments._c_closure_140(_a_2,_a_0)
    _a_2 = numpy.int32(_a_2) # postprocess
    _a_3=128
    _a_3 = fragments._c_closure_141(_a_1,_a_3)
    _a_3 = numpy.int32(_a_3) # postprocess
    self.row_param_ptrb = numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    self.row_param_ptre = numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    self.row_code_ptr = numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    self.param_varidx = numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    self.param_code_sizes = numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    self.code = numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    self.cconst = numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
   else:
    if (_a_0 > (int((self.param_varidx).shape[0]) - self.first_free_entry)):
     _a_4=int((self.param_varidx).shape[0])
     _a_4 = fragments._c_closure_142(self.first_free_entry,_a_4,_a_0)
     _a_4 = numpy.int32(_a_4) # postprocess
     _a_5=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
     _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int64))
     _a_7=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.param_varidx,0,_a_6,0,self.first_free_entry)
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.param_code_sizes,0,_a_7,0,self.first_free_entry)
     self.param_varidx = _a_6
     self.param_code_sizes = _a_7
    if (_a_1 > (int((self.code).shape[0]) - self.first_free_codeitem)):
     _a_8=int((self.code).shape[0])
     _a_8 = fragments._c_closure_143(_a_1,self.first_free_codeitem,_a_8)
     _a_8 = numpy.int32(_a_8) # postprocess
     _a_9=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.int32))
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.code,0,_a_9,0,self.first_free_codeitem)
     _a_10=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.float64))
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.cconst,0,_a_10,0,self.first_free_codeitem)
     self.code = _a_9
     self.cconst = _a_10
  @staticmethod
  def _match_release_I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_release_I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _release_alt_I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._release_I_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _release_I_3I(self,_a_0,_a_1):
   _a_2=self.blocks._blocksize_I(_a_0)
   self.blocks._get_I_3II(_a_0,_a_1,0)
   self.blocks._free_I(_a_0)
   self.code_used = fragments._c_closure_144(self.code_used,_a_1,_a_2,self.row_code_ptr,self.row_param_ptrb,self.row_param_ptre)
   self.code_used = numpy.int32(self.code_used) # postprocess
  @staticmethod
  def _match_allocate__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_allocate__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _allocate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._allocate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _allocate__3I(self,_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=self.blocks._alloc_I(_a_1)
   self.blocks._get_I_3II(_a_2,_a_0,0)
   if ((self.row_code_ptr is not None) and (self.blocks._capacity_() > int((self.row_param_ptrb).shape[0]))):
    _a_3=numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.row_param_ptrb,0,_a_3,0,int((self.row_param_ptrb).shape[0]))
    _a_4=numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.row_param_ptre,0,_a_4,0,int((self.row_param_ptre).shape[0]))
    _a_5=numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.row_code_ptr,0,_a_5,0,int((self.row_code_ptr).shape[0]))
    self.row_param_ptrb = _a_3
    self.row_param_ptre = _a_4
    self.row_code_ptr = _a_5
   return numpy.int32(_a_2)
  @staticmethod
  def _match_row_1is_1parameterized_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_row_1is_1parameterized_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _row_1is_1parameterized_alt_I(self,_t__a_0):
    return self._row_1is_1parameterized_I(numpy.int32(__a_0))
  def _row_1is_1parameterized_I(self,_a_0):
   return (((self.row_param_ptrb is not None) and (self.row_param_ptrb[_a_0] < self.row_param_ptre[_a_0])))
 return RowBlockManager
mosek_fusion_RowBlockManager=__mk_mosek_fusion_RowBlockManager()
del __mk_mosek_fusion_RowBlockManager
#BEFORE CLASS
def __mk_mosek_fusion_BaseVariable():
 class BaseVariable(mosek_fusion_Variable,object):
  __slots__ = ['_BaseVariable__sparsity','_BaseVariable__basevar_nativeidxs','_BaseVariable__model','_BaseVariable__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseVariable.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int64,ndim=1),array(int64,ndim=1))')
  def numInst(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.numInst()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_numInst_(*args):
      return self._numInst_(*args)
    elif mosek_fusion_BaseVariable._match_alt_numInst_(*args):
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.numInst()')
  def makeContinuous(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.makeContinuous()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeContinuous_(*args):
      return self._makeContinuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeContinuous_(*args):
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeContinuous()')
  def fromTril(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.fromTril(int32)
      mosek.fusion.BaseVariable.fromTril(int32,int32)

    Description
    -----------

    Convert from a trilinear representation into a square variable. 

    Parameters
    ----------

    d : int32
        Dimension of the square variable. 
    dim0 : int32
        Index of the trilinear variable slices in a multi-dimensional representation. 
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_fromTril_I(*args):
      return self._fromTril_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_fromTril_I(*args):
      return self._fromTril_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_fromTril_II(*args):
      return self._fromTril_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_fromTril_II(*args):
      return self._fromTril_alt_II(*args)
    else:
      raise ValueError('Invalid argument list fromTril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.fromTril(int32)\n\tmosek.fusion.BaseVariable.fromTril(int32,int32)')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.pick(array(int32,ndim=1))
      mosek.fusion.BaseVariable.pick(array(int32,ndim=2))
      mosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))
      mosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Create a one-dimensional variable by picking a list of indexes from this variable. 

    Parameters
    ----------

    i0 : array(int32,ndim=1)
        Index along the first dimension.
    i1 : array(int32,ndim=1)
        Index along the second dimension.
    i2 : array(int32,ndim=1)
        Index along the third dimension.
    idxs : array(int32,ndim=1)
        Indexes of the elements requested.
    midxs : array(int32,ndim=2)
        A sequence of multi-dimensional indexes of the elements requested.
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I(*args):
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I(*args):
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I_3I(*args):
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I_3I(*args):
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def getDim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.getDim(int32)

    Description
    -----------

    

    Parameters
    ----------

    d : int32
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_getDim_I(*args):
      return self._getDim_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_getDim_I(*args):
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getDim(int32)')
  def makeInteger(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.makeInteger()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeInteger_(*args):
      return self._makeInteger_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeInteger_(*args):
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeInteger()')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.getND()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getND()')
  def getModel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.getModel()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_getModel_(*args):
      return self._getModel_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getModel_(*args):
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getModel()')
  def values(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)

    Description
    -----------

    

    Parameters
    ----------

    offset : int32
    primal : bool
    target : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_values_I_3DZ(*args):
      return self._values_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_I_3DZ(*args):
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)')
  def reshape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.reshape(array(int32,ndim=1))
      mosek.fusion.BaseVariable.reshape(int32)
      mosek.fusion.BaseVariable.reshape(int32,int32)
      mosek.fusion.BaseVariable.reshape(int32,int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    dim0 : int32
    dim1 : int32
    dim2 : int32
    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_reshape__3I(*args):
      return self._reshape__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape__3I(*args):
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_I(*args):
      return self._reshape_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_I(*args):
      return self._reshape_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_II(*args):
      return self._reshape_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_II(*args):
      return self._reshape_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_reshape_III(*args):
      return self._reshape_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_III(*args):
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.reshape(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.reshape(int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32,int32)')
  def antidiag(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.antidiag()
      mosek.fusion.BaseVariable.antidiag(int32)

    Description
    -----------

    Return the antidiagonal of a square variable matrix.

    Parameters
    ----------

    index : int32
        Index of the anti-diagonal
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_antidiag_(*args):
      return self._antidiag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_(*args):
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_antidiag_I(*args):
      return self._antidiag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_I(*args):
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.antidiag()\n\tmosek.fusion.BaseVariable.antidiag(int32)')
  def dual(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.dual()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_dual_(*args):
      return self._dual_(*args)
    elif mosek_fusion_BaseVariable._match_alt_dual_(*args):
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.dual()')
  def inst(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1))
      mosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    basevar_nativeidxs : array(int64,ndim=1)
    nindex : array(int64,ndim=1)
    nioffset : int32
    offset : int32
    sparsity : array(int64,ndim=1)
    spoffset : int32
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_inst_I_3J(*args):
      return self._inst_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3J(*args):
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_inst_I_3JI_3J(*args):
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3JI_3J(*args):
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.getSize()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getSize()')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.getShape()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getShape()')
  def make_continuous(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.make_continuous()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1continuous_(*args):
      return self._make_1continuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1continuous_(*args):
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_continuous()')
  def tril(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.tril()
      mosek.fusion.BaseVariable.tril(int32,int32)

    Description
    -----------

    Convert from a square variable to a trilinear representation. 

    Parameters
    ----------

    dim1 : int32
        First dimension in the current shape containing the square variables. 
    dim2 : int32
        Second dimension in the current shape containing the square variables. 
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_tril_(*args):
      return self._tril_(*args)
    elif mosek_fusion_BaseVariable._match_alt_tril_(*args):
      return self._tril_alt_(*args)
    elif mosek_fusion_BaseVariable._match_tril_II(*args):
      return self._tril_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_tril_II(*args):
      return self._tril_alt_II(*args)
    else:
      raise ValueError('Invalid argument list tril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.tril()\n\tmosek.fusion.BaseVariable.tril(int32,int32)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def level(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.level()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_level_(*args):
      return self._level_(*args)
    elif mosek_fusion_BaseVariable._match_alt_level_(*args):
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.level()')
  def make_integer(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.make_integer()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1integer_(*args):
      return self._make_1integer_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1integer_(*args):
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_integer()')
  def remove(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.remove()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_remove_(*args):
      return self._remove_(*args)
    elif mosek_fusion_BaseVariable._match_alt_remove_(*args):
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.remove()')
  def diag(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.diag()
      mosek.fusion.BaseVariable.diag(int32)

    Description
    -----------

    Return the diagonal of a square variable matrix.

    Parameters
    ----------

    index : int32
        Index of the anti-diagonal
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_diag_(*args):
      return self._diag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_(*args):
      return self._diag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_diag_I(*args):
      return self._diag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_I(*args):
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.diag()\n\tmosek.fusion.BaseVariable.diag(int32)')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.transpose()

    Description
    -----------

    Transpose the variable.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_BaseVariable._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.transpose()')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.index(int32)
      mosek.fusion.BaseVariable.index(array(int32,ndim=1))
      mosek.fusion.BaseVariable.index(int32,int32)
      mosek.fusion.BaseVariable.index(int32,int32,int32)

    Description
    -----------

    Return a variable slice of size 1 corresponding to a single element in the variable object..

    Parameters
    ----------

    i0 : int32
        Index in the first dimension of the element requested.
    i1 : int32
        Index in the second dimension of the element requested.
    i2 : int32
    index : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_index_II(*args):
      return self._index_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_II(*args):
      return self._index_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_index_III(*args):
      return self._index_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_III(*args):
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.index(int32)\n\tmosek.fusion.BaseVariable.index(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.index(int32,int32)\n\tmosek.fusion.BaseVariable.index(int32,int32,int32)')
  def set_values(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.set_values(array(double,ndim=1),bool)

    Description
    -----------

    

    Parameters
    ----------

    primal : bool
    values : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_set_1values__3DZ(*args):
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values__3DZ(*args):
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.set_values(array(double,ndim=1),bool)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_BaseVariable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.toString()')
  def setLevel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.setLevel(array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    v : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_setLevel__3D(*args):
      return self._setLevel__3D(*args)
    elif mosek_fusion_BaseVariable._match_alt_setLevel__3D(*args):
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.setLevel(array(double,ndim=1))')
  def asExpr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.asExpr()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_asExpr_(*args):
      return self._asExpr_(*args)
    elif mosek_fusion_BaseVariable._match_alt_asExpr_(*args):
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.asExpr()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseVariable.slice(int32,int32)
      mosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Create a slice variable by picking a range of indexes for each variable dimension. 

    Parameters
    ----------

    first : array(int32,ndim=1)
        The indices from which the slice of a multidimensional variable begins.
    last : array(int32,ndim=1)
        The indices after the last element of slice of a multidimensional variable.
    '''
    if False: pass
    elif mosek_fusion_BaseVariable._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.slice(int32,int32)\n\tmosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BaseVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   self.__model = m
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
   self.__basevar_nativeidxs = (v.__basevar_nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,basevar_nativeidxs):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,basevar_nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,basevar_nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(basevar_nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,basevar_nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(basevar_nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,basevar_nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(basevar_nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,basevar_nativeidxs):
   self.__model = m
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__basevar_nativeidxs) = basevar_nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("Variable((")
   if (int((self.__shape).shape[0]) > 0):
    _a_0._a_I(self.__shape[0])
    for _a_1 in range(1,int((self.__shape).shape[0])):
     _a_0._a_S(",")._a_I(self.__shape[_a_1])
   _a_0._a_S("))")
   return (_a_0._toString_())
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=int((self.__basevar_nativeidxs).shape[0])
   _a_4=_a_3
   _a_5=int((self.__shape).shape[0])
   _a_6=(self.__sparsity is not None)
   _a_0._alloc_1expr_IIIZ(_a_5,_a_4,_a_3,_a_6)
   _a_7=(_a_0.ptr_base)
   _a_8=(_a_0.nidxs_base)
   _a_9=(_a_0.sp_base)
   _a_10=(_a_0.cof_base)
   _a_11=(_a_0.shape_base)
   _a_12=(_a_0.i32)
   _a_13=(_a_0.i64)
   _a_14=(_a_0.f64)
   fragments._c_closure_145(_a_5,_a_12,self.__shape,_a_11) 
   fragments._c_closure_146(self.__basevar_nativeidxs,_a_10,_a_6,_a_8,_a_3,_a_7,_a_14,_a_12,_a_13,_a_9,self.__sparsity) 
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   raise mosek_fusion_DeletionError._ctor_S("Only original variables can be removed")
  @staticmethod
  def _match_fromTril_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_fromTril_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _fromTril_alt_II(self,_t__a_0,_t__a_1):
    return self._fromTril_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _fromTril_II(self,_a_0,_a_1):
   if ((_a_0 < 0) or (_a_0 >= int((self.__shape).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension")
   elif (self.__shape[_a_0]!=((_a_1 * (_a_1 + 1)) // 2)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   _a_2=1
   _a_2 = fragments._c_closure_147(_a_2,_a_0,self.__shape)
   _a_2 = numpy.int32(_a_2) # postprocess
   _a_3=self.__shape[_a_0]
   _a_4=1
   _a_4 = fragments._c_closure_148(_a_4,_a_0,self.__shape)
   _a_4 = numpy.int32(_a_4) # postprocess
   _a_5=numpy.zeros(((int((self.__shape).shape[0]) + 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_149(_a_0,_a_5,self.__shape) 
   _a_5[_a_0] = _a_1
   _a_5[(_a_0 + 1)] = _a_1
   fragments._c_closure_150(_a_0,_a_5,self.__shape) 
   if (self.__sparsity is None):
    _a_6=numpy.zeros(((((_a_2 * _a_1) * _a_1) * _a_4),), dtype=numpy.dtype(numpy.int64))
    _a_7=0
    _a_7 = fragments._c_closure_151(self.__basevar_nativeidxs,_a_1,_a_2,_a_3,_a_4,_a_6,_a_7)
    _a_7 = numpy.int32(_a_7) # postprocess
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_5,None,_a_6))
   else:
    _a_8=0
    for _a_9 in range(0,int((self.__sparsity).shape[0])):
     _a_10=((self.__sparsity[_a_9] // _a_4) % _a_3)
     _a_11=numpy.int32((((- 1) + mosek.fusion.Utils.Tools._sqrt_D(((1 + (2 * _a_10)) * (1 + (2 * _a_10))))) / 4))
     _a_12=(self.__sparsity[_a_9] - ((_a_11 * (_a_11 + 1)) // 2))
     if (_a_11==_a_12):
      _a_8 += 1
     else:
      _a_8 += 2
    _a_13=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.int64))
    _a_14=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.int64))
    _a_15=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_152(_a_8,_a_15) 
    _a_16=0
    for _a_17 in range(0,int((self.__sparsity).shape[0])):
     _a_18=(self.__sparsity[_a_17] // (_a_3 * _a_4))
     _a_19=((self.__sparsity[_a_17] // _a_4) % _a_3)
     _a_20=(self.__sparsity[_a_17] % _a_4)
     _a_21=numpy.int32((((- 1) + mosek.fusion.Utils.Tools._sqrt_D(((1 + (2 * _a_19)) * (1 + (2 * _a_19))))) / 4))
     _a_22=(self.__sparsity[_a_17] - ((_a_21 * (_a_21 + 1)) // 2))
     if (_a_21==_a_22):
      _a_13[_a_16] = self.__basevar_nativeidxs[_a_17]
      _a_14[_a_16] = (((((_a_18 * _a_1) * _a_1) * _a_4) + (((_a_21 * _a_1) + _a_22) * _a_4)) + _a_20)
      _a_16 += 1
     else:
      _a_13[_a_16] = self.__basevar_nativeidxs[_a_17]
      _a_13[(_a_16 + 1)] = self.__basevar_nativeidxs[_a_17]
      _a_14[_a_16] = (((((_a_18 * _a_1) * _a_1) * _a_4) + (((_a_21 * _a_1) + _a_22) * _a_4)) + _a_20)
      _a_14[(_a_16 + 1)] = (((((_a_18 * _a_1) * _a_1) * _a_4) + (((_a_22 * _a_1) + _a_21) * _a_4)) + _a_20)
      _a_16 += 2
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_15,_a_13,None,0,_a_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_5,numpy.array([_a_14[_a_15[_a_23]] for _a_23 in range(0,_a_8)], dtype=numpy.dtype(numpy.int64)),numpy.array([_a_13[_a_15[_a_24]] for _a_24 in range(0,_a_8)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_fromTril_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_fromTril_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _fromTril_alt_I(self,_t__a_0):
    return self._fromTril_I(numpy.int32(__a_0))
  def _fromTril_I(self,_a_0):
   return (self._fromTril_II(0,_a_0))
  @staticmethod
  def _match_tril_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_tril_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _tril_alt_II(self,_t__a_0,_t__a_1):
    return self._tril_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _tril_II(self,_a_0,_a_1):
   if ((_a_0 < 0) or ((_a_0 >= _a_1) or (_a_1 >= int((self.__shape).shape[0])))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension specification")
   else:
    if (self.__shape[_a_0]!=self.__shape[_a_1]):
     raise mosek_fusion_DimensionError._ctor_S("Operation only valid for square variables")
   _a_2=numpy.zeros(((int((self.__shape).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_153(_a_0,_a_2,self.__shape) 
   _a_2[_a_0] = ((self.__shape[_a_0] * (self.__shape[_a_0] + 1)) // 2)
   fragments._c_closure_154(_a_0,_a_1,_a_2,self.__shape) 
   fragments._c_closure_155(_a_1,_a_2,self.__shape) 
   if (self.__sparsity is None):
    _a_3=1
    _a_3 = fragments._c_closure_156(_a_3,_a_0,self.__shape)
    _a_3 = numpy.int32(_a_3) # postprocess
    _a_4=self.__shape[_a_0]
    _a_5=1
    _a_5 = fragments._c_closure_157(_a_5,_a_0,_a_1,self.__shape)
    _a_5 = numpy.int32(_a_5) # postprocess
    _a_6=self.__shape[_a_1]
    _a_7=1
    _a_7 = fragments._c_closure_158(_a_7,_a_1,self.__shape)
    _a_7 = numpy.int32(_a_7) # postprocess
    _a_8=numpy.zeros(((((((_a_3 * _a_5) * _a_7) * _a_4) * (_a_4 + 1)) // 2),), dtype=numpy.dtype(numpy.int64))
    _a_9=0
    _a_9 = fragments._c_closure_159(self.__basevar_nativeidxs,_a_3,_a_4,_a_5,_a_6,_a_7,_a_9,_a_8)
    _a_9 = numpy.int32(_a_9) # postprocess
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_2,None,_a_8))
   else:
    _a_10=1
    _a_10 = fragments._c_closure_160(_a_10,_a_0,self.__shape)
    _a_10 = numpy.int32(_a_10) # postprocess
    _a_11=self.__shape[_a_0]
    _a_12=1
    _a_12 = fragments._c_closure_161(_a_12,_a_0,_a_1,self.__shape)
    _a_12 = numpy.int32(_a_12) # postprocess
    _a_13=self.__shape[_a_1]
    _a_14=1
    _a_14 = fragments._c_closure_162(_a_14,_a_1,self.__shape)
    _a_14 = numpy.int32(_a_14) # postprocess
    _a_15=1
    _a_16=_a_14
    _a_17=(_a_16 * _a_13)
    _a_18=(_a_17 * _a_12)
    _a_19=(_a_18 * _a_11)
    _a_20=0
    _a_20 = fragments._c_closure_163(_a_11,_a_13,_a_20,_a_18,_a_16,self.__sparsity)
    _a_20 = numpy.int32(_a_20) # postprocess
    _a_21=1
    _a_22=_a_14
    _a_23=(_a_22 * _a_12)
    _a_24=(((_a_23 * _a_11) * (_a_11 + 1)) // 2)
    _a_25=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int64))
    _a_26=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int64))
    _a_27=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int64))
    _a_28=0
    _a_28 = fragments._c_closure_164(self.__basevar_nativeidxs,_a_11,_a_12,_a_13,_a_14,_a_28,_a_20,_a_25,_a_26,_a_24,_a_23,_a_22,_a_21,_a_27,_a_19,_a_18,_a_17,_a_16,_a_15,self.__sparsity)
    _a_28 = numpy.int32(_a_28) # postprocess
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_25,_a_26,None,0,_a_20)
    _a_29=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int64))
    _a_30=numpy.zeros((_a_20,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_165(_a_20,_a_29,_a_25,_a_26) 
    fragments._c_closure_166(_a_20,_a_25,_a_27,_a_30) 
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_2,_a_30,_a_29))
  @staticmethod
  def _match_tril_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_tril_(*args):
    if len(args) != 0: return False
    return True
  def _tril_alt_(self,):
    return self._tril_()
  def _tril_(self,):
   return (self._tril_II(0,1))
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _reshape_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._reshape_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _reshape_III(self,_a_0,_a_1,_a_2):
   return (self._reshape__3I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _reshape_alt_II(self,_t__a_0,_t__a_1):
    return self._reshape_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _reshape_II(self,_a_0,_a_1):
   return (self._reshape__3I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _reshape_alt_I(self,_t__a_0):
    return self._reshape_I(numpy.int32(__a_0))
  def _reshape_I(self,_a_0):
   return (self._reshape__3I(numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _reshape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._reshape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _reshape__3I(self,_a_0):
   _a_1=1
   for _a_2 in range(0,int((_a_0).shape[0])):
    if (_a_0[_a_2] < 0):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
    _a_1 *= _a_0[_a_2]
   if (_a_1!=self._getSize_()):
    raise mosek_fusion_LengthError._ctor_S("Shape size does not match variable size")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_a_0[_a_3] for _a_3 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__basevar_nativeidxs))
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  def _setLevel_alt__3D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setLevel__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setLevel__3D(self,_a_0):
   if (self.__sparsity is None):
    if (int((_a_0).shape[0])!=int((self.__basevar_nativeidxs).shape[0])):
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    self.__model._setVariableValues_Z_3J_3D(True,self.__basevar_nativeidxs,_a_0)
   else:
    if (int((_a_0).shape[0])!=self._getSize_()):
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    _a_1=numpy.array([_a_0[self.__sparsity[_a_2]] for _a_2 in range(0,int((self.__basevar_nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.float64))
    self.__model._setVariableValues_Z_3J_3D(True,self.__basevar_nativeidxs,_a_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getDim_alt_I(self,_t__a_0):
    return self._getDim_I(numpy.int32(__a_0))
  def _getDim_I(self,_a_0):
   return numpy.int32(self.__shape[_a_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _a_0=1
   _a_0 = fragments._c_closure_167(self.__shape,_a_0)
   _a_0 = numpy.int64(_a_0) # postprocess
   return numpy.int64(_a_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _a_0=numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model._getVariableValues_Z_3J_3DI(False,self.__basevar_nativeidxs,_a_0,0)
   if (self.__sparsity is not None):
    _a_1=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_168(self.__basevar_nativeidxs,_a_0,self.__sparsity,_a_1) 
    _a_0 = _a_1
   return (_a_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _a_0=numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model._getVariableValues_Z_3J_3DI(True,self.__basevar_nativeidxs,_a_0,0)
   if (self.__sparsity is not None):
    _a_1=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_169(self.__basevar_nativeidxs,_a_0,self.__sparsity,_a_1) 
    _a_0 = _a_1
   return (_a_0)
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous_()
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer_()
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if (int((self.__shape).shape[0])==1):
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([1,self.__shape[0]], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__basevar_nativeidxs))
   elif (int((self.__shape).shape[0]) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   else:
    _a_0=numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _a_1=(None if ((self.__sparsity is None) ) else numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64)))
    fragments._c_closure_170(self.__basevar_nativeidxs,_a_0,self.__shape,_a_1,self.__sparsity) 
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([self.__shape[1],self.__shape[0]], dtype=numpy.dtype(numpy.int32)),_a_1,_a_0))
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _index_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._index_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _index_III(self,_a_0,_a_1,_a_2):
   return (self._index__3I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _index_alt_II(self,_t__a_0,_t__a_1):
    return self._index_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _index_II(self,_a_0,_a_1):
   return (self._index__3I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   _a_1=numpy.zeros((1,int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_171(_a_0,_a_1) 
   return (self._pick__3_5I(_a_1)._reshape__3I(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   return (self._pick__3I(numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)))._reshape__3I(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2))
  def _pick_alt__3I_3I_3I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I_3I_3I(self,_a_0,_a_1,_a_2):
   if (int((self.__shape).shape[0])!=3):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if ((int((_a_0).shape[0])!=int((_a_1).shape[0])) or (int((_a_0).shape[0])!=int((_a_2).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   _a_3=numpy.zeros((int((_a_0).shape[0]),3,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_172(_a_0,_a_1,_a_2,_a_3) 
   return (self._pick__3_5I(_a_3))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _pick_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I_3I(self,_a_0,_a_1):
   if ((int((self.__shape).shape[0])!=2) or (int((_a_0).shape[0])!=int((_a_1).shape[0]))):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_2=numpy.zeros((int((_a_0).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_173(_a_0,_a_1,_a_2) 
   return (self._pick__3_5I(_a_2))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   if (int((self.__shape).shape[0])!=int((_a_0).shape[1])):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_1=False
   _a_1 = fragments._c_closure_174(_a_1,_a_0,self.__shape)
   if _a_1:
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_2=int((self.__shape).shape[0])
   _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   _a_3[(_a_2 - 1)] = 1
   fragments._c_closure_175(_a_2,self.__shape,_a_3) 
   _a_4=numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))
   _a_6=None
   if (self.__sparsity is None):
    _a_5 = numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_176(self.__basevar_nativeidxs,_a_5,_a_0,_a_2,_a_3) 
   else:
    _a_7=0
    for _a_8 in range(0,int((_a_0).shape[0])):
     _a_9=0
     _a_9 = fragments._c_closure_177(_a_8,_a_9,_a_0,_a_2,_a_3)
     _a_9 = numpy.int64(_a_9) # postprocess
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_a_9) >= 0):
      _a_7 += 1
    _a_5 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_6 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_10=0
    for _a_11 in range(0,int((_a_0).shape[0])):
     _a_12=0
     _a_12 = fragments._c_closure_178(_a_11,_a_12,_a_0,_a_2,_a_3)
     _a_12 = numpy.int64(_a_12) # postprocess
     _a_13=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_a_12)
     if (_a_13 >= 0):
      _a_5[_a_10] = self.__basevar_nativeidxs[_a_13]
      _a_6[_a_10] = _a_11
      _a_10 += 1
    if (_a_7==int((_a_0).shape[0])):
     _a_6 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_4,_a_6,_a_5))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   if (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_1=False
   _a_1 = fragments._c_closure_179(_a_0,_a_1,self.__shape)
   if _a_1:
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_3=None
   if (self.__sparsity is None):
    _a_2 = numpy.array([self.__basevar_nativeidxs[_a_0[_a_4]] for _a_4 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   else:
    _a_5=0
    for _a_6 in range(0,int((_a_0).shape[0])):
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_a_0[_a_6]) >= 0):
      _a_5 += 1
    _a_2 = numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int64))
    _a_3 = numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int64))
    _a_7=0
    for _a_8 in range(0,int((_a_0).shape[0])):
     _a_9=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_a_0[_a_8])
     if (_a_9 >= 0):
      _a_3[_a_7] = _a_8
      _a_2[_a_7] = self.__basevar_nativeidxs[_a_9]
      _a_7 += 1
    if (_a_5==int((_a_0).shape[0])):
     _a_3 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32)),_a_3,_a_2))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _antidiag_alt_I(self,_t__a_0):
    return self._antidiag_I(numpy.int32(__a_0))
  def _antidiag_I(self,_a_0):
   if (int((self.__shape).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   elif ((_a_0 >= self.__shape[1]) or ((- _a_0) >= self.__shape[2])):
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_a_0 >= 0):
    return (self.__general_1diag__3I_3II(numpy.array([0,((self.__shape[1] - 1) - _a_0)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _a_0)) ) else (self.__shape[1] - _a_0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _a_0),(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _a_0)) ) else (self.__shape[0] + _a_0))))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   if (int((self.__shape).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _diag_alt_I(self,_t__a_0):
    return self._diag_I(numpy.int32(__a_0))
  def _diag_I(self,_a_0):
   if (int((self.__shape).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   elif ((_a_0 >= self.__shape[1]) or ((- _a_0) >= self.__shape[2])):
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_a_0 >= 0):
    return (self.__general_1diag__3I_3II(numpy.array([0,_a_0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _a_0)) ) else (self.__shape[1] - _a_0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _a_0),0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _a_0)) ) else (self.__shape[0] + _a_0))))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   if (int((self.__shape).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  def __general_1diag_alt__3I_3II(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self.__general_1diag__3I_3II(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __general_1diag__3I_3II(self,_a_0,_a_1,_a_2):
   _a_3=int((self.__shape).shape[0])
   if ((_a_3!=int((_a_0).shape[0])) or (_a_3!=int((_a_1).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid start or step definition")
   for _a_4 in range(0,_a_3):
    if ((_a_0[_a_4] < 0) or (_a_0[_a_4] >= self.__shape[_a_4])):
     raise mosek_fusion_LengthError._ctor_S("Start element is out of bounds")
   _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_5[(_a_3 - 1)] = 1
   fragments._c_closure_180(_a_3,self.__shape,_a_5) 
   _a_6=0
   _a_6 = fragments._c_closure_181(_a_0,_a_6,_a_1,_a_5)
   _a_6 = numpy.int64(_a_6) # postprocess
   _a_7=0
   _a_7 = fragments._c_closure_182(_a_1,_a_7,_a_5)
   _a_7 = numpy.int64(_a_7) # postprocess
   if (self.__sparsity is None):
    _a_8=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_183(self.__basevar_nativeidxs,_a_2,_a_8,_a_6,_a_7) 
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_a_2], dtype=numpy.dtype(numpy.int32)),None,_a_8))
   else:
    _a_9=0
    for _a_10 in range(0,_a_2):
     _a_11=(_a_6 + (_a_7 * _a_10))
     _a_12=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_a_11)
     if (_a_12 >= 0):
      _a_9 += 1
    _a_13=numpy.zeros((_a_9,), dtype=numpy.dtype(numpy.int64))
    _a_14=numpy.zeros((_a_9,), dtype=numpy.dtype(numpy.int64))
    _a_15=0
    for _a_16 in range(0,_a_2):
     _a_13[_a_16] = self.__basevar_nativeidxs[(_a_6 + (_a_7 * _a_16))]
     _a_17=(_a_6 + (_a_7 * _a_16))
     _a_18=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_a_17)
     if (_a_18 >= 0):
      _a_14[_a_15] = _a_16
      _a_13[_a_15] = self.__basevar_nativeidxs[_a_18]
      _a_15 += 1
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_a_2], dtype=numpy.dtype(numpy.int32)),_a_14,_a_13))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   if (int((_a_0).shape[0])!=int((_a_1).shape[0])):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (int((_a_0).shape[0])!=int((self.__shape).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   else:
    for _a_2 in range(0,int((self.__shape).shape[0])):
     if ((_a_0[_a_2] < 0) or (_a_1[_a_2] > self.__shape[_a_2])):
      raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
     elif (_a_0[_a_2] > _a_1[_a_2]):
      raise mosek_fusion_SliceError._ctor_S("Invalid slice")
    _a_3=int((self.__shape).shape[0])
    _a_4=numpy.array([(_a_1[_a_5] - _a_0[_a_5]) for _a_5 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32))
    _a_6=1
    _a_6 = fragments._c_closure_184(_a_0,_a_1,_a_3,_a_6)
    _a_6 = numpy.int32(_a_6) # postprocess
    if (_a_6==0):
     return (mosek_fusion_NilVariable._ctor_())
    elif (self.__sparsity is not None):
     _a_7=0
     _a_8=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
     _a_7 = fragments._c_closure_185(_a_0,_a_8,_a_1,_a_3,_a_7,self.__shape,self.__sparsity)
     _a_7 = numpy.int32(_a_7) # postprocess
     _a_9=0
     _a_10=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
     _a_11=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
     _a_9 = fragments._c_closure_186(self.__basevar_nativeidxs,_a_0,_a_9,_a_10,_a_8,_a_1,_a_3,self.__shape,_a_4,_a_11,self.__sparsity)
     _a_9 = numpy.int32(_a_9) # postprocess
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_4,_a_11,_a_10))
    else:
     _a_12=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int64))
     fragments._c_closure_187(self.__basevar_nativeidxs,_a_0,_a_1,_a_3,self.__shape,_a_12,_a_6) 
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_a_4,None,_a_12))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   if (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_a_0==0) and (_a_1==self.__shape[0])):
    return (self)
   elif ((_a_0 < 0) or (_a_1 > self.__shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_a_0 > _a_1):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (_a_0==_a_1):
    return (mosek_fusion_NilVariable._ctor_())
   elif (self.__sparsity is not None):
    _a_2=(_a_1 - _a_0)
    _a_3=0
    _a_4=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_a_0)
    _a_5=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_a_1)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_a_2], dtype=numpy.dtype(numpy.int32)),numpy.array([(self.__sparsity[_a_6] - _a_0) for _a_6 in range(_a_4,_a_5)], dtype=numpy.dtype(numpy.int64)),numpy.array([self.__basevar_nativeidxs[_a_7] for _a_7 in range(_a_4,_a_5)], dtype=numpy.dtype(numpy.int64))))
   else:
    _a_8=(_a_1 - _a_0)
    _a_9=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.__basevar_nativeidxs,_a_0,_a_9,0,_a_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_a_8], dtype=numpy.dtype(numpy.int32)),None,_a_9))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprFromVar._ctor_Lmosek_4fusion_4Variable_2(self))
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_I__(_a_2) and __arg_match__3J__(_a_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match__3J__(_a_3))
  def _inst_alt_I_3JI_3J(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int64))
   _1_res = self._inst_I_3JI_3J(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _inst_I_3JI_3J(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=(self.__basevar_nativeidxs)
   _a_5=(self.__sparsity)
   if (_a_5 is None):
    fragments._c_closure_188(_a_3,_a_2,_a_1,_a_0,_a_4) 
   else:
    for _a_6 in range(0,int(((self.__sparsity)).shape[0])):
     _a_1[(_a_0 + _a_6)] = _a_5[_a_6]
     _a_3[(_a_6 + _a_2)] = _a_4[_a_6]
   return numpy.int32(int(((self.__basevar_nativeidxs)).shape[0]))
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(int((self.__basevar_nativeidxs).shape[0]))
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1))
  def _inst_alt_I_3J(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _1_res = self._inst_I_3J(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _inst_I_3J(self,_a_0,_a_1):
   if (self.__sparsity is None):
    fragments._c_closure_189(self.__basevar_nativeidxs,_a_1,_a_0) 
   else:
    _a_2=self._getShape_()
    _a_3=1
    _a_3 = fragments._c_closure_190(_a_3,_a_2)
    _a_3 = numpy.int32(_a_3) # postprocess
    fragments._c_closure_191(_a_3,_a_1,_a_0) 
    fragments._c_closure_192(self.__basevar_nativeidxs,_a_1,_a_0,self.__sparsity) 
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Z__(_a_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Z__(_a_1))
  def _set_1values_alt__3DZ(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = self._set_1values__3DZ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _set_1values__3DZ(self,_a_0,_a_1):
   if (self.__sparsity is None):
    self._getModel_()._setVariableValues_Z_3J_3D(_a_1,self.__basevar_nativeidxs,_a_0)
   else:
    _a_2=1
    _a_2 = fragments._c_closure_193(self.__shape,_a_2)
    _a_2 = numpy.int32(_a_2) # postprocess
    _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_194(self.__basevar_nativeidxs,_a_3,self.__sparsity) 
    self._getModel_()._setVariableValues_Z_3J_3D(_a_1,_a_3,_a_0)
  def _dual_1lu_alt_I_3DZ(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = self._dual_1lu_I_3DZ(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _dual_1lu_I_3DZ(self,_a_0,_a_1,_a_2):
   if (self.__sparsity is None):
    self.__model._getVariableDuals_Z_3J_3DI(_a_2,self.__basevar_nativeidxs,_a_1,_a_0)
   else:
    _a_3=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_195(self.__basevar_nativeidxs,_a_3,self.__sparsity) 
    self.__model._getVariableDuals_Z_3J_3DI(_a_2,_a_3,_a_1,_a_0)
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3D__(_a_1) and __arg_match_Z__(_a_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match_Z__(_a_2))
  def _values_alt_I_3DZ(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = self._values_I_3DZ(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _values_I_3DZ(self,_a_0,_a_1,_a_2):
   if (self.__sparsity is None):
    self.__model._getVariableValues_Z_3J_3DI(_a_2,self.__basevar_nativeidxs,_a_1,_a_0)
   else:
    _a_3=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_196(self.__basevar_nativeidxs,_a_3,self.__sparsity) 
    self.__model._getVariableValues_Z_3J_3DI(_a_2,_a_3,_a_1,_a_0)
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   self._getModel_()._make_1continuous__3J(self.__basevar_nativeidxs)
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   self._getModel_()._make_1integer__3J(self.__basevar_nativeidxs)
 return BaseVariable
mosek_fusion_BaseVariable=__mk_mosek_fusion_BaseVariable()
del __mk_mosek_fusion_BaseVariable
#BEFORE CLASS
def __mk_mosek_fusion_SliceVariable():
 class SliceVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_SliceVariable__shape','_SliceVariable__sparsity','_SliceVariable__nativeidxs']
  def __repr__(self): return 'mosek.fusion.SliceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceVariable_2(v):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4SliceVariable_2(v)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceVariable_2(*args):
    if len(args) != 1: return False
    v, = args
    return (__arg_match_Lmosek_4fusion_4SliceVariable_2__(v))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceVariable_2(*args):
    if len(args) != 1: return False
    v, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v))
  def _ctor_alt_init_Lmosek_4fusion_4SliceVariable_2(self,v):
    self._ctor_init_Lmosek_4fusion_4SliceVariable_2(v)
  def _ctor_init_Lmosek_4fusion_4SliceVariable_2(self,v):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,v._getModel_())
   (self.__nativeidxs) = (v.__nativeidxs)
   (self.__sparsity) = (v.__sparsity)
   (self.__shape) = (v.__shape)
 return SliceVariable
mosek_fusion_SliceVariable=__mk_mosek_fusion_SliceVariable()
del __mk_mosek_fusion_SliceVariable
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceVariable():
 class BoundInterfaceVariable(mosek_fusion_SliceVariable):
  __slots__ = ['_BoundInterfaceVariable__islower']
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceVariable.slice(int32,int32)
      mosek.fusion.BoundInterfaceVariable.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    first : int32
    firsta : array(int32,ndim=1)
    last : int32
    lasta : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.slice(int32,int32)\n\tmosek.fusion.BoundInterfaceVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def antidiag(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceVariable.antidiag()
      mosek.fusion.BoundInterfaceVariable.antidiag(int32)

    Description
    -----------

    

    Parameters
    ----------

    index : int32
    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_antidiag_(*args):
      return self._antidiag_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_antidiag_(*args):
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_antidiag_I(*args):
      return self._antidiag_I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_antidiag_I(*args):
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.antidiag()\n\tmosek.fusion.BoundInterfaceVariable.antidiag(int32)')
  def diag(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceVariable.diag()
      mosek.fusion.BoundInterfaceVariable.diag(int32)

    Description
    -----------

    

    Parameters
    ----------

    index : int32
    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_diag_(*args):
      return self._diag_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_diag_(*args):
      return self._diag_alt_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_diag_I(*args):
      return self._diag_I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_diag_I(*args):
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.diag()\n\tmosek.fusion.BoundInterfaceVariable.diag(int32)')
  def dual(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceVariable.dual()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_dual_(*args):
      return self._dual_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_dual_(*args):
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.dual()')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceVariable.transpose()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.transpose()')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1))
      mosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=2))
      mosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1))
      mosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    i0 : array(int32,ndim=1)
    i1 : array(int32,ndim=1)
    i2 : array(int32,ndim=1)
    idxs : array(int32,ndim=1)
    midxs : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I_3I(*args):
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I_3I(*args):
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I_3I_3I(*args):
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I_3I_3I(*args):
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BoundInterfaceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,shape,sparsity,nativeidxs,islower):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,shape,sparsity,nativeidxs,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(*args):
    if len(args) != 5: return False
    m,shape,sparsity,nativeidxs,islower, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(*args):
    if len(args) != 5: return False
    m,shape,sparsity,nativeidxs,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self,m,shape,sparsity,nativeidxs,islower):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)),islower)
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self,m,shape,sparsity,nativeidxs,islower):
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__islower) = islower
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceVariable_2Z(v,islower):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4SliceVariable_2Z(v,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceVariable_2Z(*args):
    if len(args) != 2: return False
    v,islower, = args
    return (__arg_match_Lmosek_4fusion_4SliceVariable_2__(v) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceVariable_2Z(*args):
    if len(args) != 2: return False
    v,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4SliceVariable_2Z(self,v,islower):
    self._ctor_init_Lmosek_4fusion_4SliceVariable_2Z(v,islower)
  def _ctor_init_Lmosek_4fusion_4SliceVariable_2Z(self,v,islower):
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4SliceVariable_2(self,v)
   (self.__islower) = islower
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _a_0=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
   self._dual_1lu_I_3DZ(0,_a_0,self.__islower)
   return (_a_0)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._transpose_(self)))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3I__(_a_2))
  def _pick_alt__3I_3I_3I(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I_3I_3I(self,_a_0,_a_1,_a_2):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I_3I_3I(self,_a_0,_a_1,_a_2)))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _pick_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I_3I(self,_a_0,_a_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I_3I(self,_a_0,_a_1)))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3_5I(self,_a_0)))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I(self,_a_0)))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _antidiag_alt_I(self,_t__a_0):
    return self._antidiag_I(numpy.int32(__a_0))
  def _antidiag_I(self,_a_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._antidiag_I(self,_a_0)))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._antidiag_(self)))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _diag_alt_I(self,_t__a_0):
    return self._diag_I(numpy.int32(__a_0))
  def _diag_I(self,_a_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._diag_I(self,_a_0)))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._diag_(self)))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._slice__3I_3I(self,_a_0,_a_1)))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._slice_II(self,_a_0,_a_1)))
  def __from_1_alt_Lmosek_4fusion_4Variable_2(self,_t__a_0):
    return self.__from_1_Lmosek_4fusion_4Variable_2(_a_0)
  def __from_1_Lmosek_4fusion_4Variable_2(self,_a_0):
   _a_1=self._getShape_()
   _a_2=_a_0._numInst_()
   _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   _a_4=None
   if (_a_0._getSize_()==_a_2):
    _a_0._inst_I_3J(0,_a_3)
   else:
    _a_4 = numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    _a_0._inst_I_3JI_3J(0,_a_4,0,_a_3)
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(_a_0._getModel_(),_a_1,_a_4,_a_3,self.__islower))
 return BoundInterfaceVariable
mosek_fusion_BoundInterfaceVariable=__mk_mosek_fusion_BoundInterfaceVariable()
del __mk_mosek_fusion_BoundInterfaceVariable
#BEFORE CLASS
def __mk_mosek_fusion_ModelVariable():
 class ModelVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_ModelVariable__sparsity','_ModelVariable__shape','_ModelVariable__modelvar_nativeidxs','_ModelVariable__varid','_ModelVariable__name']
  def elementName(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)

    Description
    -----------

    

    Parameters
    ----------

    index : int64
    sb : mosek.fusion.Utils.StringBuffer
    '''
    if False: pass
    elif mosek_fusion_ModelVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ModelVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def remove(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ModelVariable.remove()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ModelVariable._match_remove_(*args):
      return self._remove_(*args)
    elif mosek_fusion_ModelVariable._match_alt_remove_(*args):
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.remove()')
  def __repr__(self): return 'mosek.fusion.ModelVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__varid = (v.__varid)
   self.__modelvar_nativeidxs = (v.__modelvar_nativeidxs)
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,modelvar_nativeidxs):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,modelvar_nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,modelvar_nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match_J__(varid) and __arg_match__3J__(sparsity) and __arg_match__3J__(modelvar_nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,modelvar_nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match_J__(varid) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(modelvar_nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,modelvar_nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(modelvar_nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,modelvar_nativeidxs):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,model,shape,sparsity,modelvar_nativeidxs)
   (self.__name) = name
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__modelvar_nativeidxs) = modelvar_nativeidxs
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_J__(_a_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_J__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   _a_1._a_S(("_" if ((int(len(self.__name))==0) ) else self.__name))._a_S("[")._a_S(mosek.fusion.Set._indexToString__3IJ(self.__shape,_a_0))._a_S("]")
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   self._getModel_()._removeVariableBlock_J(self.__varid)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   pass
 return ModelVariable
mosek_fusion_ModelVariable=__mk_mosek_fusion_ModelVariable()
del __mk_mosek_fusion_ModelVariable
#BEFORE CLASS
def __mk_mosek_fusion_RangedVariable():
 class RangedVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_RangedVariable__shape','_RangedVariable__name','_RangedVariable__nativeidxs','_RangedVariable__sparsity']
  def upperBoundVar(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangedVariable.upperBoundVar()

    Description
    -----------

    Obtain the interface to the variable's upper bound. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RangedVariable._match_upperBoundVar_(*args):
      return self._upperBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_upperBoundVar_(*args):
      return self._upperBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.upperBoundVar()')
  def lowerBoundVar(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangedVariable.lowerBoundVar()

    Description
    -----------

    Obtain the interface to the variable's lower bound. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RangedVariable._match_lowerBoundVar_(*args):
      return self._lowerBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_lowerBoundVar_(*args):
      return self._lowerBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.lowerBoundVar()')
  def elementDesc(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)

    Description
    -----------

    

    Parameters
    ----------

    index : int64
    sb : mosek.fusion.Utils.StringBuffer
    '''
    if False: pass
    elif mosek_fusion_RangedVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RangedVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.RangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__shape = (v.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.RangedVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__name) = name
   (self.__shape) = shape
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_J__(_a_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_J__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_a_0,_a_1)
   _a_1._a_S(" : in range")
   return (_a_1)
  def _dual_1u_alt_I_3D(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = self._dual_1u_I_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _dual_1u_I_3D(self,_a_0,_a_1):
   self._dual_1lu_I_3DZ(_a_0,_a_1,False)
  def _dual_1l_alt_I_3D(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = self._dual_1l_I_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _dual_1l_I_3D(self,_a_0,_a_1):
   self._dual_1lu_I_3DZ(_a_0,_a_1,True)
  @staticmethod
  def _match_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundVar_alt_(self,):
    return self._upperBoundVar_()
  def _upperBoundVar_(self,):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self._getModel_(),self.__shape,self.__sparsity,numpy.array([self.__nativeidxs[_a_0] for _a_0 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int64)),False))
  @staticmethod
  def _match_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundVar_alt_(self,):
    return self._lowerBoundVar_()
  def _lowerBoundVar_(self,):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self._getModel_(),self.__shape,self.__sparsity,numpy.array([self.__nativeidxs[_a_0] for _a_0 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int64)),True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_RangedVariable.__globalNativeIndexes__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __globalNativeIndexes__3I(_a_0):
   _a_1=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_197(_a_0,_a_1) 
   return (_a_1)
 return RangedVariable
mosek_fusion_RangedVariable=__mk_mosek_fusion_RangedVariable()
del __mk_mosek_fusion_RangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDVariable():
 class LinearPSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearPSDVariable__shape','_LinearPSDVariable__name','_LinearPSDVariable__varid','_LinearPSDVariable__nativeidxs','_LinearPSDVariable__conedim']
  def make_continuous(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearPSDVariable.make_continuous()
      mosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    idxs : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous_(*args):
      return self._make_1continuous_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous_(*args):
      return self._make_1continuous_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous__3J(*args):
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous__3J(*args):
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_continuous()\n\tmosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearPSDVariable.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.toString()')
  def make_integer(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearPSDVariable.make_integer()
      mosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    idxs : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1integer_(*args):
      return self._make_1integer_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer_(*args):
      return self._make_1integer_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1integer__3J(*args):
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer__3J(*args):
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_integer()\n\tmosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.LinearPSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   (self.__conedim) = (v.__conedim)
   (self.__varid) = (v.__varid)
   (self.__name) = (v.__name)
   (self.__shape) = (v.__shape)
   (self.__nativeidxs) = (v.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.LinearPSDVariable.__globalNativeIndexes__3J(nativeidxs))
   (self.__name) = name
   (self.__conedim) = conedim
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0):
    _a_0._a_S("'")._a_S(self.__name)._a_S("',")
   _a_0._a_I(self.__shape[0])
   for _a_1 in range(1,int((self.__shape).shape[0])):
    _a_0._a_S(",")._a_I(self.__shape[_a_1])
   _a_0._a_S(")")
   return (_a_0._toString_())
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3J__(_a_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3J__(_a_0))
  def _make_1continuous_alt__3J(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _1_res = self._make_1continuous__3J(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _make_1continuous__3J(self,_a_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3J__(_a_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3J__(_a_0))
  def _make_1integer_alt__3J(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _1_res = self._make_1integer__3J(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _make_1integer__3J(self,_a_0):
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def __globalNativeIndexes_alt__3J(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_LinearPSDVariable.__globalNativeIndexes__3J(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __globalNativeIndexes__3J(_a_0):
   return (numpy.array([(- (_a_0[_a_1] + 1)) for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
 return LinearPSDVariable
mosek_fusion_LinearPSDVariable=__mk_mosek_fusion_LinearPSDVariable()
del __mk_mosek_fusion_LinearPSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_PSDVariable():
 class PSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_PSDVariable__model','_PSDVariable__barvaridxs','_PSDVariable__conedim2','_PSDVariable__conedim1','_PSDVariable__shape','_PSDVariable__name','_PSDVariable__nativeidxs','_PSDVariable__varid']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.PSDVariable.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_PSDVariable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_PSDVariable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.toString()')
  def elementDesc(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)

    Description
    -----------

    

    Parameters
    ----------

    index : int64
    sb : mosek.fusion.Utils.StringBuffer
    '''
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.PSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__varid = (v.__varid)
   self.__nativeidxs = (v.__nativeidxs)
   self.__name = (v.__name)
   self.__shape = (v.__shape)
   self.__conedim1 = (v.__conedim1)
   self.__conedim2 = (v.__conedim2)
   self.__model = m
   self.__barvaridxs = (v.__barvaridxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(*args):
    if len(args) != 8: return False
    model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2) and __arg_match__3I__(barvaridxs) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(*args):
    if len(args) != 8: return False
    model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2) and __arg_alt_match__3I__(barvaridxs) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(self,model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2),numpy.array(barvaridxs,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(self,model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.PSDVariable.__fullnativeidxs__3III_3J(shape,conedim1,conedim2,nativeidxs))
   (self.__varid) = varid
   (self.__nativeidxs) = nativeidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim1) = conedim1
   (self.__conedim2) = conedim2
   (self.__model) = model
   (self.__barvaridxs) = barvaridxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0):
    _a_0._a_S("'")._a_S(self.__name)._a_S("',")
   _a_0._a_I(self.__shape[0])
   for _a_1 in range(1,int((self.__shape).shape[0])):
    _a_0._a_S(",")._a_I(self.__shape[_a_1])
   _a_0._a_S(")")
   return (_a_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_J__(_a_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_J__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_a_0,_a_1)
   _a_1._a_S(" : element in positive semidefinite cone")
   return (_a_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def __fullnativeidxs_alt__3III_3J(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_PSDVariable.__fullnativeidxs__3III_3J(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __fullnativeidxs__3III_3J(_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_0).shape[0])
   _a_5=(_a_1 < _a_2)
   _a_6=(_a_1 if (_a_5 ) else _a_2)
   _a_7=(_a_1 if ((not _a_5) ) else _a_2)
   _a_8=1
   _a_8 = fragments._c_closure_198(_a_6,_a_8,_a_0)
   _a_8 = numpy.int32(_a_8) # postprocess
   _a_9=_a_0[_a_6]
   _a_10=1
   _a_10 = fragments._c_closure_199(_a_6,_a_7,_a_10,_a_0)
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_11=_a_0[_a_7]
   _a_12=1
   _a_12 = fragments._c_closure_200(_a_7,_a_12,_a_4,_a_0)
   _a_12 = numpy.int32(_a_12) # postprocess
   _a_13=((((_a_8 * _a_9) * _a_10) * _a_11) * _a_12)
   _a_14=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int64))
   _a_15=_a_12
   _a_16=(_a_15 * _a_11)
   _a_17=(_a_16 * _a_10)
   _a_18=(_a_17 * _a_17)
   fragments._c_closure_201(_a_8,_a_9,_a_10,_a_11,_a_12,_a_3,_a_14,_a_18,_a_17,_a_16,_a_15) 
   return (_a_14)
 return PSDVariable
mosek_fusion_PSDVariable=__mk_mosek_fusion_PSDVariable()
del __mk_mosek_fusion_PSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearVariable():
 class LinearVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearVariable__shape','_LinearVariable__sparsity','_LinearVariable__nativeidxs','_LinearVariable__name']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearVariable.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinearVariable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_LinearVariable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.toString()')
  def __repr__(self): return 'mosek.fusion.LinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__shape = (v.__shape)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.LinearVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("LinearVariable((")
   if (int((self.__shape).shape[0]) > 0):
    _a_0._a_I(self.__shape[0])
    for _a_1 in range(1,int((self.__shape).shape[0])):
     _a_0._a_S(",")._a_I(self.__shape[_a_1])
   _a_0._a_S(")")
   if (self.__sparsity is not None):
    _a_0._a_S(",sparse")
   _a_0._a_S(")")
   return (_a_0._toString_())
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_LinearVariable.__globalNativeIndexes__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __globalNativeIndexes__3I(_a_0):
   _a_1=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_202(_a_0,_a_1) 
   return (_a_1)
 return LinearVariable
mosek_fusion_LinearVariable=__mk_mosek_fusion_LinearVariable()
del __mk_mosek_fusion_LinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_ConicVariable():
 class ConicVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_ConicVariable__nativeidxs','_ConicVariable__shape','_ConicVariable__name','_ConicVariable__varid']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConicVariable.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ConicVariable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ConicVariable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.toString()')
  def __repr__(self): return 'mosek.fusion.ConicVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__shape = (v.__shape)
   self.__nativeidxs = (v.__nativeidxs)
   self.__shape = (v.__shape)
   self.__varid = (v.__varid)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.ConicVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__name) = name
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("ConicVariable( ")
   if (int(len(self.__name)) > 0):
    _a_0._a_S("'")._a_S(self.__name)._a_S("',")
   _a_0._a_S("(")
   _a_0._a_I(self.__shape[0])
   for _a_1 in range(1,int((self.__shape).shape[0])):
    _a_0._a_S(",")._a_I(self.__shape[_a_1])
   _a_0._a_S(") )")
   return (_a_0._toString_())
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ConicVariable.__globalNativeIndexes__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __globalNativeIndexes__3I(_a_0):
   _a_1=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_203(_a_0,_a_1) 
   return (_a_1)
 return ConicVariable
mosek_fusion_ConicVariable=__mk_mosek_fusion_ConicVariable()
del __mk_mosek_fusion_ConicVariable
#BEFORE CLASS
def __mk_mosek_fusion_NilVariable():
 class NilVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_NilVariable__shape']
  def numInst(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.numInst()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_numInst_(*args):
      return self._numInst_(*args)
    elif mosek_fusion_NilVariable._match_alt_numInst_(*args):
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.numInst()')
  def make_continuous(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.make_continuous()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1continuous_(*args):
      return self._make_1continuous_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1continuous_(*args):
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_continuous()')
  def elementDesc(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)

    Description
    -----------

    

    Parameters
    ----------

    index : int64
    sb : mosek.fusion.Utils.StringBuffer
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)

    Description
    -----------

    

    Parameters
    ----------

    offset : int32
    primal : bool
    target : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_values_I_3DZ(*args):
      return self._values_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_I_3DZ(*args):
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.slice(int32,int32)
      mosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    first : array(int32,ndim=1)
    last : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_NilVariable._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_NilVariable._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.slice(int32,int32)\n\tmosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def elementName(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)

    Description
    -----------

    

    Parameters
    ----------

    index : int64
    sb : mosek.fusion.Utils.StringBuffer
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def make_integer(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.make_integer()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1integer_(*args):
      return self._make_1integer_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1integer_(*args):
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_integer()')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_NilVariable._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.toString()')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.index(int32)
      mosek.fusion.NilVariable.index(array(int32,ndim=1))
      mosek.fusion.NilVariable.index(int32,int32)
      mosek.fusion.NilVariable.index(int32,int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    first : array(int32,ndim=1)
    i0 : int32
    i1 : int32
    i2 : int32
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_NilVariable._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_NilVariable._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_NilVariable._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    elif mosek_fusion_NilVariable._match_index_II(*args):
      return self._index_II(*args)
    elif mosek_fusion_NilVariable._match_alt_index_II(*args):
      return self._index_alt_II(*args)
    elif mosek_fusion_NilVariable._match_index_III(*args):
      return self._index_III(*args)
    elif mosek_fusion_NilVariable._match_alt_index_III(*args):
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.index(int32)\n\tmosek.fusion.NilVariable.index(array(int32,ndim=1))\n\tmosek.fusion.NilVariable.index(int32,int32)\n\tmosek.fusion.NilVariable.index(int32,int32,int32)')
  def set_values(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.set_values(array(double,ndim=1),bool)

    Description
    -----------

    

    Parameters
    ----------

    primal : bool
    target : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_set_1values__3DZ(*args):
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values__3DZ(*args):
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.set_values(array(double,ndim=1),bool)')
  def inst(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.NilVariable.inst(int32,array(int64,ndim=1))
      mosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),array(int64,ndim=1))
      mosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    basevar_nativeidxs : array(int64,ndim=1)
    nindex : array(int64,ndim=1)
    nioffset : int32
    offset : int32
    sparsity : array(int64,ndim=1)
    spoffset : int32
    '''
    if False: pass
    elif mosek_fusion_NilVariable._match_inst_I_3J(*args):
      return self._inst_I_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J(*args):
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3J_3J(*args):
      return self._inst_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J_3J(*args):
      return self._inst_alt_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3JI_3J(*args):
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3JI_3J(*args):
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NilVariable'
  @staticmethod
  def _ctor__3I(shape):
    o = NilVariable.__new__(NilVariable)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,None,mosek.fusion.Utils.Tools._arraycopy__3I(shape),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)))
   (self.__shape) = numpy.array([shape[_a_0] for _a_0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_():
    o = NilVariable.__new__(NilVariable)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_NilVariable._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_J__(_a_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_J__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   return (_a_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_J__(_a_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_J__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_a_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3J__(_a_2))
  @staticmethod
  def _match_alt_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3J__(_a_2))
  def _inst_alt_I_3J_3J(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _1_res = self._inst_I_3J_3J(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _inst_I_3J_3J(self,_a_0,_a_1,_a_2):
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1))
  def _inst_alt_I_3J(self,_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _1_res = self._inst_I_3J(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _inst_I_3J(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Z__(_a_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Z__(_a_1))
  def _set_1values_alt__3DZ(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = self._set_1values__3DZ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _set_1values__3DZ(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3D__(_a_1) and __arg_match_Z__(_a_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match_Z__(_a_2))
  def _values_alt_I_3DZ(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = self._values_I_3DZ(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _values_I_3DZ(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("NilVariable")
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _a_1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _a_1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   if ((int((self.__shape).shape[0])!=int((_a_0).shape[0])) or (int((self.__shape).shape[0])!=int((_a_1).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   for _a_2 in range(0,int((_a_0).shape[0])):
    if ((_a_1[_a_2] > _a_0[_a_2]) or ((_a_0[_a_2] < 0) or (_a_1[_a_2] >= self.__shape[_a_2]))):
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_a_1[_a_3] - _a_0[_a_3]) for _a_3 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   if ((_a_1 > _a_0) or ((_a_0 < 0) or (_a_1 > self.__shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   elif (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   else:
    return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_a_1 - _a_0)], dtype=numpy.dtype(numpy.int32))))
 return NilVariable
mosek_fusion_NilVariable=__mk_mosek_fusion_NilVariable()
del __mk_mosek_fusion_NilVariable
#BEFORE CLASS
def __mk_mosek_fusion_Var():
 class Var(object):
  @staticmethod
  def compress(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.compress(mosek.fusion.Variable)

    Description
    -----------

    Reshape a variable object by removing all dimensions of size 1. 

    Parameters
    ----------

    v : mosek.fusion.Variable
    '''
    if False: pass
    elif mosek_fusion_Var._match_compress_Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._compress_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list compress('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.compress(mosek.fusion.Variable)')
  @staticmethod
  def reshape(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))
      mosek.fusion.Var.reshape(mosek.fusion.Variable,int32)
      mosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)

    Description
    -----------

    Reshape a variable object. 

    Parameters
    ----------

    d1 : int32
        Size of first dimension in the result.
    d2 : int32
        Size of second dimension in the result.
    shape : array(int32,ndim=1)
        An array containing the shape of the new variable.
    v : mosek.fusion.Variable
        A variable object.
    '''
    if False: pass
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2II(*args):
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def vrepeat(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)

    Description
    -----------

    Repeat a variable a number of times in the first dimension.

    Parameters
    ----------

    n : int32
        Number of times to repeat ``v``.
    v : mosek.fusion.Variable
        A variable object.
    '''
    if False: pass
    elif mosek_fusion_Var._match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._vrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list vrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def flatten(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.flatten(mosek.fusion.Variable)

    Description
    -----------

    Create a one-dimensional logical view of a variable object.

    Parameters
    ----------

    v : mosek.fusion.Variable
    '''
    if False: pass
    elif mosek_fusion_Var._match_flatten_Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._flatten_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.flatten(mosek.fusion.Variable)')
  @staticmethod
  def hstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))
      mosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)
      mosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)

    Description
    -----------

    Stack three variables in second dimension. 

    Parameters
    ----------

    v : array(mosek.fusion.Variable,ndim=1)
        List of variables to stack.
    v1 : mosek.fusion.Variable
        First variable in the stack.
    v2 : mosek.fusion.Variable
        Second variable in the stack.
    v3 : mosek.fusion.Variable
        Third variable in the stack.
    '''
    if False: pass
    elif mosek_fusion_Var._match_hstack__3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._hstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def repeat(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.repeat(mosek.fusion.Variable,int32)
      mosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)

    Description
    -----------

    Repeat a variable a number of times in the given dimension.

    Parameters
    ----------

    dim : int32
        Dimension to repeat in. 
    n : int32
        Number of times to repeat ``v``.
    v : mosek.fusion.Variable
        A variable object.
    '''
    if False: pass
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2II(*args):
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def stack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))
      mosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)
      mosek.fusion.Var.stack(int32,array(mosek.fusion.Variable,ndim=1))
      mosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)
      mosek.fusion.Var.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable)
      mosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)
      mosek.fusion.Var.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)

    Description
    -----------

    Create a stacked variable. 

    Parameters
    ----------

    dim : int32
        Dimension in which to stack.
    v : array(mosek.fusion.Variable,ndim=1)
        List of variables to stack.
    v1 : mosek.fusion.Variable
        First variable in the stack.
    v2 : mosek.fusion.Variable
        Second variable in the stack.
    v3 : mosek.fusion.Variable
        Third variable in the stack.
    vlist : array(array(mosek.fusion.Variable,ndim=1),ndim=1)
        List of variables to stack.
    '''
    if False: pass
    elif mosek_fusion_Var._match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_alt__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack__3Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._stack_alt__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_I_3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_I_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack_I_3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_alt_I_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))\n\tmosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)\n\tmosek.fusion.Var.stack(int32,array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def hrepeat(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)

    Description
    -----------

    Repeat a variable a number of times in the second dimension.

    Parameters
    ----------

    n : int32
        Number of times to repeat ``v``.
    v : mosek.fusion.Variable
        A variable object.
    '''
    if False: pass
    elif mosek_fusion_Var._match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._hrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list hrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def vstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))
      mosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)
      mosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)

    Description
    -----------

    Stack three variables. 

    Parameters
    ----------

    v : array(mosek.fusion.Variable,ndim=1)
        List of variables to stack.
    v1 : mosek.fusion.Variable
        First variable in the stack.
    v2 : mosek.fusion.Variable
        Second variable in the stack.
    v3 : mosek.fusion.Variable
        Third variable in the stack.
    '''
    if False: pass
    elif mosek_fusion_Var._match_vstack__3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._vstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def empty(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.empty(array(int32,ndim=1))

    Description
    -----------

    
    Produce a new empty variable of the given shape.
          

    Parameters
    ----------

    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Var._match_empty__3I(*args):
      return mosek_fusion_Var._empty__3I(*args)
    elif mosek_fusion_Var._match_alt_empty__3I(*args):
      return mosek_fusion_Var._empty_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list empty('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.empty(array(int32,ndim=1))')
  @staticmethod
  def promote(*args):
    '''
    Syntax
    ------

      mosek.fusion.Var.promote(mosek.fusion.Variable,int32)

    Description
    -----------

    Pad variable shape.

    Parameters
    ----------

    nd : int32
    v : mosek.fusion.Variable
    '''
    if False: pass
    elif mosek_fusion_Var._match_promote_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_promote_Lmosek_4fusion_4Variable_2I(*args):
      return mosek_fusion_Var._promote_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list promote('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.promote(mosek.fusion.Variable,int32)')
  def __repr__(self): return 'mosek.fusion.Var'
  @staticmethod
  def _match_empty__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_empty__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _empty_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Var._empty__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _empty__3I(_a_0):
   for _a_1 in range(0,int((_a_0).shape[0])):
    if (_a_0[_a_1] < 0):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
   return (mosek_fusion_NilVariable._ctor__3I(_a_0))
  @staticmethod
  def _match_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _compress_alt_Lmosek_4fusion_4Variable_2(_t__a_0):
    return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(_a_0)
  @staticmethod
  def _compress_Lmosek_4fusion_4Variable_2(_a_0):
   _a_1=_a_0._getShape_()
   _a_2=int((_a_1).shape[0])
   _a_3=0
   _a_3 = fragments._c_closure_204(_a_2,_a_3,_a_1)
   _a_3 = numpy.int32(_a_3) # postprocess
   _a_4=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_205(_a_2,_a_4,_a_1) 
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_a_0,_a_4))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_a_0,numpy.array([_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2II(_a_0,_a_1,_a_2):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_a_0,numpy.array([_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Variable_2(_t__a_0):
    return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(_a_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Variable_2(_a_0):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_a_0,numpy.array([numpy.int32(mosek.fusion.Set._size__3I(_a_0._getShape_()))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2_3I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2_3I(_a_0,_a_1):
   return (_a_0._reshape__3I(_a_1))
  @staticmethod
  def _index_1permute_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Var._index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_a_0,_a_1):
   _a_4=_a_0._getShape_()
   _a_5=int((_a_4).shape[0])
   _a_6=1
   _a_6 = fragments._c_closure_206(_a_5,_a_4,_a_6)
   _a_6 = numpy.int32(_a_6) # postprocess
   _a_7=_a_0._numInst_()
   _a_8=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int64))
   _a_8[(_a_5 - 1)] = 1
   fragments._c_closure_207(_a_5,_a_1,_a_8,_a_4) 
   if (_a_7 < _a_6):
    _a_2 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_3 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_0._inst_I_3JI_3J(0,_a_2,0,_a_3)
   else:
    _a_2 = None
    _a_3 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_0._inst_I_3J(0,_a_3)
   if (_a_2 is None):
    _a_9=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_208(_a_3,_a_5,_a_7,_a_1,_a_8,_a_9,_a_4) 
    _a_3 = _a_9
   else:
    _a_10=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_209(_a_5,_a_7,_a_1,_a_8,_a_10,_a_4) 
    _a_11=numpy.array([_a_12 for _a_12 in range(0,_a_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_11,_a_10,None,0,_a_7)
    _a_2 = numpy.array([_a_2[_a_11[_a_13]] for _a_13 in range(0,_a_7)], dtype=numpy.dtype(numpy.int64))
    _a_3 = numpy.array([_a_3[_a_11[_a_14]] for _a_14 in range(0,_a_7)], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_0._getModel_(),numpy.array([_a_4[_a_1[_a_15]] for _a_15 in range(0,_a_5)], dtype=numpy.dtype(numpy.int32)),_a_2,_a_3))
  @staticmethod
  def _match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _hrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _hrepeat_Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_a_0,1,_a_1))
  @staticmethod
  def _match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _vrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _vrepeat_Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_a_0,0,_a_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_a_0,0,_a_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_a_0,_a_1,_a_2):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_a_0,_a_2,_a_1))
  @staticmethod
  def __drepeat_alt_Lmosek_4fusion_4Variable_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var.__drepeat_Lmosek_4fusion_4Variable_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def __drepeat_Lmosek_4fusion_4Variable_2II(_a_0,_a_1,_a_2):
   if (_a_2 < 0):
    raise mosek_fusion_LengthError._ctor_S("Cannot repeat less than 0 times")
   elif (_a_2==0):
    _a_3=_a_0._getShape_()
    _a_4=_a_3
    if (int((_a_3).shape[0])==_a_1):
     _a_4 = numpy.zeros(((_a_1 + 1),), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_210(_a_1,_a_4,_a_3) 
    _a_4[_a_1] = 0
    mosek.fusion.Debug._o_()._p_S("drepeat dim=")._p_I(_a_1)._p_S(", n=")._p_I(_a_2)._p_S(", shape=")._p__3I(_a_0._getShape_())._p_S(" -> ")._p__3I(_a_4)._lf_()
    return (mosek_fusion_NilVariable._ctor__3I(_a_4))
   elif (_a_2==1):
    _a_5=_a_0._getShape_()
    _a_6=_a_5
    if (int((_a_5).shape[0])==_a_1):
     _a_6 = numpy.zeros(((_a_1 + 1),), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_211(_a_1,_a_6,_a_5) 
     _a_6[_a_1] = 1
    mosek.fusion.Debug._o_()._p_S("drepeat dim=")._p_I(_a_1)._p_S(", n=")._p_I(_a_2)._p_S(", shape=")._p__3I(_a_0._getShape_())._p_S(" -> ")._p__3I(_a_6)._lf_()
    return (_a_0)
   else:
    _a_7=_a_0._getModel_()
    _a_8=_a_0._getShape_()
    _a_9=int((_a_8).shape[0])
    if ((_a_1 < 0) or (_a_1 > _a_9)):
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    _a_10=mosek.fusion.Set._size__3I(_a_8)
    _a_11=_a_0._numInst_()
    _a_12=(_a_11 * _a_2)
    _a_13=1
    _a_13 = fragments._c_closure_212(_a_13,_a_1,_a_8)
    _a_13 = numpy.int32(_a_13) # postprocess
    _a_14=(_a_8[_a_1] if ((_a_1 < _a_9) ) else 1)
    _a_15=(_a_14 * _a_2)
    _a_16=1
    _a_16 = fragments._c_closure_213(_a_16,_a_1,_a_9,_a_8)
    _a_16 = numpy.int32(_a_16) # postprocess
    _a_17=(_a_9 if ((_a_1 < _a_9) ) else (_a_1 + 1))
    _a_18=numpy.zeros((_a_17,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_214(_a_9,_a_18,_a_8) 
    fragments._c_closure_215(_a_9,_a_17,_a_18) 
    _a_18[_a_1] = _a_15
    if (_a_11 < _a_10):
     _a_19=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
     _a_20=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
     _a_21=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int64))
     _a_22=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int64))
     _a_0._inst_I_3JI_3J(0,_a_20,0,_a_19)
     _a_23=(_a_15 * _a_16)
     _a_24=(_a_14 * _a_16)
     _a_25=_a_16
     if (_a_1==0):
      _a_26=0
      _a_26 = fragments._c_closure_216(_a_10,_a_26,_a_2,_a_11,_a_21,_a_22,_a_19,_a_20)
      _a_26 = numpy.int32(_a_26) # postprocess
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_7,_a_18,_a_22,_a_21))
     elif (_a_1 >= _a_9):
      _a_27=0
      _a_27 = fragments._c_closure_217(_a_27,_a_2,_a_11,_a_21,_a_22,_a_19,_a_20)
      _a_27 = numpy.int32(_a_27) # postprocess
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_7,_a_18,_a_22,_a_21))
     else:
      _a_28=0
      _a_28 = fragments._c_closure_218(_a_14,_a_16,_a_28,_a_2,_a_11,_a_23,_a_21,_a_22,_a_24,_a_25,_a_19,_a_20)
      _a_28 = numpy.int32(_a_28) # postprocess
      _a_29=1
      _a_29 = fragments._c_closure_219(_a_29,_a_17,_a_18)
      _a_29 = numpy.int32(_a_29) # postprocess
      _a_30=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
      _a_31=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int32))
      _a_32=numpy.zeros(((_a_29 + 1),), dtype=numpy.dtype(numpy.int32))
      _a_33=numpy.zeros((_a_17,), dtype=numpy.dtype(numpy.int64))
      _a_33[(_a_17 - 1)] = 1
      fragments._c_closure_220(_a_17,_a_18,_a_33) 
      fragments._c_closure_221(_a_30,_a_12) 
      for _a_34 in range(0,_a_17):
       _a_35=((_a_17 - _a_34) - 1)
       fragments._c_closure_222(_a_35,_a_32,_a_18) 
       fragments._c_closure_223(_a_35,_a_32,_a_12,_a_18,_a_22,_a_33) 
       fragments._c_closure_224(_a_35,_a_32,_a_18) 
       fragments._c_closure_225(_a_30,_a_35,_a_32,_a_12,_a_18,_a_22,_a_33,_a_31) 
       _a_36=_a_30
       _a_30 = _a_31
       _a_31 = _a_36
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_7,_a_18,numpy.array([_a_22[_a_30[_a_37]] for _a_37 in range(0,_a_12)], dtype=numpy.dtype(numpy.int64)),numpy.array([_a_21[_a_30[_a_38]] for _a_38 in range(0,_a_12)], dtype=numpy.dtype(numpy.int64))))
    else:
     _a_39=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
     _a_40=numpy.zeros(((_a_11 * _a_2),), dtype=numpy.dtype(numpy.int64))
     _a_0._inst_I_3J(0,_a_39)
     _a_41=(_a_15 * _a_16)
     _a_42=_a_16
     _a_43=0
     _a_43 = fragments._c_closure_226(_a_13,_a_14,_a_16,_a_43,_a_2,_a_40,_a_41,_a_42,_a_39)
     _a_43 = numpy.int32(_a_43) # postprocess
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_7,_a_18,None,_a_40))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Variable_2(_t__a_0):
   _a_0=_monty.makeJaggedArray(_t__a_0,(1,1),numpy.dtype(object))
   _1_res = mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Variable_2(_a_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_a_0[_a_1],1) for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Variable_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Variable_2(_a_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_a_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Variable_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Variable_2(_a_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_a_0,1))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack__3Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   return (mosek.fusion.Var._stack_I_3Lmosek_4fusion_4Variable_2(_a_1,_a_0))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_2) and __arg_alt_match_I__(_a_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_a_0,_a_1,_a_2,numpy.int32(__a_3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Var._stack_I_3Lmosek_4fusion_4Variable_2(_a_3,numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_a_0,_a_1,numpy.int32(__a_2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_a_0,_a_1,_a_2):
   return (mosek.fusion.Var._stack_I_3Lmosek_4fusion_4Variable_2(_a_2,numpy.array([_a_0,_a_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Var._stack_I_3Lmosek_4fusion_4Variable_2(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   _a_2=_a_0
   for _a_3 in range(0,int((_a_1).shape[0])):
    if (_a_2 < _a_1[_a_3]._getND_()):
     _a_2 = _a_1[_a_3]._getND_()
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_a_1,_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__a_0),_a_1,_a_2,_a_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_a_1,_a_2,_a_3], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__a_0),_a_1,_a_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_a_1,_a_2], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _promote_alt_Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _promote_Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   if (_a_1 > _a_0._getND_()):
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    _a_3=_a_0._getShape_()
    fragments._c_closure_227(_a_3,_a_2) 
    fragments._c_closure_228(_a_1,_a_3,_a_2) 
    return (_a_0._reshape__3I(_a_2))
   else:
    return (_a_0)
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Variable_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Var._dstack__3Lmosek_4fusion_4Variable_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Variable_2I(_a_0,_a_1):
   if (_a_1 < 0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   _a_2=None
   for _a_3 in range(0,int((_a_0).shape[0])):
    if (_a_2 is None):
     _a_2 = _a_0[_a_3]._getModel_()
    elif ((_a_0[_a_3]._getModel_() is not None) and (_a_0[_a_3]._getModel_() is not _a_2)):
     _a_4=mosek.fusion.Utils.StringBuffer()
     _a_5=(_a_2._getName_() if ((int(len(_a_2._getName_())) > 0) ) else "?")
     _a_6=(_a_0[_a_3]._getModel_()._getName_() if ((int(len(_a_0[_a_3]._getModel_()._getName_())) > 0) ) else "?")
     _a_4._a_S("Variables belong to different models: '")._a_S(_a_5)._a_S("' and '")._a_S(_a_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_a_4._toString_())
   if (int((_a_0).shape[0])==0):
    return (mosek_fusion_NilVariable._ctor_())
   elif (int((_a_0).shape[0])==1):
    return (_a_0[0])
   else:
    _a_7=int((_a_0).shape[0])
    _a_8=numpy.array([_a_0[_a_9]._numInst_() for _a_9 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
    _a_10=_monty.initJaggedArray([_a_0[_a_11]._getShape_() for _a_11 in range(0,_a_7)], 1)
    _a_12=numpy.array([int((_a_10[_a_13]).shape[0]) for _a_13 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
    _a_14=_a_10[0]
    _a_15=_a_12[0]
    _a_16=0
    _a_16 = fragments._c_closure_229(_a_7,_a_8,_a_16)
    _a_16 = numpy.int32(_a_16) # postprocess
    _a_17=(_a_1 + 1)
    _a_17 = fragments._c_closure_230(_a_7,_a_12,_a_17)
    _a_17 = numpy.int32(_a_17) # postprocess
    _a_18=numpy.zeros((_a_17,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_231(_a_15,_a_18,_a_14) 
    fragments._c_closure_232(_a_15,_a_17,_a_18) 
    _a_18[_a_1] = 0
    fragments._c_closure_233(_a_1,_a_7,_a_18,_a_10) 
    for _a_19 in range(0,_a_7):
     for _a_20 in range(0,int((_a_10[_a_19]).shape[0])):
      if ((_a_20!=_a_1) and (_a_10[_a_19][_a_20]!=_a_18[_a_20])):
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
     for _a_21 in range(int((_a_10[_a_19]).shape[0]),_a_17):
      if ((_a_21!=_a_1) and (1!=_a_18[_a_21])):
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
    _a_22=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.int64))
    _a_23=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.int64))
    _a_24=numpy.array([(_a_10[_a_25][_a_1] if ((_a_1 < int((_a_10[_a_25]).shape[0])) ) else 1) for _a_25 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _a_26=1
    _a_26 = fragments._c_closure_234(_a_26,_a_1,_a_14)
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_27=0
    _a_27 = fragments._c_closure_235(_a_27,_a_7,_a_24)
    _a_27 = numpy.int32(_a_27) # postprocess
    _a_28=1
    _a_28 = fragments._c_closure_236(_a_28,_a_1,_a_14)
    _a_28 = numpy.int32(_a_28) # postprocess
    if (_a_26==1):
     _a_29=0
     _a_30=0
     for _a_31 in range(0,_a_7):
      _a_0[_a_31]._inst_I_3JI_3J(_a_29,_a_23,_a_29,_a_22)
      _a_29 = fragments._c_closure_237(_a_31,_a_29,_a_30,_a_8,_a_23)
      _a_29 = numpy.int32(_a_29) # postprocess
      _a_30 += mosek.fusion.Set._size__3I(_a_10[_a_31])
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_2,_a_18,(_a_23 if ((_a_16 < ((_a_26 * _a_27) * _a_28)) ) else None),_a_22))
    else:
     _a_32=0
     for _a_33 in range(0,_a_7):
      _a_32 += _a_0[_a_33]._inst_I_3JI_3J(_a_32,_a_23,_a_32,_a_22)
     _a_34=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.int32))
     _a_35=numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.int32))
     _a_36=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_238(_a_7,_a_36,_a_24) 
     fragments._c_closure_239(_a_34,_a_16) 
     _a_37=0
     _a_37 = fragments._c_closure_240(_a_27,_a_28,_a_37,_a_7,_a_8,_a_36,_a_23,_a_24)
     _a_37 = numpy.int32(_a_37) # postprocess
     _a_38=1
     _a_38 = fragments._c_closure_241(_a_38,_a_17,_a_18)
     _a_38 = numpy.int32(_a_38) # postprocess
     _a_39=numpy.zeros((_a_17,), dtype=numpy.dtype(numpy.int64))
     _a_39[(_a_17 - 1)] = 1
     fragments._c_closure_242(_a_17,_a_18,_a_39) 
     _a_40=numpy.zeros(((_a_38 + 1),), dtype=numpy.dtype(numpy.int32))
     for _a_41 in range(0,_a_17):
      _a_42=((_a_17 - _a_41) - 1)
      fragments._c_closure_243(_a_42,_a_40,_a_18) 
      fragments._c_closure_244(_a_42,_a_40,_a_16,_a_18,_a_23,_a_39) 
      fragments._c_closure_245(_a_42,_a_40,_a_18) 
      fragments._c_closure_246(_a_34,_a_42,_a_40,_a_16,_a_18,_a_23,_a_39,_a_35) 
      _a_43=_a_34
      _a_34 = _a_35
      _a_35 = _a_43
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_a_2,_a_18,(numpy.array([_a_23[_a_34[_a_44]] for _a_44 in range(0,_a_16)], dtype=numpy.dtype(numpy.int64)) if ((_a_16 < ((_a_26 * _a_27) * _a_28)) ) else None),numpy.array([_a_22[_a_34[_a_45]] for _a_45 in range(0,_a_16)], dtype=numpy.dtype(numpy.int64))))
 return Var
mosek_fusion_Var=__mk_mosek_fusion_Var()
del __mk_mosek_fusion_Var
#BEFORE CLASS
def __mk_mosek_fusion_Constraint():
 class Constraint(object):
  __slots__ = ['_Constraint__con_nativeidxs','_Constraint__shape','_Constraint__model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
      self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Constraint,mosek.fusion.Model)\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int32,ndim=1))')
  def get_nd(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.get_nd()

    Description
    -----------

    Get the number of dimensions of the constraint. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_get_1nd_(*args):
      return self._get_1nd_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1nd_(*args):
      return self._get_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_nd()')
  @staticmethod
  def vstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.vstack(array(mosek.fusion.Constraint,ndim=1))
      mosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint)
      mosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)

    Description
    -----------

    Stack three constraints. 

    Parameters
    ----------

    clist : array(mosek.fusion.Constraint,ndim=1)
        The constraints in the stack. 
    v1 : mosek.fusion.Constraint
        The first constraint in the stack. 
    v2 : mosek.fusion.Constraint
        The second constraint in the stack. 
    v3 : mosek.fusion.Constraint
        The third constraint in the stack. 
    '''
    if False: pass
    elif mosek_fusion_Constraint._match_vstack__3Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._vstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.vstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.toString()

    Description
    -----------

    Create a human readable string representation of the constraint.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_Constraint._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.toString()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.slice(int32,int32)
      mosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Create a slice constraint.

    Parameters
    ----------

    first : int32
        Index of the first element in the slice.
    firsta : array(int32,ndim=1)
        The indexes of first elements in the slice along each dimension.
    last : int32
        Index of the first element after the end of the slice.
    lasta : array(int32,ndim=1)
        The indexes of first elements after the end of the slice along each dimension.
    '''
    if False: pass
    elif mosek_fusion_Constraint._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_Constraint._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_Constraint._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.slice(int32,int32)\n\tmosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.index(int32)
      mosek.fusion.Constraint.index(array(int32,ndim=1))

    Description
    -----------

    Get a single element from a one-dimensional constraint. 

    Parameters
    ----------

    idx : int32
        The index of the element.
    idxa : array(int32,ndim=1)
        A multi-dimensional index of the element.
    '''
    if False: pass
    elif mosek_fusion_Constraint._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_Constraint._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_Constraint._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_Constraint._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.index(int32)\n\tmosek.fusion.Constraint.index(array(int32,ndim=1))')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.getND()

    Description
    -----------

    Return the number of dimensions in the constraint shape. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_Constraint._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getND()')
  def size(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.size()

    Description
    -----------

    Get the total number of elements in the constraint.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_size_(*args):
      return self._size_(*args)
    elif mosek_fusion_Constraint._match_alt_size_(*args):
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.size()')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.getShape()

    Description
    -----------

    Return the constraint's shape. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_Constraint._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getShape()')
  def get_model(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.get_model()

    Description
    -----------

    Get the model to which the constraint belongs.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_get_1model_(*args):
      return self._get_1model_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1model_(*args):
      return self._get_1model_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_model('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_model()')
  def dual(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.dual()

    Description
    -----------

    
    Get the dual solution values of the constraint.
            

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_dual_(*args):
      return self._dual_(*args)
    elif mosek_fusion_Constraint._match_alt_dual_(*args):
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.dual()')
  @staticmethod
  def stack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1),int32)
      mosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,int32)
      mosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32)

    Description
    -----------

    Stack a number of constraints.

    Parameters
    ----------

    clist : array(mosek.fusion.Constraint,ndim=1)
        The constraints in the stack. 
    dim : int32
        The dimension in which to stack, 0 means vertically. 
    v1 : mosek.fusion.Constraint
        The first constraint in the stack. 
    v2 : mosek.fusion.Constraint
        The second constraint in the stack. 
    v3 : mosek.fusion.Constraint
        The third constraint in the stack. 
    '''
    if False: pass
    elif mosek_fusion_Constraint._match_stack__3Lmosek_4fusion_4Constraint_2I(*args):
      return mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args):
      return mosek_fusion_Constraint._stack_alt__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1),int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32)')
  def getModel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.getModel()

    Description
    -----------

    Return the model that the constraint belongs to. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_getModel_(*args):
      return self._getModel_(*args)
    elif mosek_fusion_Constraint._match_alt_getModel_(*args):
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getModel()')
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.getSize()

    Description
    -----------

    Return the total number of elements in the constraint. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_Constraint._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getSize()')
  def level(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.level()

    Description
    -----------

    
    Get the primal solution values of the constraint.
            

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_level_(*args):
      return self._level_(*args)
    elif mosek_fusion_Constraint._match_alt_level_(*args):
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.level()')
  @staticmethod
  def hstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.hstack(array(mosek.fusion.Constraint,ndim=1))
      mosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint)
      mosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)

    Description
    -----------

    Stack a number of constraints horizontally.

    Parameters
    ----------

    clist : array(mosek.fusion.Constraint,ndim=1)
        The constraints in the stack. 
    v1 : mosek.fusion.Constraint
        The first constraint in the stack. 
    v2 : mosek.fusion.Constraint
        The second constraint in the stack. 
    v3 : mosek.fusion.Constraint
        The third constraint in the stack. 
    '''
    if False: pass
    elif mosek_fusion_Constraint._match_hstack__3Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._hstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.hstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def remove(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.remove()

    Description
    -----------

    Remove the constraint from the model.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Constraint._match_remove_(*args):
      return self._remove_(*args)
    elif mosek_fusion_Constraint._match_alt_remove_(*args):
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.remove()')
  def update(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Constraint.update(mosek.fusion.Expression)
      mosek.fusion.Constraint.update(array(double,ndim=1))
      mosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable)
      mosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable,bool)

    Description
    -----------

    Update part of a constraint. 

    Parameters
    ----------

    bfix : array(double,ndim=1)
        The fixed term to update with.
    bfixupdate : bool
        Whether to include fixed terms as well.
    expr : mosek.fusion.Expression
        The expression to update with.
    x : mosek.fusion.Variable
        Variable object defining the columns to update.
    '''
    if False: pass
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2(*args):
      return self._update_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2(*args):
      return self._update_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_update__3D(*args):
      return self._update__3D(*args)
    elif mosek_fusion_Constraint._match_alt_update__3D(*args):
      return self._update_alt__3D(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    else:
      raise ValueError('Invalid argument list update('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression)\n\tmosek.fusion.Constraint.update(array(double,ndim=1))\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable,bool)')
  def __repr__(self): return 'mosek.fusion.Constraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
   self.__model = m
   self.__shape = (c.__shape)
   self.__con_nativeidxs = (c.__con_nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,con_nativeidxs):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,con_nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,con_nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(con_nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,con_nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(con_nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,con_nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(con_nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,con_nativeidxs):
   (self.__model) = model
   (self.__shape) = shape
   (self.__con_nativeidxs) = con_nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("Constraint.toString")
  def _toStringArray_alt__3JJ_3S(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int64(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(object))
   _1_res = self._toStringArray__3JJ_3S(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _toStringArray__3JJ_3S(self,_a_0,_a_1,_a_2):
   pass
  def _dual_1lu_alt_I_3DZ(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = self._dual_1lu_I_3DZ(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _dual_1lu_I_3DZ(self,_a_0,_a_1,_a_2):
   self.__model._getConstraintDuals_Z_3I_3DI(_a_2,self.__con_nativeidxs,_a_1,_a_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _a_0=numpy.zeros((int((self.__con_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(False,0,_a_0)
   return (_a_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _a_0=numpy.zeros((int((self.__con_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(True,0,_a_0)
   return (_a_0)
  def __values_alt_ZI_3D(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = self.__values_ZI_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __values_ZI_3D(self,_a_0,_a_1,_a_2):
   self.__model._getConstraintValues_Z_3I_3DI(_a_0,self.__con_nativeidxs,_a_2,_a_1)
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   raise mosek_fusion_DeletionError._ctor_S("Only original constraints can be removed")
  @staticmethod
  def _match_update__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_update__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  def _update_alt__3D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = self._update__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _update__3D(self,_a_0):
   self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(mosek.fusion.Expr._constTerm__3D(_a_0),self._getShape_()),mosek_fusion_NilVariable._ctor_(),True)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0))
  def _update_alt_Lmosek_4fusion_4Expression_2(self,_t__a_0):
    return self._update_Lmosek_4fusion_4Expression_2(_a_0)
  def _update_Lmosek_4fusion_4Expression_2(self,_a_0):
   _a_1=_a_0._getShape_()
   if (int((self.__shape).shape[0]) < int((_a_1).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _a_2 in range(0,int((_a_1).shape[0])):
    if (_a_1[_a_2]!=self.__shape[_a_2]):
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _a_3 in range(int((_a_1).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_a_3]!=1):
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   self.__model._update__3ILmosek_4fusion_4Expression_2(self.__con_nativeidxs,_a_0)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_match_Z__(_a_2))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1) and __arg_alt_match_Z__(_a_2))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_t__a_0,_t__a_1,_t__a_2):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_a_0,_a_1,_a_2)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_a_0,_a_1,_a_2):
   _a_3=self._getND_()
   _a_4=_a_0._getShape_()
   if (_a_3 < int((_a_4).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _a_5 in range(0,int((_a_4).shape[0])):
    if (_a_4[_a_5]!=self.__shape[_a_5]):
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _a_6 in range(int((_a_4).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_a_6]!=1):
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   _a_7=_a_1._numInst_()
   _a_8=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
   if (_a_7 < _a_1._getSize_()):
    _a_9=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_1._inst_I_3JI_3J(0,_a_9,0,_a_8)
   else:
    _a_1._inst_I_3J(0,_a_8)
   for _a_10 in range(0,_a_7):
    if (_a_8[_a_10] < 0):
     raise mosek_fusion_UpdateError._ctor_S("Semidefinite terms cannot be updated")
   _a_12=True
   _a_12 = fragments._c_closure_247(_a_12,_a_7,_a_8)
   if _a_12:
    if (not _a_2):
     _a_11 = numpy.array([numpy.int32(_a_8[_a_13]) for _a_13 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
    else:
     _a_11 = numpy.zeros(((_a_7 + 1),), dtype=numpy.dtype(numpy.int32))
     _a_11[0] = 0
     fragments._c_closure_248(_a_7,_a_8,_a_11) 
   else:
    _a_14=numpy.array([_a_15 for _a_15 in range(0,_a_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_14,_a_8,None,0,_a_7)
    _a_16=1
    _a_16 = fragments._c_closure_249(_a_7,_a_16,_a_14,_a_8)
    _a_16 = numpy.int32(_a_16) # postprocess
    if _a_2:
     _a_16 += 1
    _a_11 = numpy.zeros((_a_16,), dtype=numpy.dtype(numpy.int32))
    _a_17=0
    if _a_2:
     _a_11[0] = 0
     _a_17 += 1
    _a_11[_a_17] = numpy.int32(_a_8[_a_14[0]])
    _a_17 = fragments._c_closure_250(_a_17,_a_7,_a_14,_a_8,_a_11)
    _a_17 = numpy.int32(_a_17) # postprocess
   self.__model._update__3ILmosek_4fusion_4Expression_2_3I(self.__con_nativeidxs,_a_0,_a_11)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__a_0,_t__a_1):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_a_0,_a_1):
   self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_a_0,_a_1,False)
  @staticmethod
  def _match_get_1model_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1model_(*args):
    if len(args) != 0: return False
    return True
  def _get_1model_alt_(self,):
    return self._get_1model_()
  def _get_1model_(self,):
   return (self.__model)
  @staticmethod
  def _match_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _get_1nd_alt_(self,):
    return self._get_1nd_()
  def _get_1nd_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _a_0=1
   _a_0 = fragments._c_closure_251(self.__shape,_a_0)
   _a_0 = numpy.int64(_a_0) # postprocess
   return numpy.int64(_a_0)
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Constraint_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack__3Lmosek_4fusion_4Constraint_2I(_a_0,_a_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_a_0,_a_1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_2) and __arg_alt_match_I__(_a_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_a_0,_a_1,_a_2,numpy.int32(__a_3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),_a_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_a_0,_a_1,numpy.int32(__a_2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_a_0,_a_1,_a_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),_a_2))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_a_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_a_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Constraint_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Constraint_2(_a_0):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_a_0,1))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_a_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_a_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Constraint_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Constraint_2(_a_0):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_a_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__a_0,_t__a_1):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_a_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_a_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__a_0,_t__a_1):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_a_0,_a_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Constraint_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Constraint_2I(_a_0,_a_1):
   _a_2=None
   for _a_3 in range(0,int((_a_0).shape[0])):
    if (_a_2 is None):
     _a_2 = _a_0[_a_3]._getModel_()
    elif (((_a_0[_a_3].__model) is not None) and ((_a_0[_a_3].__model) is not _a_2)):
     _a_4=mosek.fusion.Utils.StringBuffer()
     _a_5=(_a_2._getName_() if ((int(len(_a_2._getName_())) > 0) ) else "?")
     _a_6=(_a_0[_a_3]._getModel_()._getName_() if ((int(len(_a_0[_a_3]._getModel_()._getName_())) > 0) ) else "?")
     _a_4._a_S("Constraints belong to different models: '")._a_S(_a_5)._a_S("' and '")._a_S(_a_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_a_4._toString_())
   if (int((_a_0).shape[0])==0):
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(None,numpy.array([0], dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
   elif (int((_a_0).shape[0])==1):
    return (_a_0[1])
   else:
    _a_7=int((_a_0).shape[0])
    _a_8=1
    for _a_9 in range(0,_a_7):
     _a_8 = (_a_0[_a_9]._getND_() if ((_a_0[_a_9]._getND_() > _a_8) ) else _a_8)
    if (_a_1==_a_8):
     _a_8 += 1
    _a_10=numpy.zeros((_a_7,_a_8,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_252(_a_7,_a_8,_a_10) 
    _a_11=numpy.array([_a_0[_a_12]._getSize_() for _a_12 in range(0,_a_7)], dtype=numpy.dtype(numpy.int32))
    _a_13=0
    _a_13 = fragments._c_closure_253(_a_7,_a_11,_a_13)
    _a_13 = numpy.int32(_a_13) # postprocess
    for _a_14 in range(0,_a_7):
     _a_15=_a_0[_a_14]._getShape_()
     fragments._c_closure_254(_a_14,_a_10,_a_15) 
    if ((_a_1 < 0) or (_a_1 > _a_8)):
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    for _a_16 in range(0,_a_1):
     for _a_17 in range(1,_a_7):
      if (_a_10[0,_a_16]!=_a_10[_a_17,_a_16]):
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    for _a_18 in range((_a_1 + 1),_a_8):
     for _a_19 in range(1,_a_7):
      if (_a_10[0,_a_18]!=_a_10[_a_19,_a_18]):
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    _a_20=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
    _a_21=numpy.array([_a_10[0,_a_22] for _a_22 in range(0,_a_8)], dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_255(_a_1,_a_7,_a_21,_a_10) 
    _a_23=int((_a_21).shape[0])
    _a_24=numpy.zeros(((int((_a_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _a_25 in range(0,int((_a_0).shape[0])):
     _a_24[(_a_25 + 1)] = (_a_24[_a_25] + _a_10[_a_25,_a_1])
    if (_a_1==0):
     _a_26=0
     for _a_27 in range(0,_a_7):
      _a_28=int(((_a_0[_a_27].__con_nativeidxs)).shape[0])
      mosek.fusion.Utils.Tools._arraycopy__3II_3III((_a_0[_a_27].__con_nativeidxs),0,_a_20,_a_26,_a_28)
      _a_26 += _a_28
    else:
     _a_29=_monty.initJaggedArray([(_a_0[_a_30].__con_nativeidxs) for _a_30 in range(0,_a_7)], 1)
     if (_a_1 < _a_8):
      _a_31=1
      _a_31 = fragments._c_closure_256(_a_31,_a_1,_a_21)
      _a_31 = numpy.int32(_a_31) # postprocess
      _a_32=1
      _a_32 = fragments._c_closure_257(_a_32,_a_1,_a_8,_a_21)
      _a_32 = numpy.int32(_a_32) # postprocess
      _a_33=0
      for _a_34 in range(0,_a_31):
       for _a_35 in range(0,_a_7):
        _a_36=0
        _a_37=_a_10[_a_35,_a_1]
        for _a_38 in range(0,_a_37):
         for _a_39 in range(0,_a_32):
          _a_20[_a_33] = (_a_0[_a_7].__con_nativeidxs)[(((_a_34 * _a_32) * _a_37) + _a_36)]
          _a_33 += 1
          _a_36 += 1
     else:
      fragments._c_closure_258(_a_20,_a_7,_a_8,_a_29,_a_21) 
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(_a_2,_a_21,_a_20))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   if (int((_a_0).shape[0])!=int((self.__shape).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _a_1 in range(0,int((self.__shape).shape[0])):
     if ((_a_0[_a_1] < 0) or (_a_0[_a_1] > self.__shape[_a_1])):
      raise mosek_fusion_IndexError._ctor_S("index is out of bounds")
    _a_2=int((self.__shape).shape[0])
    _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    _a_3[(_a_2 - 1)] = 1
    fragments._c_closure_259(_a_2,self.__shape,_a_3) 
    _a_4=0
    _a_4 = fragments._c_closure_260(_a_0,_a_4,_a_2,_a_3)
    _a_4 = numpy.int32(_a_4) # postprocess
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__con_nativeidxs[_a_4]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   if ((int((self.__shape).shape[0])==0) and (_a_0==0)):
    return (self)
   elif (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   elif ((_a_0 < 0) or (_a_0 > self.__shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__con_nativeidxs[_a_0]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   if (int((_a_0).shape[0])!=int((_a_1).shape[0])):
    raise mosek_fusion_SliceError._ctor_S("invalid slice")
   elif (int((_a_0).shape[0])!=int((self.__shape).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _a_2 in range(0,int((self.__shape).shape[0])):
     if ((_a_0[_a_2] < 0) or (_a_1[_a_2] > self.__shape[_a_2])):
      raise mosek_fusion_IndexError._ctor_S("slice is out of bounds")
     elif (_a_0[_a_2] > _a_1[_a_2]):
      raise mosek_fusion_SliceError._ctor_S("invalid slice")
    _a_3=int((self.__shape).shape[0])
    _a_4=numpy.array([(_a_1[_a_5] - _a_0[_a_5]) for _a_5 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32))
    _a_6=1
    _a_6 = fragments._c_closure_261(_a_0,_a_1,_a_3,_a_6)
    _a_6 = numpy.int32(_a_6) # postprocess
    if (_a_6==0):
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,_a_4,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
    else:
     _a_7=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_262(self.__con_nativeidxs,_a_0,_a_1,_a_3,self.__shape,_a_7,_a_6) 
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self._getModel_(),_a_4,_a_7))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   if (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_a_0==0) and (_a_1==self.__shape[0])):
    return (self)
   elif ((_a_0 < 0) or (_a_1 > self.__shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_a_0 > _a_1):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.array([(_a_1 - _a_0)], dtype=numpy.dtype(numpy.int32)),numpy.array([self.__con_nativeidxs[_a_2] for _a_2 in range(_a_0,_a_1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _a_0=1
   _a_0 = fragments._c_closure_263(self.__shape,_a_0)
   _a_0 = numpy.int32(_a_0) # postprocess
   return numpy.int32(_a_0)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (numpy.array([self.__shape[_a_0] for _a_0 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  def _getNativeidxs_alt_(self,):
    return self._getNativeidxs_()
  def _getNativeidxs_(self,):
   return (self.__con_nativeidxs)
 return Constraint
mosek_fusion_Constraint=__mk_mosek_fusion_Constraint()
del __mk_mosek_fusion_Constraint
#BEFORE CLASS
def __mk_mosek_fusion_SliceConstraint():
 class SliceConstraint(mosek_fusion_Constraint):
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SliceConstraint.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SliceConstraint._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_SliceConstraint._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.SliceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceConstraint_2(c):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4SliceConstraint_2(c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceConstraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_match_Lmosek_4fusion_4SliceConstraint_2__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceConstraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(c))
  def _ctor_alt_init_Lmosek_4fusion_4SliceConstraint_2(self,c):
    self._ctor_init_Lmosek_4fusion_4SliceConstraint_2(c)
  def _ctor_init_Lmosek_4fusion_4SliceConstraint_2(self,c):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,c._getModel_())
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("SliceConstraint()")
   return (_a_0._toString_())
 return SliceConstraint
mosek_fusion_SliceConstraint=__mk_mosek_fusion_SliceConstraint()
del __mk_mosek_fusion_SliceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceConstraint():
 class BoundInterfaceConstraint(mosek_fusion_SliceConstraint):
  __slots__ = ['_BoundInterfaceConstraint__islower']
  def dual(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceConstraint.dual()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_dual_(*args):
      return self._dual_(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_dual_(*args):
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.dual()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceConstraint.slice(int32,int32)
      mosek.fusion.BoundInterfaceConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    first : int32
    firsta : array(int32,ndim=1)
    last : int32
    lasta : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.slice(int32,int32)\n\tmosek.fusion.BoundInterfaceConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BoundInterfaceConstraint.index(int32)
      mosek.fusion.BoundInterfaceConstraint.index(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    idx : int32
    idxa : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.index(int32)\n\tmosek.fusion.BoundInterfaceConstraint.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BoundInterfaceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3IZ(m,shape,nativeidxs,islower):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(m,shape,nativeidxs,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3IZ(*args):
    if len(args) != 4: return False
    m,shape,nativeidxs,islower, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3IZ(*args):
    if len(args) != 4: return False
    m,shape,nativeidxs,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3IZ(self,m,shape,nativeidxs,islower):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),islower)
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(self,m,shape,nativeidxs,islower):
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,m,shape,nativeidxs)
   (self.__islower) = islower
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceConstraint_2Z(c,islower):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(c,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceConstraint_2Z(*args):
    if len(args) != 2: return False
    c,islower, = args
    return (__arg_match_Lmosek_4fusion_4SliceConstraint_2__(c) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceConstraint_2Z(*args):
    if len(args) != 2: return False
    c,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(c) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4SliceConstraint_2Z(self,c,islower):
    self._ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(c,islower)
  def _ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(self,c,islower):
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4SliceConstraint_2(self,c)
   (self.__islower) = islower
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _a_0=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
   self._dual_1lu_I_3DZ(0,_a_0,self.__islower)
   return (_a_0)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   _a_2=mosek_fusion_Constraint._slice__3I_3I(self,_a_0,_a_1)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_a_2))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   _a_2=mosek_fusion_Constraint._slice_II(self,_a_0,_a_1)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_a_2))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   _a_1=mosek_fusion_Constraint._index__3I(self,_a_0)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_a_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   _a_1=mosek_fusion_Constraint._index_I(self,_a_0)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_a_1))
  def __from_1_alt_Lmosek_4fusion_4Constraint_2(self,_t__a_0):
    return self.__from_1_Lmosek_4fusion_4Constraint_2(_a_0)
  def __from_1_Lmosek_4fusion_4Constraint_2(self,_a_0):
   _a_2=_a_0
   if   isinstance(_a_2,mosek_fusion_SliceConstraint):
    cc=_a_2
    return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4SliceConstraint_2Z(cc,self.__islower))
   else:
    cc=_a_2
    return (None)
 return BoundInterfaceConstraint
mosek_fusion_BoundInterfaceConstraint=__mk_mosek_fusion_BoundInterfaceConstraint()
del __mk_mosek_fusion_BoundInterfaceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ModelConstraint():
 class ModelConstraint(mosek_fusion_Constraint):
  __slots__ = ['_ModelConstraint__conid','_ModelConstraint__shape','_ModelConstraint__modelcon_nativeidxs','_ModelConstraint__name']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ModelConstraint.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ModelConstraint._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.toString()')
  def remove(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ModelConstraint.remove()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ModelConstraint._match_remove_(*args):
      return self._remove_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_remove_(*args):
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.remove()')
  def __repr__(self): return 'mosek.fusion.ModelConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m)
   (self.__conid) = (c.__conid)
   self.__name = (c.__name)
   self.__modelcon_nativeidxs = (c.__modelcon_nativeidxs)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nidxs,conid):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nidxs,conid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nidxs,conid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs) and __arg_match_I__(conid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nidxs,conid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs) and __arg_alt_match_I__(conid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nidxs)
   (self.__name) = name
   (self.__modelcon_nativeidxs) = nidxs
   (self.__shape) = shape
   (self.__conid) = conid
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("Constraint('")._a_S(self.__name)._a_S("')")
   return (_a_0._toString_())
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   pass
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   self._getModel_()._removeConstraintBlock_I(self.__conid)
 return ModelConstraint
mosek_fusion_ModelConstraint=__mk_mosek_fusion_ModelConstraint()
del __mk_mosek_fusion_ModelConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDConstraint():
 class LinearPSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearPSDConstraint__conedim','_LinearPSDConstraint__shape','_LinearPSDConstraint__conid','_LinearPSDConstraint__slackidxs','_LinearPSDConstraint__nativeidxs']
  def __repr__(self): return 'mosek.fusion.LinearPSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__conedim = (c.__conedim)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3I__(nativeidxs) and __arg_match__3J__(slackidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3J__(slackidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__conid) = conid
   (self.__slackidxs) = slackidxs
   (self.__nativeidxs) = nativeidxs
   (self.__conedim) = conedim
   (self.__shape) = shape
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   _a_2=mosek.fusion.Set._idxtokey__3IJ(self.__shape,_a_0)
   _a_1._a_S(" : element (")._a_I(_a_2[0])
   for _a_3 in range(1,int((_a_2).shape[0])):
    _a_1._a_S(",")._a_I(_a_2[_a_3])
   _a_1._a_S(") in a positive semi-definite cone of size (")._a_I(self.__shape[0])
   for _a_4 in range(1,int((_a_2).shape[0])):
    _a_1._a_S(",")._a_I(self.__shape[_a_4])
   _a_1._a_S(")")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,_a_0))
 return LinearPSDConstraint
mosek_fusion_LinearPSDConstraint=__mk_mosek_fusion_LinearPSDConstraint()
del __mk_mosek_fusion_LinearPSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_PSDConstraint():
 class PSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_PSDConstraint__conedim1','_PSDConstraint__conedim0','_PSDConstraint__shape','_PSDConstraint__name','_PSDConstraint__slackidxs','_PSDConstraint__nativeidxs','_PSDConstraint__conid']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.PSDConstraint.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_PSDConstraint._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_PSDConstraint._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.PSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
   self.__shape = (c.__shape)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__conedim0 = (c.__conedim0)
   self.__conedim1 = (c.__conedim1)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim0) and __arg_match_I__(conedim1) and __arg_match__3J__(slackidxs) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim0) and __arg_alt_match_I__(conedim1) and __arg_alt_match__3J__(slackidxs) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim0),numpy.int32(conedim1),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,mosek.fusion.PSDConstraint.__computenidxs__3III_3I(shape,conedim0,conedim1,nativeidxs),conid)
   (self.__conid) = conid
   (self.__nativeidxs) = nativeidxs
   (self.__slackidxs) = slackidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim0) = conedim0
   (self.__conedim1) = conedim1
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("PSDConstraint.toString not implemented")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def __computenidxs_alt__3III_3I(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_PSDConstraint.__computenidxs__3III_3I(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __computenidxs__3III_3I(_a_0,_a_1,_a_2,_a_3):
   _a_4=int((_a_0).shape[0])
   _a_5=(_a_1 < _a_2)
   _a_6=(_a_1 if (_a_5 ) else _a_2)
   _a_7=(_a_2 if (_a_5 ) else _a_1)
   _a_8=numpy.array([1,1,1,1,1], dtype=numpy.dtype(numpy.int32))
   _a_9=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _a_10=1
   _a_10 = fragments._c_closure_264(_a_0,_a_10)
   _a_10 = numpy.int32(_a_10) # postprocess
   fragments._c_closure_265(_a_6,_a_8,_a_0) 
   _a_8[1] = _a_0[_a_6]
   fragments._c_closure_266(_a_6,_a_7,_a_8,_a_0) 
   _a_8[3] = _a_0[_a_7]
   fragments._c_closure_267(_a_7,_a_8,_a_4,_a_0) 
   _a_9[4] = 1
   fragments._c_closure_268(_a_8,_a_9) 
   _a_11=numpy.zeros((_a_10,), dtype=numpy.dtype(numpy.int32))
   _a_12=0
   _a_12 = fragments._c_closure_269(_a_8,_a_12,_a_3,_a_11,_a_9,_a_5)
   _a_12 = numpy.int32(_a_12) # postprocess
   return (_a_11)
 return PSDConstraint
mosek_fusion_PSDConstraint=__mk_mosek_fusion_PSDConstraint()
del __mk_mosek_fusion_PSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_RangedConstraint():
 class RangedConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_RangedConstraint__nativeidxs','_RangedConstraint__shape']
  def upperBoundCon(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangedConstraint.upperBoundCon()

    Description
    -----------

    Obtain the interface to the variable's upper bound. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RangedConstraint._match_upperBoundCon_(*args):
      return self._upperBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_upperBoundCon_(*args):
      return self._upperBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.upperBoundCon()')
  def lowerBoundCon(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangedConstraint.lowerBoundCon()

    Description
    -----------

    Obtain the interface to the variable's lower bound. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RangedConstraint._match_lowerBoundCon_(*args):
      return self._lowerBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_lowerBoundCon_(*args):
      return self._lowerBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.lowerBoundCon()')
  def __repr__(self): return 'mosek.fusion.RangedConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__shape = (c.__shape)
   self.__nativeidxs = (c.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nativeidxs,conid):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nativeidxs,conid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nativeidxs,conid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs) and __arg_match_I__(conid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nativeidxs,conid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_I__(conid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundCon_alt_(self,):
    return self._upperBoundCon_()
  def _upperBoundCon_(self,):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3IZ(self._getModel_(),self.__shape,self.__nativeidxs,False))
  @staticmethod
  def _match_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundCon_alt_(self,):
    return self._lowerBoundCon_()
  def _lowerBoundCon_(self,):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3IZ(self._getModel_(),self.__shape,self.__nativeidxs,True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,_a_0))
 return RangedConstraint
mosek_fusion_RangedConstraint=__mk_mosek_fusion_RangedConstraint()
del __mk_mosek_fusion_RangedConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ConicConstraint():
 class ConicConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_ConicConstraint__indexnames','_ConicConstraint__nativeidxs','_ConicConstraint__names_flushed','_ConicConstraint__name','_ConicConstraint__shape','_ConicConstraint__dom','_ConicConstraint__conid']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConicConstraint.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ConicConstraint._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.ConicConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__conid = (c.__conid)
   self.__shape = (c.__shape)
   self.__name = (c.__name)
   self.__nativeidxs = (c.__nativeidxs)
   self.__names_flushed = (c.__names_flushed)
   self.__indexnames = (c.__indexnames)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(model,name,dom,shape,conid,nativeidxs,indexnames):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(model,name,dom,shape,conid,nativeidxs,indexnames)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,indexnames, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_match__3I__(shape) and __arg_match_I__(conid) and __arg_match__3I__(nativeidxs) and __arg_match__3_3S__(indexnames))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,indexnames, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3_3S__(indexnames))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,model,name,dom,shape,conid,nativeidxs,indexnames):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(model,name,dom,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(indexnames,dtype=numpy.dtype(object)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,model,name,dom,shape,conid,nativeidxs,indexnames):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,numpy.array([(- (1 + nativeidxs[_a_0])) for _a_0 in range(0,int((nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int32)),(- (1 + conid)))
   (self.__dom) = dom
   (self.__shape) = shape
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__indexnames) = indexnames
   (self.__conid) = conid
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("ConicConstraint('")._a_S(self.__name)._a_S("')")
   return (_a_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   raise mosek_fusion_UnimplementedError._ctor_S("ConicConstraint.domainToString")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,_a_0))
 return ConicConstraint
mosek_fusion_ConicConstraint=__mk_mosek_fusion_ConicConstraint()
del __mk_mosek_fusion_ConicConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearConstraint():
 class LinearConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearConstraint__indexnames','_LinearConstraint__nidxs','_LinearConstraint__name','_LinearConstraint__conid']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearConstraint.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinearConstraint._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_LinearConstraint._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.LinearConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
   self.__nidxs = mosek.fusion.Utils.Tools._arraycopy__3I((c.__nidxs))
   self.__indexnames = (c.__indexnames)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(model,name,conid,shape,nidxs,indexnames):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(model,name,conid,shape,nidxs,indexnames)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(*args):
    if len(args) != 6: return False
    model,name,conid,shape,nidxs,indexnames, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs) and __arg_match__3_3S__(indexnames))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(*args):
    if len(args) != 6: return False
    model,name,conid,shape,nidxs,indexnames, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs) and __arg_alt_match__3_3S__(indexnames))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(self,model,name,conid,shape,nidxs,indexnames):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(indexnames,dtype=numpy.dtype(object)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(self,model,name,conid,shape,nidxs,indexnames):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid)
   (self.__nidxs) = nidxs
   (self.__conid) = conid
   (self.__name) = name
   (self.__indexnames) = indexnames
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("LinearConstraint('")._a_S(self.__name)._a_S("')")
   return (_a_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__a_0,_t__a_1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__a_0),_a_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_a_0,_a_1):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,_a_0))
 return LinearConstraint
mosek_fusion_LinearConstraint=__mk_mosek_fusion_LinearConstraint()
del __mk_mosek_fusion_LinearConstraint
#BEFORE CLASS
def __mk_mosek_fusion_Set():
 class Set(object):
  @staticmethod
  def keyToString(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.keyToString(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    key : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_keyToString__3I(*args):
      return mosek_fusion_Set._keyToString__3I(*args)
    elif mosek_fusion_Set._match_alt_keyToString__3I(*args):
      return mosek_fusion_Set._keyToString_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list keyToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.keyToString(array(int32,ndim=1))')
  @staticmethod
  def indexToString(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.indexToString(array(int32,ndim=1),int64)

    Description
    -----------

    

    Parameters
    ----------

    key : int64
    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_indexToString__3IJ(*args):
      return mosek_fusion_Set._indexToString__3IJ(*args)
    elif mosek_fusion_Set._match_alt_indexToString__3IJ(*args):
      return mosek_fusion_Set._indexToString_alt__3IJ(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToString(array(int32,ndim=1),int64)')
  @staticmethod
  def linearidx(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.linearidx(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    
    Look up the linear index associated with a key.
            

    Parameters
    ----------

    key : array(int32,ndim=1)
    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_linearidx__3I_3I(*args):
      return mosek_fusion_Set._linearidx__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_linearidx__3I_3I(*args):
      return mosek_fusion_Set._linearidx_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list linearidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.linearidx(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def scalar(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.scalar()

    Description
    -----------

    Create a shape of size 1. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Set._match_scalar_(*args):
      return mosek_fusion_Set._scalar_(*args)
    elif mosek_fusion_Set._match_alt_scalar_(*args):
      return mosek_fusion_Set._scalar_alt_(*args)
    else:
      raise ValueError('Invalid argument list scalar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.scalar()')
  @staticmethod
  def make(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.make(array(string,ndim=1))
      mosek.fusion.Set.make(int32)
      mosek.fusion.Set.make(array(int32,ndim=1))
      mosek.fusion.Set.make(array(int32,ndim=1),array(int32,ndim=1))
      mosek.fusion.Set.make(int32,int32)
      mosek.fusion.Set.make(int32,int32,int32)

    Description
    -----------

    Creates a shape. 

    Parameters
    ----------

    names : array(string,ndim=1)
        A list of strings for a set of strings. 
    s1 : int32
        Size of the first dimension. 
    s2 : int32
        Size of the second dimension. 
    s3 : int32
        Size of the third dimension. 
    set1 : array(int32,ndim=1)
        First factor in a Cartesian product. 
    set2 : array(int32,ndim=1)
        Second factor in a Cartesian product. 
    sizes : array(int32,ndim=1)
        The sizes of dimensions for a multi-dimensional integer set. 
    sz : int32
        The size of a one-dimensional set of integers. 
    '''
    if False: pass
    elif mosek_fusion_Set._match_make__3S(*args):
      return mosek_fusion_Set._make__3S(*args)
    elif mosek_fusion_Set._match_alt_make__3S(*args):
      return mosek_fusion_Set._make_alt__3S(*args)
    elif mosek_fusion_Set._match_make_I(*args):
      return mosek_fusion_Set._make_I(*args)
    elif mosek_fusion_Set._match_alt_make_I(*args):
      return mosek_fusion_Set._make_alt_I(*args)
    elif mosek_fusion_Set._match_make__3I(*args):
      return mosek_fusion_Set._make__3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I(*args):
      return mosek_fusion_Set._make_alt__3I(*args)
    elif mosek_fusion_Set._match_make__3I_3I(*args):
      return mosek_fusion_Set._make__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I_3I(*args):
      return mosek_fusion_Set._make_alt__3I_3I(*args)
    elif mosek_fusion_Set._match_make_II(*args):
      return mosek_fusion_Set._make_II(*args)
    elif mosek_fusion_Set._match_alt_make_II(*args):
      return mosek_fusion_Set._make_alt_II(*args)
    elif mosek_fusion_Set._match_make_III(*args):
      return mosek_fusion_Set._make_III(*args)
    elif mosek_fusion_Set._match_alt_make_III(*args):
      return mosek_fusion_Set._make_alt_III(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.make(array(string,ndim=1))\n\tmosek.fusion.Set.make(int32)\n\tmosek.fusion.Set.make(array(int32,ndim=1))\n\tmosek.fusion.Set.make(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Set.make(int32,int32)\n\tmosek.fusion.Set.make(int32,int32,int32)')
  @staticmethod
  def match(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.match(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    s1 : array(int32,ndim=1)
    s2 : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_match__3I_3I(*args):
      return mosek_fusion_Set._match__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_match__3I_3I(*args):
      return mosek_fusion_Set._match_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list match('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.match(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def size(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.size(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_size__3I(*args):
      return mosek_fusion_Set._size__3I(*args)
    elif mosek_fusion_Set._match_alt_size__3I(*args):
      return mosek_fusion_Set._size_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.size(array(int32,ndim=1))')
  @staticmethod
  def indexToKey(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.indexToKey(array(int32,ndim=1),int64,array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    key : int64
    res : array(int32,ndim=1)
    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_indexToKey__3IJ_3I(*args):
      return mosek_fusion_Set._indexToKey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_indexToKey__3IJ_3I(*args):
      return mosek_fusion_Set._indexToKey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list indexToKey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToKey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def idxtokey(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.idxtokey(array(int32,ndim=1),int64)
      mosek.fusion.Set.idxtokey(array(int32,ndim=1),int64,array(int32,ndim=1))

    Description
    -----------

    Convert a linear index to a N-dimensional key.

    Parameters
    ----------

    dest : array(int32,ndim=1)
    idx : int64
    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_idxtokey__3IJ(*args):
      return mosek_fusion_Set._idxtokey__3IJ(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ(*args):
      return mosek_fusion_Set._idxtokey_alt__3IJ(*args)
    elif mosek_fusion_Set._match_idxtokey__3IJ_3I(*args):
      return mosek_fusion_Set._idxtokey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ_3I(*args):
      return mosek_fusion_Set._idxtokey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list idxtokey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64)\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def strides(*args):
    '''
    Syntax
    ------

      mosek.fusion.Set.strides(array(int32,ndim=1))

    Description
    -----------

    Compute the strides from a shape. 

    Parameters
    ----------

    shape : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Set._match_strides__3I(*args):
      return mosek_fusion_Set._strides__3I(*args)
    elif mosek_fusion_Set._match_alt_strides__3I(*args):
      return mosek_fusion_Set._strides_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list strides('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.strides(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Set'
  @staticmethod
  def _match_size__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_size__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _size_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._size__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _size__3I(_a_0):
   _a_1=1
   _a_1 = fragments._c_closure_270(_a_0,_a_1)
   _a_1 = numpy.int64(_a_1) # postprocess
   return numpy.int64(_a_1)
  @staticmethod
  def _match_match__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_match__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _match_alt__3I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._match__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _match__3I_3I(_a_0,_a_1):
   if (int((_a_0).shape[0])!=int((_a_1).shape[0])):
    return (False)
   for _a_2 in range(0,int((_a_0).shape[0])):
    if (_a_0[_a_2]!=_a_1[_a_2]):
     return (False)
   return (True)
  @staticmethod
  def _match_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _linearidx_alt__3I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._linearidx__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _linearidx__3I_3I(_a_0,_a_1):
   _a_2=_a_1[0]
   _a_2 = fragments._c_closure_271(_a_1,_a_2,_a_0)
   _a_2 = numpy.int64(_a_2) # postprocess
   return numpy.int64(_a_2)
  @staticmethod
  def _match_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_J__(_a_1))
  @staticmethod
  def _match_alt_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_J__(_a_1))
  @staticmethod
  def _idxtokey_alt__3IJ(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int64(_t__a_1)
   _1_res = mosek_fusion_Set._idxtokey__3IJ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _idxtokey__3IJ(_a_0,_a_1):
   _a_2=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Set._idxtokey__3IJ_3I(_a_0,_a_1,_a_2)
   return (_a_2)
  @staticmethod
  def _match_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match_J__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_J__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _idxtokey_alt__3IJ_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int64(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._idxtokey__3IJ_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _idxtokey__3IJ_3I(_a_0,_a_1,_a_2):
   fragments._c_closure_272(_a_2,_a_1,_a_0) 
  @staticmethod
  def _match_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_J__(_a_1))
  @staticmethod
  def _match_alt_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_J__(_a_1))
  @staticmethod
  def _indexToString_alt__3IJ(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int64(_t__a_1)
   _1_res = mosek_fusion_Set._indexToString__3IJ(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _indexToString__3IJ(_a_0,_a_1):
   _a_2=int((_a_0).shape[0])
   _a_3=mosek.fusion.Utils.StringBuffer()
   if (_a_2==0):
    return ("0")
   elif (_a_2==1):
    return (_a_3._a_J(_a_1)._toString_())
   else:
    _a_4=_a_1
    _a_5=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    _a_4 = fragments._c_closure_273(_a_5,_a_2,_a_4,_a_0)
    _a_4 = numpy.int64(_a_4) # postprocess
    _a_5[0] = numpy.int32(_a_4)
    _a_3._a_I(_a_5[0])
    for _a_6 in range(1,_a_2):
     _a_3._a_S(",")._a_I(_a_5[_a_6])
    return (_a_3._toString_())
  @staticmethod
  def _match_keyToString__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_keyToString__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _keyToString_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._keyToString__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _keyToString__3I(_a_0):
   _a_1=mosek.fusion.Utils.StringBuffer()
   _a_1._a_I(_a_0[0])
   for _a_2 in range(1,int((_a_0).shape[0])):
    _a_1._a_S(",")._a_I(_a_0[_a_2])
   return (_a_1._toString_())
  @staticmethod
  def _match_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match_J__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_J__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _indexToKey_alt__3IJ_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int64(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._indexToKey__3IJ_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _indexToKey__3IJ_3I(_a_0,_a_1,_a_2):
   fragments._c_closure_274(_a_1,_a_2,_a_0) 
  @staticmethod
  def _match_strides__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_strides__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _strides_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._strides__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _strides__3I(_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int64))
   _a_2[(_a_1 - 1)] = 1
   fragments._c_closure_275(_a_1,_a_0,_a_2) 
   return (_a_2)
  @staticmethod
  def _match_make__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_make__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _make_alt__3I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._make__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _make__3I_3I(_a_0,_a_1):
   _a_2=numpy.zeros(((int((_a_0).shape[0]) + int((_a_1).shape[0])),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_276(_a_2,_a_0) 
   fragments._c_closure_277(_a_2,_a_0,_a_1) 
   return (_a_2)
  @staticmethod
  def _match_make__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_make__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _make_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Set._make__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _make__3I(_a_0):
   return (numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_make_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _make_alt_III(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Set._make_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _make_III(_a_0,_a_1,_a_2):
   return (numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_make_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _make_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Set._make_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _make_II(_a_0,_a_1):
   return (numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_make_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _make_alt_I(_t__a_0):
    return mosek_fusion_Set._make_I(numpy.int32(__a_0))
  @staticmethod
  def _make_I(_a_0):
   return (numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _scalar_alt_():
    return mosek_fusion_Set._scalar_()
  @staticmethod
  def _scalar_():
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make__3S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3S__(_a_0))
  @staticmethod
  def _match_alt_make__3S(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3S__(_a_0))
  @staticmethod
  def _make_alt__3S(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Set._make__3S(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _make__3S(_a_0):
   return (numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32)))
 return Set
mosek_fusion_Set=__mk_mosek_fusion_Set()
del __mk_mosek_fusion_Set
#BEFORE CLASS
def __mk_mosek_fusion_ConeDomain():
 class ConeDomain(object):
  __slots__ = ['_indexnames','_domsize','_domofs','_alpha','_shape','_int_flag','_axisset','_axisidx','_key']
  def integral(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConeDomain.integral()

    Description
    -----------

    Creates a domain of integral variables.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ConeDomain._match_integral_(*args):
      return self._integral_(*args)
    elif mosek_fusion_ConeDomain._match_alt_integral_(*args):
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.integral()')
  def withNamesOnAxis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConeDomain.withNamesOnAxis(array(string,ndim=1),int32)

    Description
    -----------

    Set index names in a specific axis. 

    Parameters
    ----------

    axis : int32
        The axis to change names on.
    names : array(string,ndim=1)
        List of names, this must match the actual dimension on that axis. 
    '''
    if False: pass
    elif mosek_fusion_ConeDomain._match_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_ConeDomain._match_alt_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def axisIsSet(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConeDomain.axisIsSet()

    Description
    -----------

    Returns true if the cone axis was set 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ConeDomain._match_axisIsSet_(*args):
      return self._axisIsSet_(*args)
    elif mosek_fusion_ConeDomain._match_alt_axisIsSet_(*args):
      return self._axisIsSet_alt_(*args)
    else:
      raise ValueError('Invalid argument list axisIsSet('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axisIsSet()')
  def axis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConeDomain.axis(int32)

    Description
    -----------

    Set the dimension along which the cones are created.

    Parameters
    ----------

    a : int32
    '''
    if False: pass
    elif mosek_fusion_ConeDomain._match_axis_I(*args):
      return self._axis_I(*args)
    elif mosek_fusion_ConeDomain._match_alt_axis_I(*args):
      return self._axis_alt_I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axis(int32)')
  def getAxis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConeDomain.getAxis()

    Description
    -----------

    Get the dimension along which the cones are created.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ConeDomain._match_getAxis_(*args):
      return self._getAxis_(*args)
    elif mosek_fusion_ConeDomain._match_alt_getAxis_(*args):
      return self._getAxis_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.getAxis()')
  def withShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ConeDomain.withShape(array(int32,ndim=1))
      mosek.fusion.ConeDomain.withShape(int32)
      mosek.fusion.ConeDomain.withShape(int32,int32)
      mosek.fusion.ConeDomain.withShape(int32,int32,int32)

    Description
    -----------

    Set the shape of the domain.  

    Parameters
    ----------

    dim0 : int32
        First dimension
    dim1 : int32
        Second dimension
    dim2 : int32
        Third dimension
    shp : array(int32,ndim=1)
        The shape of the domain
    '''
    if False: pass
    elif mosek_fusion_ConeDomain._match_withShape__3I(*args):
      return self._withShape__3I(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape__3I(*args):
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_ConeDomain._match_withShape_I(*args):
      return self._withShape_I(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape_I(*args):
      return self._withShape_alt_I(*args)
    elif mosek_fusion_ConeDomain._match_withShape_II(*args):
      return self._withShape_II(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape_II(*args):
      return self._withShape_alt_II(*args)
    elif mosek_fusion_ConeDomain._match_withShape_III(*args):
      return self._withShape_III(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape_III(*args):
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.ConeDomain.withShape(int32)\n\tmosek.fusion.ConeDomain.withShape(int32,int32)\n\tmosek.fusion.ConeDomain.withShape(int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.ConeDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3D_3I(k,alpha,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(k,alpha,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3D__(alpha) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3D__(alpha) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3D_3I(self,k,alpha,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(k,numpy.array(alpha,dtype=numpy.dtype(numpy.float64)),numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(self,k,alpha,d):
   self._shape = (mosek.fusion.Utils.Tools._arraycopy__3I(d) if ((d is not None) ) else None)
   self._domsize = 0
   (self._alpha) = alpha
   self._key = k
   self._axisidx = 0
   self._axisset = False
   self._int_flag = False
   self._domofs = None
   self._indexnames = None
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3I(k,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
   mosek_fusion_ConeDomain._ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(self,k,None,d)
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConeDomain_2(other):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Lmosek_4fusion_4ConeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4ConeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4ConeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4ConeDomain_2(self,other):
   self._key = (other._key)
   self._axisidx = (other._axisidx)
   self._axisset = (other._axisset)
   self._int_flag = (other._int_flag)
   self._shape = (other._shape)
   self._alpha = (other._alpha)
   self._domofs = (other._domofs)
   self._domsize = (other._domsize)
   self._indexnames = (other._indexnames)
  def _match_1shape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._match_1shape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _match_1shape__3I(self,_a_0):
   return (((self._shape is None) or mosek.fusion.Set._match__3I_3I(_a_0,self._shape)))
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._int_flag = True
   return (self)
  @staticmethod
  def _match_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  def _axisIsSet_alt_(self,):
    return self._axisIsSet_()
  def _axisIsSet_(self,):
   return (self._axisset)
  @staticmethod
  def _match_getAxis_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAxis_(*args):
    if len(args) != 0: return False
    return True
  def _getAxis_alt_(self,):
    return self._getAxis_()
  def _getAxis_(self,):
   return numpy.int32(self._axisidx)
  @staticmethod
  def _match_axis_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_axis_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _axis_alt_I(self,_t__a_0):
    return self._axis_I(numpy.int32(__a_0))
  def _axis_I(self,_a_0):
   self._axisidx = _a_0
   self._axisset = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _withShape_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._withShape_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _withShape_III(self,_a_0,_a_1,_a_2):
   return (self.__withShape_1__3I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withShape_alt_II(self,_t__a_0,_t__a_1):
    return self._withShape_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _withShape_II(self,_a_0,_a_1):
   return (self.__withShape_1__3I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _withShape_alt_I(self,_t__a_0):
    return self._withShape_I(numpy.int32(__a_0))
  def _withShape_I(self,_a_0):
   return (self.__withShape_1__3I(numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _withShape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._withShape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withShape__3I(self,_a_0):
   return (self.__withShape_1__3I(mosek.fusion.Utils.Tools._arraycopy__3I(_a_0)))
  def __withShape_1_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__withShape_1__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __withShape_1__3I(self,_a_0):
   self._shape = _a_0
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withNamesOnAxis_alt__3SI(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._withNamesOnAxis__3SI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withNamesOnAxis__3SI(self,_a_0,_a_1):
   if (_a_0 is None):
    self._indexnames = numpy.zeros(((_a_1 + 1),), dtype=numpy.dtype(object))
    self._indexnames[_a_1] = numpy.array([_a_0[_a_2] for _a_2 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_a_1 + 1)):
    _a_3=numpy.ndarray((_a_1,), dtype=numpy.dtype(object))
    for _a_4 in range(0,int((self._indexnames).shape[0])):
     _a_3[_a_4] = self._indexnames[_a_4]
    self._indexnames = _a_3
   self._indexnames[_a_1] = numpy.array([_a_0[_a_5] for _a_5 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__finalize_1and_1validate_1inplace__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __finalize_1and_1validate_1inplace__3I(self,_a_0):
   self._domsize = 1
   if (self._shape is None):
    if (_a_0 is not None):
     self._shape = _a_0
    else:
     raise mosek_fusion_DimensionError._ctor_S("Missing domain shape")
   elif (_a_0 is not None):
    if (int((_a_0).shape[0])!=int((self._shape).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
    for _a_1 in range(0,int((_a_0).shape[0])):
     if (_a_0[_a_1]!=self._shape[_a_1]):
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
   self._domsize = fragments._c_closure_278(self._domsize,self._shape)
   self._domsize = numpy.int64(self._domsize) # postprocess
   if (self._indexnames is not None):
    if (int((self._indexnames).shape[0])!=int((self._shape).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    for _a_2 in range(0,int((self._shape).shape[0])):
     if ((self._indexnames[_a_2] is not None) and (int((self._indexnames[_a_2]).shape[0])!=self._shape[_a_2])):
      raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
   if (not self._axisset):
    self._axisset = True
    self._axisidx = (int((self._shape).shape[0]) - 1)
   elif ((self._axisidx < 0) or (self._axisidx >= int((self._shape).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Cone axis is invalid")
   if ((self._domofs is not None) and (int((self._domofs).shape[0])!=self._domsize)):
    raise mosek_fusion_DimensionError._ctor_S("Domain offset does not match shape")
  def _finalize_1and_1validate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._finalize_1and_1validate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _finalize_1and_1validate__3I(self,_a_0):
   _a_1=mosek_fusion_ConeDomain._ctor_Lmosek_4fusion_4ConeDomain_2(self)
   _a_1.__finalize_1and_1validate_1inplace__3I(_a_0)
   return (_a_1)
 return ConeDomain
mosek_fusion_ConeDomain=__mk_mosek_fusion_ConeDomain()
del __mk_mosek_fusion_ConeDomain
#BEFORE CLASS
def __mk_mosek_fusion_PSDDomain():
 class PSDDomain(object):
  __slots__ = ['_indexnames','_axisIsSet','_conedim2','_conedim1','_key','_shape']
  def axis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.PSDDomain.axis(int32,int32)

    Description
    -----------

    Set the dimension along which the cones are created in a multi-dimensional domain.

    Parameters
    ----------

    conedim1 : int32
    conedim2 : int32
    '''
    if False: pass
    elif mosek_fusion_PSDDomain._match_axis_II(*args):
      return self._axis_II(*args)
    elif mosek_fusion_PSDDomain._match_alt_axis_II(*args):
      return self._axis_alt_II(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDDomain.axis(int32,int32)')
  def withNamesOnAxis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.PSDDomain.withNamesOnAxis(array(string,ndim=1),int32)

    Description
    -----------

    Set index names in a specific axis. 

    Parameters
    ----------

    axis : int32
        The axis to change names on.
    names : array(string,ndim=1)
        List of names, this must match the actual dimension on that axis. 
    '''
    if False: pass
    elif mosek_fusion_PSDDomain._match_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_PSDDomain._match_alt_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.PSDDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
   self._axisIsSet = True
   self._shape = shp
   self._key = k
   (self._conedim1) = conedim1
   (self._conedim2) = conedim2
   self._indexnames = None
   _a_0=int((self._shape).shape[0])
   if ((not ((int((self._shape).shape[0]) > conedim1) and ((int((self._shape).shape[0]) > conedim2) and ((conedim1 >= 0) and ((conedim2 >= 0) and (conedim1!=conedim2)))))) and (self._shape[conedim1]==self._shape[conedim2])):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3I(k,shp):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,shp)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
   mosek_fusion_PSDDomain._ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,(int((shp).shape[0]) - 2),(int((shp).shape[0]) - 1))
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2(k):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2(k)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2(self,k):
    self._ctor_init_Emosek_4fusion_4PSDKey_2(k)
  def _ctor_init_Emosek_4fusion_4PSDKey_2(self,k):
   self._shape = None
   self._key = k
   self._conedim1 = 0
   self._conedim2 = 0
   self._axisIsSet = False
   self._indexnames = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDDomain_2(other):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Lmosek_4fusion_4PSDDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4PSDDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4PSDDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4PSDDomain_2(self,other):
   self._shape = (other._shape)
   self._key = (other._key)
   self._conedim1 = (other._conedim1)
   self._conedim2 = (other._conedim2)
   self._axisIsSet = (other._axisIsSet)
   self._indexnames = (other._indexnames)
  @staticmethod
  def _match_axis_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_axis_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _axis_alt_II(self,_t__a_0,_t__a_1):
    return self._axis_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _axis_II(self,_a_0,_a_1):
   (self._conedim1) = _a_0
   (self._conedim2) = _a_1
   self._axisIsSet = True
   if ((self._shape is None) and (not ((_a_0 >= 0) and ((_a_1 >= 0) and (_a_0!=_a_1))))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   elif ((self._shape is not None) and ((not ((int((self._shape).shape[0]) > _a_0) and ((int((self._shape).shape[0]) > _a_1) and ((_a_0 >= 0) and ((_a_1 >= 0) and (_a_0!=_a_1)))))) and (self._shape[_a_0]==self._shape[_a_1]))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withNamesOnAxis_alt__3SI(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._withNamesOnAxis__3SI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withNamesOnAxis__3SI(self,_a_0,_a_1):
   if (self._indexnames is None):
    self._indexnames = _monty.initJaggedArray([None for _a_2 in range(0,(_a_1 + 1))], 1)
    self._indexnames[_a_1] = numpy.array([_a_0[_a_3] for _a_3 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_a_1 + 1)):
    _a_4=_monty.initJaggedArray([None for _a_5 in range(0,(_a_1 + 1))], 1)
    for _a_6 in range(0,int((self._indexnames).shape[0])):
     _a_4[_a_6] = self._indexnames[_a_6]
    self._indexnames = _a_4
   self._indexnames[_a_1] = numpy.array([_a_0[_a_7] for _a_7 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__finalize_1and_1validate_1inplace__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __finalize_1and_1validate_1inplace__3I(self,_a_0):
   if (_a_0 is not None):
    if (self._shape is None):
     self._shape = _a_0
    else:
     if (int((_a_0).shape[0])!=int((self._shape).shape[0])):
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     for _a_1 in range(0,int((_a_0).shape[0])):
      if (_a_0[_a_1]!=self._shape[_a_1]):
       raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
   if (int((self._shape).shape[0]) < 2):
    raise mosek_fusion_DimensionError._ctor_S("Positive semidefinite domain must have at least two dimensions")
   if (not self._axisIsSet):
    self._conedim1 = (int((self._shape).shape[0]) - 2)
    self._conedim2 = (int((self._shape).shape[0]) - 1)
   if ((self._conedim1 < 0) or ((self._conedim1 >= int((self._shape).shape[0])) or ((self._conedim2 < 0) or ((self._conedim2 >= int((self._shape).shape[0])) or (self._conedim1==self._conedim2))))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone dimension specification")
   if (self._shape[self._conedim1]!=self._shape[self._conedim2]):
    raise mosek_fusion_DimensionError._ctor_S("Cone dimensions must have same size")
   if (self._indexnames is not None):
    if (int((self._indexnames).shape[0])!=int((self._shape).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match the domain shape")
    else:
     for _a_2 in range(0,int((self._shape).shape[0])):
      if ((self._indexnames[_a_2] is not None) and (int((self._indexnames[_a_2]).shape[0])!=self._shape[_a_2])):
       raise mosek_fusion_DimensionError._ctor_S("Index names do not match the domain shape")
  def _finalize_1and_1validate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._finalize_1and_1validate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _finalize_1and_1validate__3I(self,_a_0):
   _a_1=mosek_fusion_PSDDomain._ctor_Lmosek_4fusion_4PSDDomain_2(self)
   _a_1.__finalize_1and_1validate_1inplace__3I(_a_0)
   return (_a_1)
 return PSDDomain
mosek_fusion_PSDDomain=__mk_mosek_fusion_PSDDomain()
del __mk_mosek_fusion_PSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_RangeDomain():
 class RangeDomain(object):
  __slots__ = ['_domsize','_nelements','_indexnames','_cardinal_flag','_scalable','_ub','_lb','_sparsity','_empty','_shape']
  def sparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangeDomain.sparse()
      mosek.fusion.RangeDomain.sparse(array(int32,ndim=1))
      mosek.fusion.RangeDomain.sparse(array(int32,ndim=2))

    Description
    -----------

    Creates a domain exploiting sparsity.

    Parameters
    ----------

    sparsity : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_RangeDomain._match_sparse_(*args):
      return self._sparse_(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse_(*args):
      return self._sparse_alt_(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3I(*args):
      return self._sparse__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3I(*args):
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3_5I(*args):
      return self._sparse__3_5I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3_5I(*args):
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.sparse()\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=2))')
  def integral(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangeDomain.integral()

    Description
    -----------

    Creates a domain of integral variables.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_RangeDomain._match_integral_(*args):
      return self._integral_(*args)
    elif mosek_fusion_RangeDomain._match_alt_integral_(*args):
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.integral()')
  def withNamesOnAxis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangeDomain.withNamesOnAxis(array(string,ndim=1),int32)

    Description
    -----------

    Set index names in a specific axis. 

    Parameters
    ----------

    axis : int32
        The axis to change names on.
    names : array(string,ndim=1)
        List of names, this must match the actual dimension on that axis. 
    '''
    if False: pass
    elif mosek_fusion_RangeDomain._match_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_RangeDomain._match_alt_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def withShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.RangeDomain.withShape(array(int32,ndim=1))
      mosek.fusion.RangeDomain.withShape(int32)
      mosek.fusion.RangeDomain.withShape(int32,int32)
      mosek.fusion.RangeDomain.withShape(int32,int32,int32)

    Description
    -----------

    Set the shape of the domain.  

    Parameters
    ----------

    dim0 : int32
        First dimension
    dim1 : int32
        Second dimension
    dim2 : int32
        Third dimension
    shp : array(int32,ndim=1)
        The shape of the domain
    '''
    if False: pass
    elif mosek_fusion_RangeDomain._match_withShape__3I(*args):
      return self._withShape__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape__3I(*args):
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_withShape_I(*args):
      return self._withShape_I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_I(*args):
      return self._withShape_alt_I(*args)
    elif mosek_fusion_RangeDomain._match_withShape_II(*args):
      return self._withShape_II(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_II(*args):
      return self._withShape_alt_II(*args)
    elif mosek_fusion_RangeDomain._match_withShape_III(*args):
      return self._withShape_III(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_III(*args):
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.withShape(int32)\n\tmosek.fusion.RangeDomain.withShape(int32,int32)\n\tmosek.fusion.RangeDomain.withShape(int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.RangeDomain'
  @staticmethod
  def _ctor_Z_3D_3D_3I(scalable,lb,ub,dims):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I(scalable,lb,ub,dims)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
    self._ctor_init_Z_3D_3D_3I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,None,1)
  @staticmethod
  def _ctor_ZDD_3I(scalable,lb,ub,dims):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_ZDD_3I(scalable,lb,ub,dims)
    return o
  @staticmethod
  def __match_ctor_ZDD_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_match_Z__(scalable) and __arg_match_D__(lb) and __arg_match_D__(ub) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_ZDD_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match_D__(lb) and __arg_alt_match_D__(ub) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_ZDD_3I(self,scalable,lb,ub,dims):
    self._ctor_init_ZDD_3I(scalable,numpy.float64(lb),numpy.float64(ub),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_ZDD_3I(self,scalable,lb,ub,dims):
   self._cardinal_flag = False
   self._shape = dims
   self._sparsity = None
   (self._scalable) = scalable
   _a_0=1
   _a_0 = fragments._c_closure_279(dims,_a_0)
   _a_0 = numpy.int32(_a_0) # postprocess
   (self._ub) = numpy.array([ub for _a_1 in range(0,_a_0)], dtype=numpy.dtype(numpy.float64))
   (self._lb) = numpy.array([lb for _a_2 in range(0,_a_0)], dtype=numpy.dtype(numpy.float64))
   (self._empty) = False
   (self._indexnames) = None
   (self._domsize) = 0
   (self._nelements) = 0
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp))
  def _ctor_alt_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
    self._ctor_init_Z_3D_3D_3I_3_5I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
    self._ctor_init_Z_3D_3D_3I_3_5II(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
   self._cardinal_flag = False
   self._shape = dims
   self._sparsity = None
   (self._scalable) = scalable
   (self._ub) = ub
   (self._lb) = lb
   (self._sparsity) = sp
   (self._empty) = False
   (self._indexnames) = None
   (self._domsize) = 0
   (self._nelements) = 0
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   self._scalable = (other._scalable)
   self._shape = (other._shape)
   self._ub = (other._ub)
   self._lb = (other._lb)
   self._domsize = (other._domsize)
   self._nelements = (other._nelements)
   self._empty = (other._empty)
   self._indexnames = (_monty.initJaggedArray([(other._indexnames)[_a_0] for _a_0 in range(0,int(((other._indexnames)).shape[0]))], 1) if (((other._indexnames) is not None) ) else None)
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _sparse_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._sparse__3_5I(_a_0)
   return _1_res
  def _sparse__3_5I(self,_a_0):
   (self._sparsity) = numpy.zeros((int((_a_0).shape[0]),int((_a_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _a_1=0
   while (_a_1 < int((_a_0).shape[0])):
    _a_2=0
    while (_a_2 < int((_a_0).shape[1])):
     (self._sparsity)[_a_1,_a_2] = _a_0[_a_1,_a_2]
     _a_2 += 1
    _a_1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _sparse_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._sparse__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _sparse__3I(self,_a_0):
   (self._sparsity) = numpy.zeros((int((_a_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _a_1 in range(0,int((_a_0).shape[0])):
    (self._sparsity)[_a_1,0] = _a_0[_a_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _withShape_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._withShape_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _withShape_III(self,_a_0,_a_1,_a_2):
   self._shape = numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withShape_alt_II(self,_t__a_0,_t__a_1):
    return self._withShape_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _withShape_II(self,_a_0,_a_1):
   self._shape = numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _withShape_alt_I(self,_t__a_0):
    return self._withShape_I(numpy.int32(__a_0))
  def _withShape_I(self,_a_0):
   self._shape = numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _withShape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._withShape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withShape__3I(self,_a_0):
   self._shape = _a_0
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withNamesOnAxis_alt__3SI(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._withNamesOnAxis__3SI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withNamesOnAxis__3SI(self,_a_0,_a_1):
   if (self._indexnames is None):
    self._indexnames = _monty.initJaggedArray([None for _a_2 in range(0,(_a_1 + 1))], 1)
    self._indexnames[_a_1] = numpy.array([_a_0[_a_3] for _a_3 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_a_1 + 1)):
    _a_4=_monty.initJaggedArray([None for _a_5 in range(0,(_a_1 + 1))], 1)
    for _a_6 in range(0,int((self._indexnames).shape[0])):
     _a_4[_a_6] = self._indexnames[_a_6]
    self._indexnames = _a_4
   self._indexnames[_a_1] = numpy.array([_a_0[_a_7] for _a_7 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def _match_1shape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._match_1shape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _match_1shape__3I(self,_a_0):
   if self._scalable:
    return (True)
   elif (int((self._shape).shape[0])!=int((_a_0).shape[0])):
    return (False)
   else:
    for _a_1 in range(0,int((self._shape).shape[0])):
     if (self._shape[_a_1]!=_a_0[_a_1]):
      return (False)
   return (True)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__finalize_1and_1validate_1inplace__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __finalize_1and_1validate_1inplace__3I(self,_a_0):
   self._domsize = 1
   if self._scalable:
    if (_a_0 is not None):
     self._shape = _a_0
    else:
     self._shape = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._domsize = fragments._c_closure_280(self._domsize,self._shape)
    self._domsize = numpy.int64(self._domsize) # postprocess
   else:
    if (_a_0 is not None):
     if (int((_a_0).shape[0])!=int((self._shape).shape[0])):
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     for _a_1 in range(0,int((_a_0).shape[0])):
      if (_a_0[_a_1]!=self._shape[_a_1]):
       raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
    self._domsize = fragments._c_closure_281(self._domsize,self._shape)
    self._domsize = numpy.int64(self._domsize) # postprocess
   if (self._indexnames is not None):
    if (int((self._indexnames).shape[0])!=int((self._shape).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    for _a_2 in range(0,int((self._shape).shape[0])):
     if ((self._indexnames[_a_2] is not None) and (int((self._indexnames[_a_2]).shape[0])!=self._shape[_a_2])):
      raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
   if (self._sparsity is not None):
    self._nelements = int((self._sparsity).shape[0])
    if (int((self._shape).shape[0])!=int((self._sparsity).shape[1])):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and sparsity pattern")
    for _a_3 in range(0,self._nelements):
     for _a_4 in range(0,int((self._sparsity).shape[1])):
      if ((self._sparsity[_a_3,_a_4] < 0) or (self._sparsity[_a_3,_a_4] >= self._shape[_a_4])):
       raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern entry is out of bounds")
    if ((not self._scalable) and ((self._lb is not None) and (int((self._lb).shape[0])!=self._nelements))):
     raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern does not match bound")
    if ((not self._scalable) and ((self._ub is not None) and (int((self._ub).shape[0])!=self._nelements))):
     raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern does not match bound")
   else:
    self._nelements = self._domsize
    if ((self._lb is not None) and (not self._scalable)):
     if (int((self._lb).shape[0])!=self._nelements):
      raise mosek_fusion_DimensionError._ctor_S("Domain bound does not match shape")
    if ((self._ub is not None) and (not self._scalable)):
     if (int((self._ub).shape[0])!=self._nelements):
      raise mosek_fusion_DimensionError._ctor_S("Domain bound does not match shape")
  def _finalize_1and_1validate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._finalize_1and_1validate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _finalize_1and_1validate__3I(self,_a_0):
   _a_1=mosek_fusion_RangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self)
   _a_1.__finalize_1and_1validate_1inplace__3I(_a_0)
   return (_a_1)
 return RangeDomain
mosek_fusion_RangeDomain=__mk_mosek_fusion_RangeDomain()
del __mk_mosek_fusion_RangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinearDomain():
 class LinearDomain(object):
  __slots__ = ['_nelements','_domsize','_indexnames','_empty','_scalable','_sparsity','_cardinal_flag','_key','_bnd','_shape']
  def sparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearDomain.sparse()
      mosek.fusion.LinearDomain.sparse(array(int32,ndim=1))
      mosek.fusion.LinearDomain.sparse(array(int32,ndim=2))

    Description
    -----------

    Creates a domain exploiting sparsity.

    Parameters
    ----------

    sparsity : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_LinearDomain._match_sparse_(*args):
      return self._sparse_(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse_(*args):
      return self._sparse_alt_(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3I(*args):
      return self._sparse__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3I(*args):
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3_5I(*args):
      return self._sparse__3_5I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3_5I(*args):
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.sparse()\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=2))')
  def withShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearDomain.withShape(array(int32,ndim=1))
      mosek.fusion.LinearDomain.withShape(int32)
      mosek.fusion.LinearDomain.withShape(int32,int32)
      mosek.fusion.LinearDomain.withShape(int32,int32,int32)

    Description
    -----------

    Set the shape of the domain.  

    Parameters
    ----------

    dim0 : int32
        First dimension
    dim1 : int32
        Second dimension
    dim2 : int32
        Third dimension
    shp : array(int32,ndim=1)
        The shape of the domain
    '''
    if False: pass
    elif mosek_fusion_LinearDomain._match_withShape__3I(*args):
      return self._withShape__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape__3I(*args):
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_withShape_I(*args):
      return self._withShape_I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_I(*args):
      return self._withShape_alt_I(*args)
    elif mosek_fusion_LinearDomain._match_withShape_II(*args):
      return self._withShape_II(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_II(*args):
      return self._withShape_alt_II(*args)
    elif mosek_fusion_LinearDomain._match_withShape_III(*args):
      return self._withShape_III(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_III(*args):
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.withShape(int32)\n\tmosek.fusion.LinearDomain.withShape(int32,int32)\n\tmosek.fusion.LinearDomain.withShape(int32,int32,int32)')
  def integral(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearDomain.integral()

    Description
    -----------

    Creates a domain of integral variables.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinearDomain._match_integral_(*args):
      return self._integral_(*args)
    elif mosek_fusion_LinearDomain._match_alt_integral_(*args):
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.integral()')
  def withNamesOnAxis(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinearDomain.withNamesOnAxis(array(string,ndim=1),int32)

    Description
    -----------

    Set index names in a specific axis. 

    Parameters
    ----------

    axis : int32
        The axis to change names on.
    names : array(string,ndim=1)
        List of names, this must match the actual dimension on that axis. 
    '''
    if False: pass
    elif mosek_fusion_LinearDomain._match_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_LinearDomain._match_alt_withNamesOnAxis__3SI(*args):
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.LinearDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
   mosek_fusion_LinearDomain._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,None,1)
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
   (self._scalable) = scalable
   (self._shape) = dims
   (self._key) = k
   (self._bnd) = rhs
   (self._sparsity) = sp
   (self._cardinal_flag) = False
   (self._empty) = False
   self._indexnames = None
   (self._domsize) = 0
   (self._nelements) = 0
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._scalable = (other._scalable)
   self._nelements = (other._nelements)
   self._domsize = (other._domsize)
   self._shape = (other._shape)
   self._key = (other._key)
   self._bnd = (other._bnd)
   self._sparsity = (other._sparsity)
   self._cardinal_flag = (other._cardinal_flag)
   self._empty = (other._empty)
   self._indexnames = (other._indexnames)
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _sparse_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._sparse__3_5I(_a_0)
   return _1_res
  def _sparse__3_5I(self,_a_0):
   (self._sparsity) = numpy.zeros((int((_a_0).shape[0]),int((_a_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   _a_1=0
   while (_a_1 < int((_a_0).shape[0])):
    _a_2=0
    while (_a_2 < int((_a_0).shape[1])):
     (self._sparsity)[_a_1,_a_2] = _a_0[_a_1,_a_2]
     _a_2 += 1
    _a_1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _sparse_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._sparse__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _sparse__3I(self,_a_0):
   (self._sparsity) = numpy.zeros((int((_a_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   for _a_1 in range(0,int((_a_0).shape[0])):
    (self._sparsity)[_a_1,0] = _a_0[_a_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _withShape_alt_III(self,_t__a_0,_t__a_1,_t__a_2):
    return self._withShape_III(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  def _withShape_III(self,_a_0,_a_1,_a_2):
   self._shape = numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withShape_alt_II(self,_t__a_0,_t__a_1):
    return self._withShape_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _withShape_II(self,_a_0,_a_1):
   self._shape = numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _withShape_alt_I(self,_t__a_0):
    return self._withShape_I(numpy.int32(__a_0))
  def _withShape_I(self,_a_0):
   self._shape = numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _withShape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._withShape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withShape__3I(self,_a_0):
   self._shape = _a_0
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3S__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3S__(_a_0) and __arg_alt_match_I__(_a_1))
  def _withNamesOnAxis_alt__3SI(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._withNamesOnAxis__3SI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _withNamesOnAxis__3SI(self,_a_0,_a_1):
   if (self._indexnames is None):
    self._indexnames = _monty.initJaggedArray([None for _a_2 in range(0,(_a_1 + 1))], 1)
    self._indexnames[_a_1] = numpy.array([_a_0[_a_3] for _a_3 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_a_1 + 1)):
    _a_4=_monty.initJaggedArray([None for _a_5 in range(0,(_a_1 + 1))], 1)
    for _a_6 in range(0,int((self._indexnames).shape[0])):
     _a_4[_a_6] = self._indexnames[_a_6]
    self._indexnames = _a_4
   self._indexnames[_a_1] = numpy.array([_a_0[_a_7] for _a_7 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def _match_1shape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._match_1shape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _match_1shape__3I(self,_a_0):
   if (not self._scalable):
    for _a_1 in range(0,int((_a_0).shape[0])):
     if (_a_0[_a_1]==self._shape[_a_1]):
      return (False)
   return (True)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__finalize_1and_1validate_1inplace__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __finalize_1and_1validate_1inplace__3I(self,_a_0):
   if self._scalable:
    if (self._shape is None):
     if ((self._sparsity is not None) and (_a_0 is None)):
      raise mosek_fusion_DimensionError._ctor_S("Sparse domain requires a fixed shape")
     if (_a_0 is not None):
      self._shape = _a_0
     else:
      self._shape = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   else:
    if (_a_0 is not None):
     if (int((_a_0).shape[0])!=int((self._shape).shape[0])):
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     for _a_1 in range(0,int((_a_0).shape[0])):
      if (_a_0[_a_1]!=self._shape[_a_1]):
       raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
   if (self._indexnames is not None):
    if (int((self._indexnames).shape[0]) > int((self._shape).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    for _a_2 in range(0,int((self._indexnames).shape[0])):
     if ((self._indexnames[_a_2] is not None) and (int((self._indexnames[_a_2]).shape[0])!=self._shape[_a_2])):
      raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    if (int((self._indexnames).shape[0]) < int((self._shape).shape[0])):
     _a_3=numpy.ndarray((int((self._shape).shape[0]),), dtype=numpy.dtype(object))
     for _a_4 in range(0,int((self._indexnames).shape[0])):
      _a_3[_a_4] = self._indexnames[_a_4]
     self._indexnames = _a_3
   self._domsize = 1
   self._domsize = fragments._c_closure_282(self._domsize,self._shape)
   self._domsize = numpy.int64(self._domsize) # postprocess
   if (self._sparsity is not None):
    self._nelements = int((self._sparsity).shape[0])
    if (int((self._shape).shape[0])!=int((self._sparsity).shape[1])):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and sparsity pattern")
    for _a_5 in range(0,self._nelements):
     for _a_6 in range(0,int((self._sparsity).shape[1])):
      if ((self._sparsity[_a_5,_a_6] < 0) or (self._sparsity[_a_5,_a_6] >= self._shape[_a_6])):
       raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern entry is out of bounds")
    if ((not self._scalable) and ((self._bnd is not None) and (int((self._bnd).shape[0])!=self._nelements))):
     raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern does not match bound")
   else:
    self._nelements = self._domsize
    if ((self._bnd is not None) and (not self._scalable)):
     if (int((self._bnd).shape[0])!=self._nelements):
      raise mosek_fusion_DimensionError._ctor_S("Domain bound does not match shape")
  def _finalize_1and_1validate_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._finalize_1and_1validate__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _finalize_1and_1validate__3I(self,_a_0):
   _a_1=mosek_fusion_LinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self)
   _a_1.__finalize_1and_1validate_1inplace__3I(_a_0)
   return (_a_1)
 return LinearDomain
mosek_fusion_LinearDomain=__mk_mosek_fusion_LinearDomain()
del __mk_mosek_fusion_LinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_Domain():
 class Domain(object):
  @staticmethod
  def inDExpCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inDExpCone()
      mosek.fusion.Domain.inDExpCone(int32)
      mosek.fusion.Domain.inDExpCone(array(int32,ndim=1))

    Description
    -----------

    Defines the dual exponential cone. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inDExpCone_(*args):
      return mosek_fusion_Domain._inDExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_(*args):
      return mosek_fusion_Domain._inDExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inDExpCone_I(*args):
      return mosek_fusion_Domain._inDExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_I(*args):
      return mosek_fusion_Domain._inDExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inDExpCone__3I(*args):
      return mosek_fusion_Domain._inDExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone__3I(*args):
      return mosek_fusion_Domain._inDExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inDExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDExpCone()\n\tmosek.fusion.Domain.inDExpCone(int32)\n\tmosek.fusion.Domain.inDExpCone(array(int32,ndim=1))')
  @staticmethod
  def axis(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.axis(mosek.fusion.ConeDomain,int32)

    Description
    -----------

    Set the dimension along which the cones are created. 

    Parameters
    ----------

    a : int32
        The axis.
    c : mosek.fusion.ConeDomain
        A conic domain.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
      return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(*args)
    elif mosek_fusion_Domain._match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
      return mosek_fusion_Domain._axis_alt_Lmosek_4fusion_4ConeDomain_2I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.axis(mosek.fusion.ConeDomain,int32)')
  @staticmethod
  def inQCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inQCone()
      mosek.fusion.Domain.inQCone(int32)
      mosek.fusion.Domain.inQCone(array(int32,ndim=1))
      mosek.fusion.Domain.inQCone(int32,int32)

    Description
    -----------

    Defines the domain of quadratic cones. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    n : int32
        The size of each cone; at least 2.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inQCone_(*args):
      return mosek_fusion_Domain._inQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_(*args):
      return mosek_fusion_Domain._inQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inQCone_I(*args):
      return mosek_fusion_Domain._inQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_I(*args):
      return mosek_fusion_Domain._inQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inQCone__3I(*args):
      return mosek_fusion_Domain._inQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone__3I(*args):
      return mosek_fusion_Domain._inQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inQCone_II(*args):
      return mosek_fusion_Domain._inQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_II(*args):
      return mosek_fusion_Domain._inQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inQCone()\n\tmosek.fusion.Domain.inQCone(int32)\n\tmosek.fusion.Domain.inQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inQCone(int32,int32)')
  @staticmethod
  def unbounded(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.unbounded()
      mosek.fusion.Domain.unbounded(int32)
      mosek.fusion.Domain.unbounded(array(int32,ndim=1))
      mosek.fusion.Domain.unbounded(int32,int32)

    Description
    -----------

    Creates a domain in which variables are unbounded.

    Parameters
    ----------

    dims : array(int32,ndim=1)
        A list of dimension sizes.
    m : int32
        Dimension size.
    n : int32
        Dimension size.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_unbounded_(*args):
      return mosek_fusion_Domain._unbounded_(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_(*args):
      return mosek_fusion_Domain._unbounded_alt_(*args)
    elif mosek_fusion_Domain._match_unbounded_I(*args):
      return mosek_fusion_Domain._unbounded_I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_I(*args):
      return mosek_fusion_Domain._unbounded_alt_I(*args)
    elif mosek_fusion_Domain._match_unbounded__3I(*args):
      return mosek_fusion_Domain._unbounded__3I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded__3I(*args):
      return mosek_fusion_Domain._unbounded_alt__3I(*args)
    elif mosek_fusion_Domain._match_unbounded_II(*args):
      return mosek_fusion_Domain._unbounded_II(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_II(*args):
      return mosek_fusion_Domain._unbounded_alt_II(*args)
    else:
      raise ValueError('Invalid argument list unbounded('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.unbounded()\n\tmosek.fusion.Domain.unbounded(int32)\n\tmosek.fusion.Domain.unbounded(array(int32,ndim=1))\n\tmosek.fusion.Domain.unbounded(int32,int32)')
  @staticmethod
  def inPPowerCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inPPowerCone(array(double,ndim=1))
      mosek.fusion.Domain.inPPowerCone(double)
      mosek.fusion.Domain.inPPowerCone(double,array(int32,ndim=1))
      mosek.fusion.Domain.inPPowerCone(array(double,ndim=1),int32)
      mosek.fusion.Domain.inPPowerCone(double,int32)
      mosek.fusion.Domain.inPPowerCone(array(double,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Defines the primal power cone. 

    Parameters
    ----------

    alpha : double
        The exponent of the power cone. Must be between 0 and 1.
    alphas : array(double,ndim=1)
        The weights of the power cone. Must be positive.
    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inPPowerCone__3D(*args):
      return mosek_fusion_Domain._inPPowerCone__3D(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone__3D(*args):
      return mosek_fusion_Domain._inPPowerCone_alt__3D(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_D(*args):
      return mosek_fusion_Domain._inPPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D(*args):
      return mosek_fusion_Domain._inPPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_D_3I(*args):
      return mosek_fusion_Domain._inPPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D_3I(*args):
      return mosek_fusion_Domain._inPPowerCone_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_inPPowerCone__3DI(*args):
      return mosek_fusion_Domain._inPPowerCone__3DI(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone__3DI(*args):
      return mosek_fusion_Domain._inPPowerCone_alt__3DI(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_DI(*args):
      return mosek_fusion_Domain._inPPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_DI(*args):
      return mosek_fusion_Domain._inPPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inPPowerCone__3D_3I(*args):
      return mosek_fusion_Domain._inPPowerCone__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone__3D_3I(*args):
      return mosek_fusion_Domain._inPPowerCone_alt__3D_3I(*args)
    else:
      raise ValueError('Invalid argument list inPPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPPowerCone(array(double,ndim=1))\n\tmosek.fusion.Domain.inPPowerCone(double)\n\tmosek.fusion.Domain.inPPowerCone(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inPPowerCone(array(double,ndim=1),int32)\n\tmosek.fusion.Domain.inPPowerCone(double,int32)\n\tmosek.fusion.Domain.inPPowerCone(array(double,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def inRange(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))
      mosek.fusion.Domain.inRange(array(double,ndim=1),double)
      mosek.fusion.Domain.inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)
      mosek.fusion.Domain.inRange(double,array(double,ndim=1))
      mosek.fusion.Domain.inRange(array(double,ndim=2),array(double,ndim=2))
      mosek.fusion.Domain.inRange(double,double)
      mosek.fusion.Domain.inRange(double,array(double,ndim=1),array(int32,ndim=1))
      mosek.fusion.Domain.inRange(array(double,ndim=1),double,array(int32,ndim=1))
      mosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1))
      mosek.fusion.Domain.inRange(double,double,array(int32,ndim=1))

    Description
    -----------

    Creates a domain specified by a range in each dimension. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        A list of dimension sizes. 
    lb : double
        The lower bound as a common scalar value. 
    lba : array(double,ndim=1)
        The lower bounds as an array. 
    lbm : mosek.fusion.Matrix
        The lower bounds as a :msk:func:`Matrix` object. 
    ub : double
        The upper bound as a common scalar value.
    uba : array(double,ndim=1)
        The upper bounds as an array. 
    ubm : mosek.fusion.Matrix
        The upper bounds as a :msk:func:`Matrix` object. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inRange__3D_3D(*args):
      return mosek_fusion_Domain._inRange__3D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D(*args):
      return mosek_fusion_Domain._inRange_alt__3D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3DD(*args):
      return mosek_fusion_Domain._inRange__3DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD(*args):
      return mosek_fusion_Domain._inRange_alt__3DD(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D(*args):
      return mosek_fusion_Domain._inRange_D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D(*args):
      return mosek_fusion_Domain._inRange_alt_D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3_5D_3_5D(*args):
      return mosek_fusion_Domain._inRange__3_5D_3_5D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3_5D_3_5D(*args):
      return mosek_fusion_Domain._inRange_alt__3_5D_3_5D(*args)
    elif mosek_fusion_Domain._match_inRange_DD(*args):
      return mosek_fusion_Domain._inRange_DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD(*args):
      return mosek_fusion_Domain._inRange_alt_DD(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D_3I(*args):
      return mosek_fusion_Domain._inRange_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D_3I(*args):
      return mosek_fusion_Domain._inRange_alt_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3DD_3I(*args):
      return mosek_fusion_Domain._inRange__3DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD_3I(*args):
      return mosek_fusion_Domain._inRange_alt__3DD_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D_3I(*args):
      return mosek_fusion_Domain._inRange__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D_3I(*args):
      return mosek_fusion_Domain._inRange_alt__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange_DD_3I(*args):
      return mosek_fusion_Domain._inRange_DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD_3I(*args):
      return mosek_fusion_Domain._inRange_alt_DD_3I(*args)
    else:
      raise ValueError('Invalid argument list inRange('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=2),array(double,ndim=2))\n\tmosek.fusion.Domain.inRange(double,double)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(double,double,array(int32,ndim=1))')
  @staticmethod
  def isTrilPSD(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.isTrilPSD()
      mosek.fusion.Domain.isTrilPSD(int32)
      mosek.fusion.Domain.isTrilPSD(int32,int32)

    Description
    -----------

    Creates a domain of Positive Semidefinite matrices.

    Parameters
    ----------

    m : int32
        Number of matrices (default 1). 
    n : int32
        Dimension of the PSD matrix. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_isTrilPSD_(*args):
      return mosek_fusion_Domain._isTrilPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_(*args):
      return mosek_fusion_Domain._isTrilPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_I(*args):
      return mosek_fusion_Domain._isTrilPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_I(*args):
      return mosek_fusion_Domain._isTrilPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_II(*args):
      return mosek_fusion_Domain._isTrilPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_II(*args):
      return mosek_fusion_Domain._isTrilPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isTrilPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isTrilPSD()\n\tmosek.fusion.Domain.isTrilPSD(int32)\n\tmosek.fusion.Domain.isTrilPSD(int32,int32)')
  @staticmethod
  def greaterThan(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.greaterThan(array(double,ndim=1))
      mosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)
      mosek.fusion.Domain.greaterThan(array(double,ndim=2))
      mosek.fusion.Domain.greaterThan(double)
      mosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))
      mosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))
      mosek.fusion.Domain.greaterThan(double,int32)
      mosek.fusion.Domain.greaterThan(double,int32,int32)

    Description
    -----------

    Defines the domain specified by a lower bound in each dimension.

    Parameters
    ----------

    a1 : array(double,ndim=1)
        A one-dimensional array of bounds. The shape must match the variable or constraint with which it is used. 
    a2 : array(double,ndim=2)
        A two-dimensional array of bounds. The shape must match the variable or constraint with which it is used. 
    b : double
        A single value. This is scalable: it means that each element in the variable or constraint is greater than or equal to :math:`b`. 
    dims : array(int32,ndim=1)
        A list of dimension sizes. 
    m : int32
        Dimension size. 
    mx : mosek.fusion.Matrix
        A matrix of bound values. The shape must match the variable or constraint with which it is used. 
    n : int32
        Dimension size. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_greaterThan__3D(*args):
      return mosek_fusion_Domain._greaterThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D(*args):
      return mosek_fusion_Domain._greaterThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._greaterThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_greaterThan__3_5D(*args):
      return mosek_fusion_Domain._greaterThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3_5D(*args):
      return mosek_fusion_Domain._greaterThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D(*args):
      return mosek_fusion_Domain._greaterThan_D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D(*args):
      return mosek_fusion_Domain._greaterThan_alt_D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D_3I(*args):
      return mosek_fusion_Domain._greaterThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D_3I(*args):
      return mosek_fusion_Domain._greaterThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan__3D_3I(*args):
      return mosek_fusion_Domain._greaterThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D_3I(*args):
      return mosek_fusion_Domain._greaterThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan_DI(*args):
      return mosek_fusion_Domain._greaterThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DI(*args):
      return mosek_fusion_Domain._greaterThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_greaterThan_DII(*args):
      return mosek_fusion_Domain._greaterThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DII(*args):
      return mosek_fusion_Domain._greaterThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list greaterThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1))\n\tmosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=2))\n\tmosek.fusion.Domain.greaterThan(double)\n\tmosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(double,int32)\n\tmosek.fusion.Domain.greaterThan(double,int32,int32)')
  @staticmethod
  def equalsTo(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.equalsTo(array(double,ndim=1))
      mosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)
      mosek.fusion.Domain.equalsTo(array(double,ndim=2))
      mosek.fusion.Domain.equalsTo(double)
      mosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))
      mosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))
      mosek.fusion.Domain.equalsTo(double,int32)
      mosek.fusion.Domain.equalsTo(double,int32,int32)

    Description
    -----------

    Defines the domain consisting of a fixed point. 

    Parameters
    ----------

    a1 : array(double,ndim=1)
        A one-dimensional array of bounds. The shape must match the variable or constraint with which it is used. 
    a2 : array(double,ndim=2)
        A two-dimensional array of bounds. The shape must match the variable or constraint with which it is used. 
    b : double
        A single value. This is scalable: it means that each element in the variable or constraint is fixed to :math:`b`. 
    dims : array(int32,ndim=1)
        A list of dimension sizes. 
    m : int32
        Dimension size. 
    mx : mosek.fusion.Matrix
        A matrix of bound values. The shape must match the variable or constraint with which it is used. 
    n : int32
        Dimension size. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_equalsTo__3D(*args):
      return mosek_fusion_Domain._equalsTo__3D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D(*args):
      return mosek_fusion_Domain._equalsTo_alt__3D(*args)
    elif mosek_fusion_Domain._match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._equalsTo_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_equalsTo__3_5D(*args):
      return mosek_fusion_Domain._equalsTo__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3_5D(*args):
      return mosek_fusion_Domain._equalsTo_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D(*args):
      return mosek_fusion_Domain._equalsTo_D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D(*args):
      return mosek_fusion_Domain._equalsTo_alt_D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D_3I(*args):
      return mosek_fusion_Domain._equalsTo_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D_3I(*args):
      return mosek_fusion_Domain._equalsTo_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo__3D_3I(*args):
      return mosek_fusion_Domain._equalsTo__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D_3I(*args):
      return mosek_fusion_Domain._equalsTo_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo_DI(*args):
      return mosek_fusion_Domain._equalsTo_DI(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DI(*args):
      return mosek_fusion_Domain._equalsTo_alt_DI(*args)
    elif mosek_fusion_Domain._match_equalsTo_DII(*args):
      return mosek_fusion_Domain._equalsTo_DII(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DII(*args):
      return mosek_fusion_Domain._equalsTo_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list equalsTo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1))\n\tmosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=2))\n\tmosek.fusion.Domain.equalsTo(double)\n\tmosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(double,int32)\n\tmosek.fusion.Domain.equalsTo(double,int32,int32)')
  @staticmethod
  def inDGeoMeanCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inDGeoMeanCone()
      mosek.fusion.Domain.inDGeoMeanCone(int32)
      mosek.fusion.Domain.inDGeoMeanCone(array(int32,ndim=1))
      mosek.fusion.Domain.inDGeoMeanCone(int32,int32)

    Description
    -----------

    Defines the domain of dual geometric mean cones. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    n : int32
        The size of each cone; at least 2.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inDGeoMeanCone_(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone_(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_alt_(*args)
    elif mosek_fusion_Domain._match_inDGeoMeanCone_I(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone_I(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inDGeoMeanCone__3I(*args):
      return mosek_fusion_Domain._inDGeoMeanCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone__3I(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inDGeoMeanCone_II(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone_II(*args):
      return mosek_fusion_Domain._inDGeoMeanCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inDGeoMeanCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDGeoMeanCone()\n\tmosek.fusion.Domain.inDGeoMeanCone(int32)\n\tmosek.fusion.Domain.inDGeoMeanCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inDGeoMeanCone(int32,int32)')
  @staticmethod
  def integral(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.integral(mosek.fusion.ConeDomain)
      mosek.fusion.Domain.integral(mosek.fusion.LinearDomain)
      mosek.fusion.Domain.integral(mosek.fusion.RangeDomain)

    Description
    -----------

    Creates a domain of integral variables.

    Parameters
    ----------

    c : mosek.fusion.ConeDomain
        A conic domain.
    ld : mosek.fusion.LinearDomain
        A linear domain.
    rd : mosek.fusion.RangeDomain
        A ranged domain.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4ConeDomain_2(*args):
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args):
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.integral(mosek.fusion.ConeDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.RangeDomain)')
  @staticmethod
  def inSVecPSDCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inSVecPSDCone()
      mosek.fusion.Domain.inSVecPSDCone(int32)
      mosek.fusion.Domain.inSVecPSDCone(array(int32,ndim=1))
      mosek.fusion.Domain.inSVecPSDCone(int32,int32)

    Description
    -----------

    Creates a domain of vectorized Positive Semidefinite matrices.

    Parameters
    ----------

    d1 : int32
        Size of first dimension of the domain. 
    d2 : int32
        Size of second dimension of the domain. 
    dims : array(int32,ndim=1)
        Shape of the domain. 
    n : int32
        Length of the vectorization - this must be of the form :math:`d*(d+1)/2` for some positive integer :math:`d`. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inSVecPSDCone_(*args):
      return mosek_fusion_Domain._inSVecPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone_(*args):
      return mosek_fusion_Domain._inSVecPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inSVecPSDCone_I(*args):
      return mosek_fusion_Domain._inSVecPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone_I(*args):
      return mosek_fusion_Domain._inSVecPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inSVecPSDCone__3I(*args):
      return mosek_fusion_Domain._inSVecPSDCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone__3I(*args):
      return mosek_fusion_Domain._inSVecPSDCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inSVecPSDCone_II(*args):
      return mosek_fusion_Domain._inSVecPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone_II(*args):
      return mosek_fusion_Domain._inSVecPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inSVecPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inSVecPSDCone()\n\tmosek.fusion.Domain.inSVecPSDCone(int32)\n\tmosek.fusion.Domain.inSVecPSDCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inSVecPSDCone(int32,int32)')
  @staticmethod
  def inPGeoMeanCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inPGeoMeanCone()
      mosek.fusion.Domain.inPGeoMeanCone(int32)
      mosek.fusion.Domain.inPGeoMeanCone(array(int32,ndim=1))
      mosek.fusion.Domain.inPGeoMeanCone(int32,int32)

    Description
    -----------

    Defines the domain of primal geometric mean cones. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    n : int32
        The size of each cone; at least 2.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inPGeoMeanCone_(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone_(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPGeoMeanCone_I(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone_I(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPGeoMeanCone__3I(*args):
      return mosek_fusion_Domain._inPGeoMeanCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone__3I(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inPGeoMeanCone_II(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone_II(*args):
      return mosek_fusion_Domain._inPGeoMeanCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPGeoMeanCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPGeoMeanCone()\n\tmosek.fusion.Domain.inPGeoMeanCone(int32)\n\tmosek.fusion.Domain.inPGeoMeanCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inPGeoMeanCone(int32,int32)')
  @staticmethod
  def inPExpCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inPExpCone()
      mosek.fusion.Domain.inPExpCone(int32)
      mosek.fusion.Domain.inPExpCone(array(int32,ndim=1))

    Description
    -----------

    Defines the primal exponential cone. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inPExpCone_(*args):
      return mosek_fusion_Domain._inPExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_(*args):
      return mosek_fusion_Domain._inPExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPExpCone_I(*args):
      return mosek_fusion_Domain._inPExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_I(*args):
      return mosek_fusion_Domain._inPExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPExpCone__3I(*args):
      return mosek_fusion_Domain._inPExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone__3I(*args):
      return mosek_fusion_Domain._inPExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inPExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPExpCone()\n\tmosek.fusion.Domain.inPExpCone(int32)\n\tmosek.fusion.Domain.inPExpCone(array(int32,ndim=1))')
  @staticmethod
  def inDPowerCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inDPowerCone(array(double,ndim=1))
      mosek.fusion.Domain.inDPowerCone(double)
      mosek.fusion.Domain.inDPowerCone(double,array(int32,ndim=1))
      mosek.fusion.Domain.inDPowerCone(array(double,ndim=1),int32)
      mosek.fusion.Domain.inDPowerCone(double,int32)
      mosek.fusion.Domain.inDPowerCone(array(double,ndim=1),array(int32,ndim=1))

    Description
    -----------

    Defines the dual power cone. 

    Parameters
    ----------

    alpha : double
        The exponent of the power cone. Must be between 0 and 1.
    alphas : array(double,ndim=1)
        The weights of the power cone. Must be positive.
    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inDPowerCone__3D(*args):
      return mosek_fusion_Domain._inDPowerCone__3D(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone__3D(*args):
      return mosek_fusion_Domain._inDPowerCone_alt__3D(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_D(*args):
      return mosek_fusion_Domain._inDPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D(*args):
      return mosek_fusion_Domain._inDPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_D_3I(*args):
      return mosek_fusion_Domain._inDPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D_3I(*args):
      return mosek_fusion_Domain._inDPowerCone_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_inDPowerCone__3DI(*args):
      return mosek_fusion_Domain._inDPowerCone__3DI(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone__3DI(*args):
      return mosek_fusion_Domain._inDPowerCone_alt__3DI(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_DI(*args):
      return mosek_fusion_Domain._inDPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_DI(*args):
      return mosek_fusion_Domain._inDPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inDPowerCone__3D_3I(*args):
      return mosek_fusion_Domain._inDPowerCone__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone__3D_3I(*args):
      return mosek_fusion_Domain._inDPowerCone_alt__3D_3I(*args)
    else:
      raise ValueError('Invalid argument list inDPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDPowerCone(array(double,ndim=1))\n\tmosek.fusion.Domain.inDPowerCone(double)\n\tmosek.fusion.Domain.inDPowerCone(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inDPowerCone(array(double,ndim=1),int32)\n\tmosek.fusion.Domain.inDPowerCone(double,int32)\n\tmosek.fusion.Domain.inDPowerCone(array(double,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def lessThan(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.lessThan(array(double,ndim=1))
      mosek.fusion.Domain.lessThan(mosek.fusion.Matrix)
      mosek.fusion.Domain.lessThan(array(double,ndim=2))
      mosek.fusion.Domain.lessThan(double)
      mosek.fusion.Domain.lessThan(double,array(int32,ndim=1))
      mosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))
      mosek.fusion.Domain.lessThan(double,int32)
      mosek.fusion.Domain.lessThan(double,int32,int32)

    Description
    -----------

    Defines the domain specified by an upper bound in each dimension.

    Parameters
    ----------

    a1 : array(double,ndim=1)
        A one-dimensional array of bounds. The shape must match the variable or constraint with which it is used. 
    a2 : array(double,ndim=2)
        A two-dimensional array of bounds. The shape must match the variable or constraint with which it is used. 
    b : double
        A single value. This is scalable: it means that each element in the variable or constraint is less than or equal to :math:`b`. 
    dims : array(int32,ndim=1)
        A list of dimension sizes. 
    m : int32
        Dimension size. 
    mx : mosek.fusion.Matrix
        A matrix of bound values. The shape must match the variable or constraint with which it is used. 
    n : int32
        Dimension size. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_lessThan__3D(*args):
      return mosek_fusion_Domain._lessThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D(*args):
      return mosek_fusion_Domain._lessThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Domain._lessThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_lessThan__3_5D(*args):
      return mosek_fusion_Domain._lessThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3_5D(*args):
      return mosek_fusion_Domain._lessThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_lessThan_D(*args):
      return mosek_fusion_Domain._lessThan_D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D(*args):
      return mosek_fusion_Domain._lessThan_alt_D(*args)
    elif mosek_fusion_Domain._match_lessThan_D_3I(*args):
      return mosek_fusion_Domain._lessThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D_3I(*args):
      return mosek_fusion_Domain._lessThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan__3D_3I(*args):
      return mosek_fusion_Domain._lessThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D_3I(*args):
      return mosek_fusion_Domain._lessThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan_DI(*args):
      return mosek_fusion_Domain._lessThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DI(*args):
      return mosek_fusion_Domain._lessThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_lessThan_DII(*args):
      return mosek_fusion_Domain._lessThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DII(*args):
      return mosek_fusion_Domain._lessThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list lessThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1))\n\tmosek.fusion.Domain.lessThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.lessThan(array(double,ndim=2))\n\tmosek.fusion.Domain.lessThan(double)\n\tmosek.fusion.Domain.lessThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(double,int32)\n\tmosek.fusion.Domain.lessThan(double,int32,int32)')
  @staticmethod
  def binary(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.binary()
      mosek.fusion.Domain.binary(array(int32,ndim=1))
      mosek.fusion.Domain.binary(int32)
      mosek.fusion.Domain.binary(int32,int32)

    Description
    -----------

    Creates a domain of binary variables.

    Parameters
    ----------

    dims : array(int32,ndim=1)
        A list of dimension sizes.
    m : int32
        Dimension size.
    n : int32
        Dimension size.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_binary_(*args):
      return mosek_fusion_Domain._binary_(*args)
    elif mosek_fusion_Domain._match_alt_binary_(*args):
      return mosek_fusion_Domain._binary_alt_(*args)
    elif mosek_fusion_Domain._match_binary__3I(*args):
      return mosek_fusion_Domain._binary__3I(*args)
    elif mosek_fusion_Domain._match_alt_binary__3I(*args):
      return mosek_fusion_Domain._binary_alt__3I(*args)
    elif mosek_fusion_Domain._match_binary_I(*args):
      return mosek_fusion_Domain._binary_I(*args)
    elif mosek_fusion_Domain._match_alt_binary_I(*args):
      return mosek_fusion_Domain._binary_alt_I(*args)
    elif mosek_fusion_Domain._match_binary_II(*args):
      return mosek_fusion_Domain._binary_II(*args)
    elif mosek_fusion_Domain._match_alt_binary_II(*args):
      return mosek_fusion_Domain._binary_alt_II(*args)
    else:
      raise ValueError('Invalid argument list binary('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.binary()\n\tmosek.fusion.Domain.binary(array(int32,ndim=1))\n\tmosek.fusion.Domain.binary(int32)\n\tmosek.fusion.Domain.binary(int32,int32)')
  @staticmethod
  def sparse(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=1))
      mosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=2))
      mosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=1))
      mosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=2))

    Description
    -----------

    Use a sparse representation.

    Parameters
    ----------

    ld : mosek.fusion.LinearDomain
        The linear sparse domain.
    rd : mosek.fusion.RangeDomain
        The ranged sparse domain.
    sparsity : array(int32,ndim=2)
        Sparsity pattern.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=2))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=2))')
  @staticmethod
  def inPSDCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inPSDCone()
      mosek.fusion.Domain.inPSDCone(int32)
      mosek.fusion.Domain.inPSDCone(int32,int32)

    Description
    -----------

    Creates a domain of Positive Semidefinite matrices.

    Parameters
    ----------

    m : int32
        Number of matrices (default 1). 
    n : int32
        Dimension of the PSD matrix. 
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inPSDCone_(*args):
      return mosek_fusion_Domain._inPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_(*args):
      return mosek_fusion_Domain._inPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPSDCone_I(*args):
      return mosek_fusion_Domain._inPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_I(*args):
      return mosek_fusion_Domain._inPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPSDCone_II(*args):
      return mosek_fusion_Domain._inPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_II(*args):
      return mosek_fusion_Domain._inPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPSDCone()\n\tmosek.fusion.Domain.inPSDCone(int32)\n\tmosek.fusion.Domain.inPSDCone(int32,int32)')
  @staticmethod
  def inRotatedQCone(*args):
    '''
    Syntax
    ------

      mosek.fusion.Domain.inRotatedQCone()
      mosek.fusion.Domain.inRotatedQCone(int32)
      mosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))
      mosek.fusion.Domain.inRotatedQCone(int32,int32)

    Description
    -----------

    Defines the domain of rotated quadratic cones. 

    Parameters
    ----------

    dims : array(int32,ndim=1)
        Shape of the domain.
    m : int32
        The number of cones (default 1).
    n : int32
        The size of each cone; at least 3.
    '''
    if False: pass
    elif mosek_fusion_Domain._match_inRotatedQCone_(*args):
      return mosek_fusion_Domain._inRotatedQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_(*args):
      return mosek_fusion_Domain._inRotatedQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_I(*args):
      return mosek_fusion_Domain._inRotatedQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_I(*args):
      return mosek_fusion_Domain._inRotatedQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone__3I(*args):
      return mosek_fusion_Domain._inRotatedQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone__3I(*args):
      return mosek_fusion_Domain._inRotatedQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_II(*args):
      return mosek_fusion_Domain._inRotatedQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_II(*args):
      return mosek_fusion_Domain._inRotatedQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inRotatedQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRotatedQCone()\n\tmosek.fusion.Domain.inRotatedQCone(int32)\n\tmosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inRotatedQCone(int32,int32)')
  def __repr__(self): return 'mosek.fusion.Domain'
  @staticmethod
  def __dimsize_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain.__dimsize__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __dimsize__3I(_a_0):
   _a_1=1
   _a_1 = fragments._c_closure_283(_a_0,_a_1)
   _a_1 = numpy.int64(_a_1) # postprocess
   return numpy.int64(_a_1)
  @staticmethod
  def __mkRangedDomain_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Domain.__mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def __mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   if (((_a_0._dimi)!=(_a_1._dimi)) or ((_a_0._dimj)!=(_a_1._dimj))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions in domain")
   if (_a_0._isSparse_() and _a_1._isSparse_()):
    _a_2=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_3=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_4=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _a_5=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_6=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_7=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _a_0._getDataAsTriplets__3I_3I_3D(_a_2,_a_3,_a_4)
    _a_1._getDataAsTriplets__3I_3I_3D(_a_5,_a_6,_a_7)
    _a_8=0
    _a_8 = fragments._c_closure_284(_a_2,_a_3,_a_8,_a_5,_a_6)
    _a_8 = numpy.int64(_a_8) # postprocess
    _a_9=numpy.zeros((_a_8,2,), dtype=numpy.dtype(numpy.int32))
    _a_10=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.float64))
    _a_11=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_285(_a_9,_a_10,_a_2,_a_3,_a_4,_a_11,_a_5,_a_6,_a_7) 
    return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_a_10,_a_11,numpy.array([(_a_0._dimi),(_a_0._dimj)], dtype=numpy.dtype(numpy.int32)),_a_9,1))
   else:
    _a_12=(_a_0._dimj)
    _a_13=(_a_0._dimi)
    _a_14=(_a_13 * _a_12)
    if _a_0._isSparse_():
     _a_15 = numpy.zeros((_a_14,), dtype=numpy.dtype(numpy.float64))
     _a_17=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _a_18=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _a_19=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _a_0._getDataAsTriplets__3I_3I_3D(_a_17,_a_18,_a_19)
     fragments._c_closure_286(_a_12,_a_15,_a_17,_a_18,_a_19) 
    else:
     _a_15 = _a_0._getDataAsArray_()
    if _a_1._isSparse_():
     _a_16 = numpy.zeros((_a_14,), dtype=numpy.dtype(numpy.float64))
     _a_20=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _a_21=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _a_22=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _a_1._getDataAsTriplets__3I_3I_3D(_a_20,_a_21,_a_22)
     fragments._c_closure_287(_a_12,_a_20,_a_21,_a_16,_a_22) 
    else:
     _a_16 = _a_1._getDataAsArray_()
    return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_a_15,_a_16,numpy.array([(_a_0._dimi),(_a_0._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __mkRangedDomain_alt__3_5D_3_5D(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain.__mkRangedDomain__3_5D_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def __mkRangedDomain__3_5D_3_5D(_a_0,_a_1):
   if ((int((_a_0).shape[0])!=int((_a_1).shape[0])) or (int((_a_0).shape[1])!=int((_a_1).shape[1]))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions in domain")
   _a_2=int((_a_0).shape[1])
   _a_3=int((_a_0).shape[0])
   _a_4=(_a_3 * _a_2)
   _a_5=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   _a_7=0
   _a_7 = fragments._c_closure_288(_a_3,_a_2,_a_7,_a_0,_a_5,_a_1,_a_6)
   _a_7 = numpy.int32(_a_7) # postprocess
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_a_5,_a_6,numpy.array([_a_3,_a_2], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(__a_0,_a_1)
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   if _a_1._isSparse_():
    _a_2=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_3=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_4=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _a_1._getDataAsTriplets__3I_3I_3D(_a_2,_a_3,_a_4)
    _a_5=numpy.zeros((int((_a_2).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_289(_a_5,_a_2,_a_3) 
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_a_0,False,_a_4,numpy.array([(_a_1._dimi),(_a_1._dimj)], dtype=numpy.dtype(numpy.int32)),_a_5,1))
   else:
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_a_0,False,_a_1._getDataAsArray_(),numpy.array([(_a_1._dimi),(_a_1._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __prod_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain.__prod__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __prod__3I(_a_0):
   _a_1=1
   _a_1 = fragments._c_closure_290(_a_0,_a_1)
   _a_1 = numpy.int64(_a_1) # postprocess
   return numpy.int64(_a_1)
  @staticmethod
  def __inRange_alt_Z_3D_3D_3_5I_3I(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.array(_t__a_3,ndmin=_monty.checkShape(_t__a_3,2),dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain.__inRange_Z_3D_3D_3_5I_3I(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __inRange_Z_3D_3D_3_5I_3I(_a_0,_a_1,_a_2,_a_3,_a_4):
   if ((not _a_0) and (int((_a_1).shape[0])!=int((_a_2).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper and lower bounds.")
   if ((_a_3 is not None) and (int((_a_3).shape[0])!=int((_a_1).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper/lower bounds and sparsity.")
   for _a_5 in range(0,int((_a_2).shape[0])):
    if (_a_1[_a_5] > _a_2[_a_5]):
     raise mosek_fusion_DomainError._ctor_S("Invalid range specified")
   if ((_a_4 is not None) and (mosek.fusion.Domain.__dimsize__3I(_a_4)!=int((_a_1).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching dimensions.")
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(_a_0,_a_1,_a_2,_a_4)._sparse__3_5I(_a_3))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_0) and __arg_match__3_5I__(_a_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_0) and __arg_alt_match__3_5I__(_a_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_a_0,_a_1):
   return (_a_0._sparse__3_5I(_a_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3I(_a_0,_a_1):
   return (_a_0._sparse__3I(_a_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_0) and __arg_match__3_5I__(_a_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_0) and __arg_alt_match__3_5I__(_a_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_a_0,_a_1):
   return (_a_0._sparse__3_5I(_a_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3I(_a_0,_a_1):
   return (_a_0._sparse__3I(_a_1))
  @staticmethod
  def _match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_a_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_a_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4RangeDomain_2(_t__a_0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(_a_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4RangeDomain_2(_a_0):
   return (_a_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_a_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_a_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4LinearDomain_2(_t__a_0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(_a_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4LinearDomain_2(_a_0):
   return (_a_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4ConeDomain_2(_t__a_0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(_a_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4ConeDomain_2(_a_0):
   return (_a_0._integral_())
  @staticmethod
  def _match_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _axis_alt_Lmosek_4fusion_4ConeDomain_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _axis_Lmosek_4fusion_4ConeDomain_2I(_a_0,_a_1):
   return (_a_0._axis_I(_a_1))
  @staticmethod
  def _match_inDPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_inDPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _inDPowerCone_alt__3D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inDPowerCone__3D_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inDPowerCone__3D_3I(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,_a_0,numpy.array([_a_1[_a_2] for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inDPowerCone__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inDPowerCone_alt__3DI(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Domain._inDPowerCone__3DI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inDPowerCone__3DI(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,_a_0,numpy.array([_a_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_inDPowerCone__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _inDPowerCone_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._inDPowerCone__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inDPowerCone__3D(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,_a_0,None))
  @staticmethod
  def _match_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _inDPowerCone_alt_D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inDPowerCone_D_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inDPowerCone_D_3I(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,numpy.array([_a_0,(1.0 - _a_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1[_a_2] for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inDPowerCone_alt_DI(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inDPowerCone_DI(numpy.float64(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inDPowerCone_DI(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,numpy.array([_a_0,(1.0 - _a_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  @staticmethod
  def _inDPowerCone_alt_D(_t__a_0):
    return mosek_fusion_Domain._inDPowerCone_D(numpy.float64(__a_0))
  @staticmethod
  def _inDPowerCone_D(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,numpy.array([_a_0,(1.0 - _a_0)], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_inPPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_inPPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _inPPowerCone_alt__3D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inPPowerCone__3D_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inPPowerCone__3D_3I(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,_a_0,numpy.array([_a_1[_a_2] for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inPPowerCone__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inPPowerCone_alt__3DI(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Domain._inPPowerCone__3DI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inPPowerCone__3DI(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,_a_0,numpy.array([_a_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_inPPowerCone__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _inPPowerCone_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._inPPowerCone__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inPPowerCone__3D(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,_a_0,None))
  @staticmethod
  def _match_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _inPPowerCone_alt_D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inPPowerCone_D_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inPPowerCone_D_3I(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,numpy.array([_a_0,(1.0 - _a_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1[_a_2] for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inPPowerCone_alt_DI(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inPPowerCone_DI(numpy.float64(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inPPowerCone_DI(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,numpy.array([_a_0,(1.0 - _a_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  @staticmethod
  def _inPPowerCone_alt_D(_t__a_0):
    return mosek_fusion_Domain._inPPowerCone_D(numpy.float64(__a_0))
  @staticmethod
  def _inPPowerCone_D(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,numpy.array([_a_0,(1.0 - _a_0)], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inDExpCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inDExpCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inDExpCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inDExpCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inDExpCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inDExpCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inDExpCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_a_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inDExpCone_alt_():
    return mosek_fusion_Domain._inDExpCone_()
  @staticmethod
  def _inDExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,None))
  @staticmethod
  def _match_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inPExpCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inPExpCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inPExpCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inPExpCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inPExpCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inPExpCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inPExpCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_a_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPExpCone_alt_():
    return mosek_fusion_Domain._inPExpCone_()
  @staticmethod
  def _inPExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,None))
  @staticmethod
  def _match_inDGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inDGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inDGeoMeanCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inDGeoMeanCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inDGeoMeanCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inDGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inDGeoMeanCone_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inDGeoMeanCone_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inDGeoMeanCone_II(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inDGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inDGeoMeanCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inDGeoMeanCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inDGeoMeanCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inDGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inDGeoMeanCone_alt_():
    return mosek_fusion_Domain._inDGeoMeanCone_()
  @staticmethod
  def _inDGeoMeanCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,None))
  @staticmethod
  def _match_inPGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inPGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inPGeoMeanCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inPGeoMeanCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inPGeoMeanCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inPGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inPGeoMeanCone_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inPGeoMeanCone_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inPGeoMeanCone_II(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inPGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inPGeoMeanCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inPGeoMeanCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inPGeoMeanCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPGeoMeanCone_alt_():
    return mosek_fusion_Domain._inPGeoMeanCone_()
  @staticmethod
  def _inPGeoMeanCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,None))
  @staticmethod
  def _match_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inRotatedQCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inRotatedQCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRotatedQCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inRotatedQCone_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inRotatedQCone_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inRotatedQCone_II(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inRotatedQCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inRotatedQCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inRotatedQCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inRotatedQCone_alt_():
    return mosek_fusion_Domain._inRotatedQCone_()
  @staticmethod
  def _inRotatedQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,None))
  @staticmethod
  def _match_inQCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inQCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inQCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inQCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inQCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inQCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inQCone_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inQCone_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inQCone_II(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inQCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inQCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inQCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inQCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inQCone_alt_():
    return mosek_fusion_Domain._inQCone_()
  @staticmethod
  def _inQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,None))
  @staticmethod
  def _match_inSVecPSDCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_inSVecPSDCone__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _inSVecPSDCone_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inSVecPSDCone__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inSVecPSDCone__3I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,_a_0))
  @staticmethod
  def _match_inSVecPSDCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inSVecPSDCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inSVecPSDCone_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inSVecPSDCone_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inSVecPSDCone_II(_a_0,_a_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inSVecPSDCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inSVecPSDCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inSVecPSDCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inSVecPSDCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inSVecPSDCone_I(_a_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inSVecPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inSVecPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inSVecPSDCone_alt_():
    return mosek_fusion_Domain._inSVecPSDCone_()
  @staticmethod
  def _inSVecPSDCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,None))
  @staticmethod
  def _match_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _isTrilPSD_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._isTrilPSD_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _isTrilPSD_II(_a_0,_a_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_a_1,_a_0,_a_0], dtype=numpy.dtype(numpy.int32)),1,2))
  @staticmethod
  def _match_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _isTrilPSD_alt_I(_t__a_0):
    return mosek_fusion_Domain._isTrilPSD_I(numpy.int32(__a_0))
  @staticmethod
  def _isTrilPSD_I(_a_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_a_0,_a_0], dtype=numpy.dtype(numpy.int32)),0,1))
  @staticmethod
  def _match_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isTrilPSD_alt_():
    return mosek_fusion_Domain._isTrilPSD_()
  @staticmethod
  def _isTrilPSD_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsTrilPSD))
  @staticmethod
  def _match_inPSDCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_inPSDCone_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _inPSDCone_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inPSDCone_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _inPSDCone_II(_a_0,_a_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_a_1,_a_0,_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_inPSDCone_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _inPSDCone_alt_I(_t__a_0):
    return mosek_fusion_Domain._inPSDCone_I(numpy.int32(__a_0))
  @staticmethod
  def _inPSDCone_I(_a_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_a_0,_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPSDCone_alt_():
    return mosek_fusion_Domain._inPSDCone_()
  @staticmethod
  def _inPSDCone_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsSymPSD))
  @staticmethod
  def _match_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _binary_alt_():
    return mosek_fusion_Domain._binary_()
  @staticmethod
  def _binary_():
   return (mosek.fusion.Domain._inRange_DD(0.0,1.0)._integral_())
  @staticmethod
  def _match_binary__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_binary__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _binary_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._binary__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _binary__3I(_a_0):
   return (mosek.fusion.Domain._inRange_DD_3I(0.0,1.0,_a_0)._integral_())
  @staticmethod
  def _match_binary_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_binary_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _binary_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._binary_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _binary_II(_a_0,_a_1):
   return (mosek.fusion.Domain._inRange_DD_3I(0.0,1.0,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_binary_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_binary_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _binary_alt_I(_t__a_0):
    return mosek_fusion_Domain._binary_I(numpy.int32(__a_0))
  @staticmethod
  def _binary_I(_a_0):
   return (mosek.fusion.Domain._inRange_DD_3I(0.0,1.0,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Domain.__mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1))
  @staticmethod
  def _match_inRange__3_5D_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_inRange__3_5D_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _inRange_alt__3_5D_3_5D(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._inRange__3_5D_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _inRange__3_5D_3_5D(_a_0,_a_1):
   return (mosek.fusion.Domain.__mkRangedDomain__3_5D_3_5D(_a_0,_a_1))
  @staticmethod
  def _match_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3D__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _inRange_alt__3D_3D_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inRange__3D_3D_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange__3D_3D_3I(_a_0,_a_1,_a_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_a_0,_a_1,_a_2))
  @staticmethod
  def _match_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3D__(_a_0) and __arg_match_D__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _inRange_alt__3DD_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.float64(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inRange__3DD_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange__3DD_3I(_a_0,_a_1,_a_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_a_0,numpy.array([_a_1 for _a_3 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),_a_2))
  @staticmethod
  def _match_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match__3D__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _inRange_alt_D_3D_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inRange_D_3D_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange_D_3D_3I(_a_0,_a_1,_a_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_a_0 for _a_3 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_a_1,_a_2))
  @staticmethod
  def _match_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_D__(_a_1) and __arg_match__3I__(_a_2))
  @staticmethod
  def _match_alt_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match__3I__(_a_2))
  @staticmethod
  def _inRange_alt_DD_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.float64(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._inRange_DD_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange_DD_3I(_a_0,_a_1,_a_2):
   return (mosek_fusion_RangeDomain._ctor_ZDD_3I(False,_a_0,_a_1,_a_2))
  @staticmethod
  def _match_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _inRange_alt__3D_3D(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._inRange__3D_3D(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange__3D_3D(_a_0,_a_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_a_0,_a_1,numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3DD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_inRange__3DD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _inRange_alt__3DD(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.float64(_t__a_1)
   _1_res = mosek_fusion_Domain._inRange__3DD(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange__3DD(_a_0,_a_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_a_0,numpy.array([_a_1 for _a_2 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_D_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_inRange_D_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _inRange_alt_D_3D(_t__a_0,_t__a_1):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._inRange_D_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _inRange_D_3D(_a_0,_a_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_a_0 for _a_2 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_a_1,numpy.array([int((_a_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_inRange_DD(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _inRange_alt_DD(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._inRange_DD(numpy.float64(__a_0),numpy.float64(__a_1))
  @staticmethod
  def _inRange_DD(_a_0,_a_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _greaterThan_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _greaterThan_Lmosek_4fusion_4Matrix_2(_a_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.GreaterThan,_a_0))
  @staticmethod
  def _match_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _greaterThan_alt__3D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._greaterThan__3D_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _greaterThan__3D_3I(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_a_0),_a_1))
  @staticmethod
  def _match_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  @staticmethod
  def _greaterThan_alt__3_5D(_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._greaterThan__3_5D(_a_0)
   return _1_res
  @staticmethod
  def _greaterThan__3_5D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_a_0[_a_1,_a_2] for _a_1 in range(0,int((_a_0).shape[0])) for _a_2 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_a_0).shape[0]),int((_a_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_greaterThan__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _greaterThan_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._greaterThan__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _greaterThan__3D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_a_0),numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _greaterThan_alt_D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._greaterThan_D_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _greaterThan_D_3I(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_a_0 for _a_2 in range(0,mosek.fusion.Domain.__prod__3I(_a_1))], dtype=numpy.dtype(numpy.float64)),_a_1))
  @staticmethod
  def _match_greaterThan_DII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_greaterThan_DII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _greaterThan_alt_DII(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Domain._greaterThan_DII(numpy.float64(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _greaterThan_DII(_a_0,_a_1,_a_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_a_0 for _a_3 in range(0,(_a_2 * _a_1))], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_greaterThan_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _greaterThan_alt_DI(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._greaterThan_DI(numpy.float64(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _greaterThan_DI(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_a_0 for _a_2 in range(0,_a_1)], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_greaterThan_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  @staticmethod
  def _greaterThan_alt_D(_t__a_0):
    return mosek_fusion_Domain._greaterThan_D(numpy.float64(__a_0))
  @staticmethod
  def _greaterThan_D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _lessThan_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _lessThan_Lmosek_4fusion_4Matrix_2(_a_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.LessThan,_a_0))
  @staticmethod
  def _match_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _lessThan_alt__3D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._lessThan__3D_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _lessThan__3D_3I(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_a_0),_a_1))
  @staticmethod
  def _match_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  @staticmethod
  def _lessThan_alt__3_5D(_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._lessThan__3_5D(_a_0)
   return _1_res
  @staticmethod
  def _lessThan__3_5D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_a_0[_a_1,_a_2] for _a_1 in range(0,int((_a_0).shape[0])) for _a_2 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_a_0).shape[0]),int((_a_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_lessThan__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _lessThan_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._lessThan__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _lessThan__3D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_a_0),numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _lessThan_alt_D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._lessThan_D_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _lessThan_D_3I(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),_a_1))
  @staticmethod
  def _match_lessThan_DII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_lessThan_DII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _lessThan_alt_DII(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Domain._lessThan_DII(numpy.float64(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _lessThan_DII(_a_0,_a_1,_a_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_lessThan_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _lessThan_alt_DI(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._lessThan_DI(numpy.float64(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _lessThan_DI(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_lessThan_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  @staticmethod
  def _lessThan_alt_D(_t__a_0):
    return mosek_fusion_Domain._lessThan_D(numpy.float64(__a_0))
  @staticmethod
  def _lessThan_D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _equalsTo_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _equalsTo_Lmosek_4fusion_4Matrix_2(_a_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.EqualsTo,_a_0))
  @staticmethod
  def _match_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _equalsTo_alt__3D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._equalsTo__3D_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _equalsTo__3D_3I(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_a_0),_a_1))
  @staticmethod
  def _match_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  @staticmethod
  def _equalsTo_alt__3_5D(_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._equalsTo__3_5D(_a_0)
   return _1_res
  @staticmethod
  def _equalsTo__3_5D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_a_0[_a_1,_a_2] for _a_1 in range(0,int((_a_0).shape[0])) for _a_2 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_a_0).shape[0]),int((_a_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_equalsTo__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _equalsTo_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Domain._equalsTo__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _equalsTo__3D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_a_0),numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _equalsTo_alt_D_3I(_t__a_0,_t__a_1):
   _a_0=numpy.float64(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._equalsTo_D_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _equalsTo_D_3I(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),_a_1))
  @staticmethod
  def _match_equalsTo_DII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_equalsTo_DII(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _equalsTo_alt_DII(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Domain._equalsTo_DII(numpy.float64(__a_0),numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _equalsTo_DII(_a_0,_a_1,_a_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1,_a_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_equalsTo_DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _equalsTo_alt_DI(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._equalsTo_DI(numpy.float64(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _equalsTo_DI(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_equalsTo_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  @staticmethod
  def _equalsTo_alt_D(_t__a_0):
    return mosek_fusion_Domain._equalsTo_D(numpy.float64(__a_0))
  @staticmethod
  def _equalsTo_D(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_a_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_unbounded__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_unbounded__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _unbounded_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Domain._unbounded__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _unbounded__3I(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_a_0[_a_1] for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_unbounded_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _unbounded_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Domain._unbounded_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _unbounded_II(_a_0,_a_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_a_0,_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_unbounded_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _unbounded_alt_I(_t__a_0):
    return mosek_fusion_Domain._unbounded_I(numpy.int32(__a_0))
  @staticmethod
  def _unbounded_I(_a_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _unbounded_alt_():
    return mosek_fusion_Domain._unbounded_()
  @staticmethod
  def _unbounded_():
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,True,None,None))
 return Domain
mosek_fusion_Domain=__mk_mosek_fusion_Domain()
del __mk_mosek_fusion_Domain
#BEFORE CLASS
def __mk_mosek_fusion_Param():
 class Param(object):
  @staticmethod
  def stack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Param.stack(array(array(mosek.fusion.Parameter,ndim=1),ndim=1))
      mosek.fusion.Param.stack(int32,array(mosek.fusion.Parameter,ndim=1))
      mosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter)
      mosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)

    Description
    -----------

    Stack a list of parameters in an arbitrary dimension. 

    Parameters
    ----------

    dim : int32
        The dimension in which to stack.
    p : array(mosek.fusion.Parameter,ndim=1)
        Parameters to stack. 
    p1 : mosek.fusion.Parameter
        First parameter to stack. 
    p2 : mosek.fusion.Parameter
        Second parameter to stack.
    p3 : mosek.fusion.Parameter
        Third parameter to stack.
    '''
    if False: pass
    elif mosek_fusion_Param._match_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack__3_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_alt__3_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_I_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_alt_I_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.stack(array(array(mosek.fusion.Parameter,ndim=1),ndim=1))\n\tmosek.fusion.Param.stack(int32,array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  @staticmethod
  def repeat(*args):
    '''
    Syntax
    ------

      mosek.fusion.Param.repeat(mosek.fusion.Parameter,int32,int32)

    Description
    -----------

    Repeat a parameter a number of times in the given dimension.

    Parameters
    ----------

    dim : int32
        The dimension in which to repeat. Must define a valid dimension index. 
    n : int32
        Number of times to repeat. Must be strictly positive. 
    p : mosek.fusion.Parameter
        The parameter to repeat. 
    '''
    if False: pass
    elif mosek_fusion_Param._match_repeat_Lmosek_4fusion_4Parameter_2II(*args):
      return mosek_fusion_Param._repeat_Lmosek_4fusion_4Parameter_2II(*args)
    elif mosek_fusion_Param._match_alt_repeat_Lmosek_4fusion_4Parameter_2II(*args):
      return mosek_fusion_Param._repeat_alt_Lmosek_4fusion_4Parameter_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.repeat(mosek.fusion.Parameter,int32,int32)')
  @staticmethod
  def hstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Param.hstack(array(mosek.fusion.Parameter,ndim=1))
      mosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter)
      mosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)

    Description
    -----------

    Stack a list of parameters horizontally (i.e. along the second dimension). 

    Parameters
    ----------

    p : array(mosek.fusion.Parameter,ndim=1)
        Parameters to stack. 
    p1 : mosek.fusion.Parameter
        First parameter to stack. 
    p2 : mosek.fusion.Parameter
        Second parameter to stack.
    p3 : mosek.fusion.Parameter
        Third parameter to stack.
    '''
    if False: pass
    elif mosek_fusion_Param._match_hstack__3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._hstack__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack__3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._hstack_alt__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.hstack(array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  @staticmethod
  def vstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Param.vstack(array(mosek.fusion.Parameter,ndim=1))
      mosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter)
      mosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)

    Description
    -----------

    Stack a list of parameters vertically (i.e. along the first dimension). 

    Parameters
    ----------

    p : array(mosek.fusion.Parameter,ndim=1)
        Parameters to stack. 
    p1 : mosek.fusion.Parameter
        First parameter to stack. 
    p2 : mosek.fusion.Parameter
        Second parameter to stack.
    p3 : mosek.fusion.Parameter
        Third parameter to stack.
    '''
    if False: pass
    elif mosek_fusion_Param._match_vstack__3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._vstack__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack__3Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._vstack_alt__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Param._vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.vstack(array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  def __repr__(self): return 'mosek.fusion.Param'
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Parameter_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Parameter_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Parameter_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Param._repeat_Lmosek_4fusion_4Parameter_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Parameter_2II(_a_0,_a_1,_a_2):
   return (mosek.fusion.Param._stack_I_3Lmosek_4fusion_4Parameter_2(_a_2,numpy.array([_a_0 for _a_3 in range(0,_a_1)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_2) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(numpy.int32(__a_0),_a_1,_a_2,_a_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_a_1,_a_2,_a_3], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(numpy.int32(__a_0),_a_1,_a_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_a_1,_a_2], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Param._stack_I_3Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_a_1,_a_0))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Parameter_2__(_a_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Parameter_2__(_a_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Parameter_2(_t__a_0):
   _a_0=_monty.makeJaggedArray(_t__a_0,(1,1),numpy.dtype(object))
   _1_res = mosek_fusion_Param._stack__3_3Lmosek_4fusion_4Parameter_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Parameter_2(_a_0):
   return (mosek.fusion.Param._vstack__3Lmosek_4fusion_4Parameter_2(numpy.array([mosek.fusion.Param._hstack__3Lmosek_4fusion_4Parameter_2(_a_0[_a_1]) for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Parameter_2__(_a_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_a_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Parameter_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Param._hstack__3Lmosek_4fusion_4Parameter_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Parameter_2(_a_0):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_a_0,1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Parameter_2__(_a_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_a_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Parameter_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Param._vstack__3Lmosek_4fusion_4Parameter_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Parameter_2(_a_0):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_a_0,0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Parameter_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Param._dstack__3Lmosek_4fusion_4Parameter_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Parameter_2I(_a_0,_a_1):
   if (_a_1 < 0):
    raise mosek_fusion_IndexError._ctor_S("Invalid stacking dimension")
   _a_2=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _a_5=_a_0[0]._getND_()
   for _a_6 in range(1,int((_a_0).shape[0])):
    if (_a_5 < _a_0[_a_6]._getND_()):
     _a_5 = _a_0[_a_6]._getND_()
   if (_a_1 < _a_5):
    _a_7=0
    while ((_a_7 < int((_a_0).shape[0])) and (_a_5!=_a_0[_a_7]._getND_())):
     _a_7 += 1
    _a_4 = _a_0[_a_7]._getShape_()
    _a_8=0
    while ((_a_8 < int((_a_0).shape[0])) and (_a_5!=_a_0[_a_8]._getND_())):
     _a_8 += 1
    _a_4 = _a_0[_a_8]._getShape_()
   else:
    _a_4 = numpy.array([1 for _a_9 in range(0,(_a_1 + 1))], dtype=numpy.dtype(numpy.int32))
    _a_10=0
    while ((_a_10 < int((_a_0).shape[0])) and (_a_5!=_a_0[_a_10]._getND_())):
     _a_10 += 1
    _a_11=_a_0[_a_10]._getND_()
    _a_12=_a_0[_a_10]._getShape_()
    fragments._c_closure_291(_a_11,_a_4,_a_12) 
   _a_5 = int((_a_4).shape[0])
   _a_13=0
   _a_14=False
   for _a_15 in range(0,int((_a_0).shape[0])):
    _a_16=_a_0[_a_15]._getShape_()
    _a_3[_a_15] = mosek.fusion.Set._size__3I(_a_16)
    _a_14 = fragments._c_closure_292(_a_1,_a_14,_a_4,_a_16)
    _a_14,_a_13 = fragments._c_closure_293(_a_1,_a_14,_a_13,_a_2,_a_15,_a_5,_a_4,_a_16)
    _a_13 = numpy.int32(_a_13) # postprocess
   if _a_14:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for stacking")
   _a_4[_a_1] = _a_13
   _a_17=numpy.array([_a_0[_a_18]._getNumNonzero_() for _a_18 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _a_19=0
   _a_19 = fragments._c_closure_294(_a_17,_a_19)
   _a_19 = numpy.int32(_a_19) # postprocess
   _a_20=numpy.zeros((_a_19,), dtype=numpy.dtype(numpy.int64))
   _a_21=numpy.zeros((_a_19,), dtype=numpy.dtype(numpy.int32))
   _a_22=1
   _a_22 = fragments._c_closure_295(_a_1,_a_22,_a_4)
   _a_22 = numpy.int64(_a_22) # postprocess
   _a_23=_a_13
   _a_24=1
   _a_24 = fragments._c_closure_296(_a_1,_a_24,_a_5,_a_4)
   _a_24 = numpy.int64(_a_24) # postprocess
   _a_25=0
   _a_26=0
   for _a_27 in range(0,int((_a_0).shape[0])):
    _a_28=_a_0[_a_27]._getNumNonzero_()
    _a_0[_a_27]._getSp__3JI(_a_20,_a_25)
    _a_0[_a_27]._getAllIndexes__3II(_a_21,_a_25)
    _a_26 = fragments._c_closure_297(_a_1,_a_24,_a_13,_a_2,_a_27,_a_3,_a_28,_a_25,_a_26,_a_20)
    _a_26 = numpy.int64(_a_26) # postprocess
    _a_25 += _a_28
   _a_29=_a_4[0]
   _a_29 = fragments._c_closure_298(_a_29,_a_5,_a_4)
   _a_29 = numpy.int32(_a_29) # postprocess
   _a_30=numpy.zeros(((_a_29 + 1),), dtype=numpy.dtype(numpy.int32))
   _a_31=numpy.zeros((_a_19,), dtype=numpy.dtype(numpy.int32))
   _a_32=numpy.zeros((_a_19,), dtype=numpy.dtype(numpy.int32))
   _a_33=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int64))
   _a_33[(_a_5 - 1)] = 1
   fragments._c_closure_299(_a_5,_a_4,_a_33) 
   fragments._c_closure_300(_a_31,_a_19) 
   for _a_34 in range(0,_a_5):
    _a_35=((_a_5 - _a_34) - 1)
    fragments._c_closure_301(_a_29,_a_30) 
    fragments._c_closure_302(_a_35,_a_30,_a_19,_a_4,_a_33,_a_20) 
    fragments._c_closure_303(_a_29,_a_30) 
    fragments._c_closure_304(_a_35,_a_31,_a_32,_a_30,_a_19,_a_4,_a_33,_a_20) 
    _a_36=_a_32
    _a_32 = _a_31
    _a_31 = _a_36
   _a_37=numpy.array([_a_20[_a_31[_a_38]] for _a_38 in range(0,_a_19)], dtype=numpy.dtype(numpy.int64))
   _a_39=numpy.array([_a_21[_a_31[_a_40]] for _a_40 in range(0,_a_19)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(_a_0[0]._getModel_(),_a_4,_a_37,_a_39))
 return Param
mosek_fusion_Param=__mk_mosek_fusion_Param()
del __mk_mosek_fusion_Param
#BEFORE CLASS
def __mk_mosek_fusion_ParameterImpl():
 class ParameterImpl(mosek_fusion_Parameter,object):
  __slots__ = ['_ParameterImpl__size','_ParameterImpl__nidxs','_ParameterImpl__sp','_ParameterImpl__shape','_ParameterImpl__model']
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.toString()

    Description
    -----------

    String representation of the object

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.toString()')
  def getModel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getModel()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getModel_(*args):
      return self._getModel_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getModel_(*args):
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getModel()')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getShape()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getShape()')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.transpose()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.transpose()')
  def getValue(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getValue()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getValue_(*args):
      return self._getValue_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getValue_(*args):
      return self._getValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list getValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getValue()')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ParameterImpl._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def clone(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.clone(mosek.fusion.Model)

    Description
    -----------

    

    Parameters
    ----------

    m : mosek.fusion.Model
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_clone_Lmosek_4fusion_4Model_2(*args):
      return self._clone_Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_ParameterImpl._match_alt_clone_Lmosek_4fusion_4Model_2(*args):
      return self._clone_alt_Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.clone(mosek.fusion.Model)')
  def asExpr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.asExpr()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_asExpr_(*args):
      return self._asExpr_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_asExpr_(*args):
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.asExpr()')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.slice(int32,int32)
      mosek.fusion.ParameterImpl.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    astart : array(int32,ndim=1)
    astop : array(int32,ndim=1)
    start : int32
    stop : int32
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_ParameterImpl._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_ParameterImpl._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.slice(int32,int32)\n\tmosek.fusion.ParameterImpl.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getSize()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getSize()')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.index(int32)
      mosek.fusion.ParameterImpl.index(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    indexes : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_ParameterImpl._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.index(int32)\n\tmosek.fusion.ParameterImpl.index(array(int32,ndim=1))')
  def isSparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.isSparse()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_isSparse_(*args):
      return self._isSparse_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_isSparse_(*args):
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.isSparse()')
  def getNumNonzero(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getNumNonzero()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getNumNonzero_(*args):
      return self._getNumNonzero_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getNumNonzero_(*args):
      return self._getNumNonzero_alt_(*args)
    else:
      raise ValueError('Invalid argument list getNumNonzero('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getNumNonzero()')
  def getIndex(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getIndex(int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getIndex_I(*args):
      return self._getIndex_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getIndex_I(*args):
      return self._getIndex_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getIndex(int32)')
  def reshape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.reshape(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    dims : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_reshape__3I(*args):
      return self._reshape__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_reshape__3I(*args):
      return self._reshape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.reshape(array(int32,ndim=1))')
  def setValue(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.setValue(double)
      mosek.fusion.ParameterImpl.setValue(array(double,ndim=1))
      mosek.fusion.ParameterImpl.setValue(array(double,ndim=2))

    Description
    -----------

    

    Parameters
    ----------

    value : double
    values : array(double,ndim=1)
    values2 : array(double,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_setValue_D(*args):
      return self._setValue_D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue_D(*args):
      return self._setValue_alt_D(*args)
    elif mosek_fusion_ParameterImpl._match_setValue__3D(*args):
      return self._setValue__3D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue__3D(*args):
      return self._setValue_alt__3D(*args)
    elif mosek_fusion_ParameterImpl._match_setValue__3_5D(*args):
      return self._setValue__3_5D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue__3_5D(*args):
      return self._setValue_alt__3_5D(*args)
    else:
      raise ValueError('Invalid argument list setValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.setValue(double)\n\tmosek.fusion.ParameterImpl.setValue(array(double,ndim=1))\n\tmosek.fusion.ParameterImpl.setValue(array(double,ndim=2))')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getND()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getND()')
  def getDim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getDim(int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getDim_I(*args):
      return self._getDim_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getDim_I(*args):
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getDim(int32)')
  def getAllIndexes(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getAllIndexes(array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    dst : array(int32,ndim=1)
    ofs : int32
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getAllIndexes__3II(*args):
      return self._getAllIndexes__3II(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getAllIndexes__3II(*args):
      return self._getAllIndexes_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list getAllIndexes('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getAllIndexes(array(int32,ndim=1),int32)')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.pick(array(int32,ndim=1))
      mosek.fusion.ParameterImpl.pick(array(int32,ndim=2))

    Description
    -----------

    

    Parameters
    ----------

    idxs : array(int32,ndim=1)
    midxs : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_ParameterImpl._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.pick(array(int32,ndim=1))\n\tmosek.fusion.ParameterImpl.pick(array(int32,ndim=2))')
  def getSp(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ParameterImpl.getSp(array(int64,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    dest : array(int64,ndim=1)
    offset : int32
    '''
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getSp__3JI(*args):
      return self._getSp__3JI(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getSp__3JI(*args):
      return self._getSp_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list getSp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getSp(array(int64,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.ParameterImpl'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model):
    o = ParameterImpl.__new__(ParameterImpl)
    o._ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    other,model, = args
    return (__arg_match_Lmosek_4fusion_4ParameterImpl_2__(other) and __arg_match_Lmosek_4fusion_4Model_2__(model))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    other,model, = args
    return (__arg_alt_match_Lmosek_4fusion_4ParameterImpl_2__(other) and __arg_alt_match_Lmosek_4fusion_4Model_2__(model))
  def _ctor_alt_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,other,model):
    self._ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model)
  def _ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,other,model):
   (self.__model) = model
   (self.__shape) = (other.__shape)
   (self.__sp) = (other.__sp)
   (self.__size) = (other.__size)
   (self.__nidxs) = (other.__nidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(model,shape,sp,nidxs):
    o = ParameterImpl.__new__(ParameterImpl)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(model,shape,sp,nidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(*args):
    if len(args) != 4: return False
    model,shape,sp,nidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3J__(sp) and __arg_match__3I__(nidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(*args):
    if len(args) != 4: return False
    model,shape,sp,nidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sp) and __arg_alt_match__3I__(nidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3I(self,model,shape,sp,nidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int64)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(self,model,shape,sp,nidxs):
   (self.__model) = model
   (self.__shape) = mosek.fusion.Utils.Tools._arraycopy__3I(shape)
   (self.__sp) = sp
   (self.__size) = mosek.fusion.Set._size__3I(shape)
   (self.__nidxs) = mosek.fusion.Utils.Tools._arraycopy__3I(nidxs)
  @staticmethod
  def _match_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_a_0))
  @staticmethod
  def _match_alt_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_a_0))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__a_0):
    return self._clone_Lmosek_4fusion_4Model_2(_a_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_a_0):
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,_a_0))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()._a_S("Parameter((")
   if (int((self.__shape).shape[0]) > 0):
    _a_0._a_I(self.__shape[0])
    for _a_1 in range(1,int((self.__shape).shape[0])):
     _a_0._a_S(",")._a_I(self.__shape[_a_1])
   _a_0._a_S(")")
   if (self.__sp is not None):
    _a_0._a_S(",sparse")
   _a_0._a_S(")")
   return (_a_0._toString_())
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   if (int((self.__shape).shape[0])!=int((_a_0).shape[1])):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_1=False
   _a_1 = fragments._c_closure_305(_a_1,_a_0,self.__shape)
   if _a_1:
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_2=int((self.__shape).shape[0])
   _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   _a_3[(_a_2 - 1)] = 1
   fragments._c_closure_306(_a_2,self.__shape,_a_3) 
   _a_4=numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32))
   _a_6=None
   if (self.__sp is None):
    _a_5 = numpy.zeros((int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_307(_a_5,_a_0,_a_2,self.__nidxs,_a_3) 
   else:
    _a_7=0
    for _a_8 in range(0,int((_a_0).shape[0])):
     _a_9=0
     _a_9 = fragments._c_closure_308(_a_8,_a_9,_a_0,_a_2,_a_3)
     _a_9 = numpy.int64(_a_9) # postprocess
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sp,_a_9) >= 0):
      _a_7 += 1
    _a_5 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int32))
    _a_6 = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    _a_10=0
    for _a_11 in range(0,int((_a_0).shape[0])):
     _a_12=0
     _a_12 = fragments._c_closure_309(_a_11,_a_12,_a_0,_a_2,_a_3)
     _a_12 = numpy.int64(_a_12) # postprocess
     _a_13=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sp,_a_12)
     if (_a_13 >= 0):
      _a_5[_a_10] = self.__nidxs[_a_13]
      _a_6[_a_10] = _a_11
      _a_10 += 1
    if (_a_7==int((_a_0).shape[0])):
     _a_6 = None
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_a_4,_a_6,_a_5))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   if (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_1=False
   _a_1 = fragments._c_closure_310(_a_0,_a_1,self.__shape)
   if _a_1:
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_3=None
   if (self.__sp is None):
    _a_2 = numpy.array([self.__nidxs[_a_0[_a_4]] for _a_4 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   else:
    _a_5=0
    for _a_6 in range(0,int((_a_0).shape[0])):
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sp,_a_0[_a_6]) >= 0):
      _a_5 += 1
    _a_2 = numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
    _a_3 = numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int64))
    _a_7=0
    for _a_8 in range(0,int((_a_0).shape[0])):
     _a_9=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sp,_a_0[_a_8])
     if (_a_9 >= 0):
      _a_3[_a_7] = _a_8
      _a_2[_a_7] = self.__nidxs[_a_9]
      _a_7 += 1
    if (_a_5==int((_a_0).shape[0])):
     _a_3 = None
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32)),_a_3,_a_2))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   if (int((self.__shape).shape[0])!=int((_a_0).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Index has incorrect dimension")
   else:
    for _a_1 in range(0,int((_a_0).shape[0])):
     if ((_a_0[_a_1] < 0) or (_a_0[_a_1] >= self.__shape[_a_1])):
      raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__sp is None):
    _a_2=int((_a_0).shape[0])
    _a_3=_a_0[(_a_2 - 1)]
    _a_3 = fragments._c_closure_311(_a_0,_a_3,_a_2,self.__shape)
    _a_3 = numpy.int64(_a_3) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_a_3]], dtype=numpy.dtype(numpy.int32))))
   else:
    _a_4=int((_a_0).shape[0])
    _a_5=_a_0[(_a_4 - 1)]
    _a_5 = fragments._c_closure_312(_a_0,_a_5,_a_4,self.__shape)
    _a_5 = numpy.int64(_a_5) # postprocess
    _a_6=0
    _a_6 = fragments._c_closure_313(_a_5,_a_6,self.__sp)
    _a_6 = numpy.int32(_a_6) # postprocess
    if ((_a_6 < int((self.__sp).shape[0])) and (self.__sp[_a_6]==_a_5)):
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_a_6]], dtype=numpy.dtype(numpy.int32))))
    else:
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   if (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_DimensionError._ctor_S("Index has incorrect dimension")
   elif ((_a_0 < 0) or (_a_0 >= self.__shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__sp is None):
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_a_0]], dtype=numpy.dtype(numpy.int32))))
   else:
    _a_1=0
    _a_1 = fragments._c_closure_314(_a_0,_a_1,self.__sp)
    _a_1 = numpy.int32(_a_1) # postprocess
    if ((_a_1 < int((self.__sp).shape[0])) and (self.__sp[_a_1]==_a_0)):
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_a_1]], dtype=numpy.dtype(numpy.int32))))
    else:
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=int((self.__shape).shape[0])
   _a_4=int((self.__nidxs).shape[0])
   _a_5=(self.__sp is not None)
   _a_0._alloc_1expr_IIIZI(_a_3,_a_4,int((self.__nidxs).shape[0]),_a_5,int((self.__nidxs).shape[0]))
   _a_6=(_a_0.i32)
   _a_7=(_a_0.i64)
   _a_8=(_a_0.f64)
   _a_9=(_a_0.ptr_base)
   _a_10=(_a_0.nidxs_base)
   _a_11=(_a_0.cof_base)
   _a_12=(_a_0.shape_base)
   _a_13=(_a_0.codeptr_base)
   _a_14=(_a_0.code_base)
   _a_15=(_a_0.cconst_base)
   _a_16=(_a_0.sp_base)
   fragments._c_closure_315(_a_5,_a_3,_a_4,self.__nidxs,_a_15,_a_14,_a_13,_a_11,_a_8,_a_6,_a_7,_a_10,_a_9,_a_12,_a_16,self.__shape,self.__sp) 
  @staticmethod
  def _match_getSp__3JI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3J__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_getSp__3JI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3J__(_a_0) and __arg_alt_match_I__(_a_1))
  def _getSp_alt__3JI(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._getSp__3JI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getSp__3JI(self,_a_0,_a_1):
   fragments._c_closure_316(_a_0,self.__nidxs,_a_1,self.__sp) 
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return ((self.__sp is not None))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   if ((int((_a_0).shape[0])!=int((_a_1).shape[0])) or (int((_a_0).shape[0])!=int((self.__shape).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   _a_2=int((_a_0).shape[0])
   for _a_3 in range(0,_a_2):
    if ((_a_0[_a_3] < 0) or ((_a_0[_a_3] >= _a_1[_a_3]) or (_a_1[_a_3] > self.__shape[_a_3]))):
     raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _a_4=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   _a_4[(_a_2 - 1)] = 1
   fragments._c_closure_317(_a_2,self.__shape,_a_4) 
   _a_5=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.array([(_a_1[_a_7] - _a_0[_a_7]) for _a_7 in range(0,_a_2)], dtype=numpy.dtype(numpy.int32))
   if (self.__sp is None):
    _a_8=1
    _a_8 = fragments._c_closure_318(_a_8,_a_2,_a_6)
    _a_8 = numpy.int32(_a_8) # postprocess
    _a_9=numpy.zeros((_a_8,), dtype=numpy.dtype(numpy.int32))
    _a_10=0
    _a_10 = fragments._c_closure_319(_a_0,_a_1,_a_5,_a_10,_a_2,self.__nidxs,_a_9,self.__shape,_a_4)
    _a_10 = numpy.int32(_a_10) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_a_6,None,_a_9))
   else:
    _a_11=0
    _a_11 = fragments._c_closure_320(_a_0,_a_1,_a_11,_a_5,_a_2,self.__nidxs,self.__shape,self.__sp,_a_4)
    _a_11 = numpy.int32(_a_11) # postprocess
    _a_12=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int32))
    _a_13=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
    _a_14=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
    _a_14[(_a_2 - 1)] = 1
    fragments._c_closure_321(_a_2,_a_6,_a_14) 
    _a_15=0
    _a_15 = fragments._c_closure_322(_a_0,_a_1,_a_5,_a_15,_a_2,self.__nidxs,_a_12,_a_13,_a_14,self.__shape,self.__sp,_a_4)
    _a_15 = numpy.int32(_a_15) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_a_6,_a_13,_a_12))
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if (int((self.__shape).shape[0])==0):
    return (self)
   else:
    if (int((self.__shape).shape[0])==1):
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([1,self.__shape[0]], dtype=numpy.dtype(numpy.int32)),self.__sp,self.__nidxs))
    else:
     if (int((self.__shape).shape[0])==2):
      _a_0=self.__shape[0]
      _a_1=self.__shape[1]
      _a_2=numpy.array([_a_1,_a_0], dtype=numpy.dtype(numpy.int32))
      if (self.__sp is not None):
       _a_3=numpy.zeros((int((self.__nidxs).shape[0]),), dtype=numpy.dtype(numpy.int32))
       _a_4=numpy.zeros((int((self.__sp).shape[0]),), dtype=numpy.dtype(numpy.int64))
       _a_5=numpy.zeros(((_a_1 + 1),), dtype=numpy.dtype(numpy.int32))
       fragments._c_closure_323(_a_1,_a_5,self.__sp) 
       fragments._c_closure_324(_a_1,_a_5) 
       fragments._c_closure_325(_a_0,_a_1,self.__nidxs,_a_5,self.__sp,_a_3,_a_4) 
       return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_a_2,_a_4,_a_3))
      else:
       _a_6=numpy.array([self.__nidxs[((_a_8 * _a_1) + _a_7)] for _a_7 in range(0,_a_1) for _a_8 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32))
       return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_a_2,None,_a_6))
     else:
      raise mosek_fusion_DimensionError._ctor_S("Invalid shape for transpose")
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   if (int((self.__shape).shape[0])!=1):
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   if ((_a_0 < 0) or ((_a_0 >= _a_1) or (_a_1 > self.__size))):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if (self.__sp is None):
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([(_a_1 - _a_0)], dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_a_2] for _a_2 in range(_a_0,_a_1)], dtype=numpy.dtype(numpy.int32))))
   else:
    _a_3=0
    _a_3 = fragments._c_closure_326(_a_3,self.__sp,_a_0,_a_1)
    _a_3 = numpy.int32(_a_3) # postprocess
    _a_4=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
    _a_6=0
    _a_6 = fragments._c_closure_327(_a_6,self.__nidxs,_a_4,_a_5,self.__sp,_a_0,_a_1)
    _a_6 = numpy.int32(_a_6) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([(_a_1 - _a_0)], dtype=numpy.dtype(numpy.int32)),_a_5,_a_4))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _reshape_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._reshape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _reshape__3I(self,_a_0):
   if (mosek.fusion.Set._size__3I(_a_0)!=mosek.fusion.Set._size__3I(self.__shape)):
    raise mosek_fusion_DimensionError._ctor_S("Incompatible shape for resize")
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_a_0,self.__sp,self.__nidxs))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  def _getNumNonzero_alt_(self,):
    return self._getNumNonzero_()
  def _getNumNonzero_(self,):
   return numpy.int32(int((self.__nidxs).shape[0]))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getDim_alt_I(self,_t__a_0):
    return self._getDim_I(numpy.int32(__a_0))
  def _getDim_I(self,_a_0):
   return numpy.int32(self.__shape[_a_0])
  @staticmethod
  def _match_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _getAllIndexes_alt__3II(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.int32(_t__a_1)
   _1_res = self._getAllIndexes__3II(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getAllIndexes__3II(self,_a_0,_a_1):
   fragments._c_closure_328(_a_0,self.__nidxs,_a_1) 
  @staticmethod
  def _match_getIndex_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getIndex_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getIndex_alt_I(self,_t__a_0):
    return self._getIndex_I(numpy.int32(__a_0))
  def _getIndex_I(self,_a_0):
   return numpy.int32(self.__nidxs[_a_0])
  @staticmethod
  def _match_getValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getValue_(*args):
    if len(args) != 0: return False
    return True
  def _getValue_alt_(self,):
    return self._getValue_()
  def _getValue_(self,):
   return (self.__model._getParameterValue__3I(self.__nidxs))
  @staticmethod
  def _match_setValue__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_setValue__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  def _setValue_alt__3_5D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = self._setValue__3_5D(_a_0)
   return _1_res
  def _setValue__3_5D(self,_a_0):
   if ((self._getND_()!=2) or ((int((_a_0).shape[0])!=self.__shape[0]) or (int((_a_0).shape[1])!=self.__shape[1]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching value shape")
   if (self.__sp is None):
    _a_1=numpy.zeros(((self.__shape[0] * self.__shape[1]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_329(self.__shape,_a_1,_a_0) 
    self.__model._setParameterValue__3I_3D(self.__nidxs,_a_1)
   else:
    _a_2=numpy.zeros((int((self.__sp).shape[0]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_330(self.__shape,self.__sp,_a_2,_a_0) 
    self.__model._setParameterValue__3I_3D(self.__nidxs,_a_2)
  @staticmethod
  def _match_setValue__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_setValue__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  def _setValue_alt__3D(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = self._setValue__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _setValue__3D(self,_a_0):
   if (self.__sp is not None):
    if (int((_a_0).shape[0])!=self._getSize_()):
     raise mosek_fusion_LengthError._ctor_S("Length of value array is incorrect")
    else:
     _a_1=numpy.zeros((int((self.__nidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_331(_a_1,self.__nidxs,self.__sp,_a_0) 
     self.__model._setParameterValue__3I_3D(self.__nidxs,_a_1)
   else:
    if (int((_a_0).shape[0])!=int((self.__nidxs).shape[0])):
     raise mosek_fusion_LengthError._ctor_S("Length of value array is incorrect for sparse parameter")
    else:
     self.__model._setParameterValue__3I_3D(self.__nidxs,_a_0)
  @staticmethod
  def _match_setValue_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_setValue_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  def _setValue_alt_D(self,_t__a_0):
    return self._setValue_D(numpy.float64(__a_0))
  def _setValue_D(self,_a_0):
   _a_1=numpy.zeros((self.__size,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_332(self.__size,_a_1,_a_0) 
   self.__model._setParameterValue__3I_3D(self.__nidxs,_a_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
 return ParameterImpl
mosek_fusion_ParameterImpl=__mk_mosek_fusion_ParameterImpl()
del __mk_mosek_fusion_ParameterImpl
#BEFORE CLASS
def __mk_mosek_fusion_ExprRangeDomain():
 class ExprRangeDomain(mosek_fusion_ExprDomain,object):
  __slots__ = ['dom','expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprRangeDomain.ctor(mosek.fusion.Expression,mosek.fusion.RangeDomain)')
  def toDJCTerm(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprRangeDomain.toDJCTerm()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprRangeDomain._match_toDJCTerm_(*args):
      return self._toDJCTerm_(*args)
    elif mosek_fusion_ExprRangeDomain._match_alt_toDJCTerm_(*args):
      return self._toDJCTerm_alt_(*args)
    else:
      raise ValueError('Invalid argument list toDJCTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRangeDomain.toDJCTerm()')
  def __repr__(self): return 'mosek.fusion.ExprRangeDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(expr,dom):
    o = ExprRangeDomain.__new__(ExprRangeDomain)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(expr,dom)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,expr,dom):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(expr,dom)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,expr,dom):
   (self.expr) = expr
   (self.dom) = dom
  @staticmethod
  def _match_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  def _toDJCTerm_alt_(self,):
    return self._toDJCTerm_()
  def _toDJCTerm_(self,):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self.expr,self.dom))
 return ExprRangeDomain
mosek_fusion_ExprRangeDomain=__mk_mosek_fusion_ExprRangeDomain()
del __mk_mosek_fusion_ExprRangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_ExprPSDDomain():
 class ExprPSDDomain(object):
  __slots__ = ['dom','expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPSDDomain.ctor(mosek.fusion.Expression,mosek.fusion.PSDDomain)')
  def __repr__(self): return 'mosek.fusion.ExprPSDDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(expr,dom):
    o = ExprPSDDomain.__new__(ExprPSDDomain)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(expr,dom)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(dom))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(dom))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,expr,dom):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(expr,dom)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,expr,dom):
   (self.expr) = expr
   (self.dom) = dom
 return ExprPSDDomain
mosek_fusion_ExprPSDDomain=__mk_mosek_fusion_ExprPSDDomain()
del __mk_mosek_fusion_ExprPSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_ExprConicDomain():
 class ExprConicDomain(object):
  __slots__ = ['dom','expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprConicDomain.ctor(mosek.fusion.Expression,mosek.fusion.ConeDomain)')
  def __repr__(self): return 'mosek.fusion.ExprConicDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(expr,dom):
    o = ExprConicDomain.__new__(ExprConicDomain)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(expr,dom)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(dom))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(dom))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,expr,dom):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(expr,dom)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,expr,dom):
   (self.expr) = expr
   (self.dom) = dom
 return ExprConicDomain
mosek_fusion_ExprConicDomain=__mk_mosek_fusion_ExprConicDomain()
del __mk_mosek_fusion_ExprConicDomain
#BEFORE CLASS
def __mk_mosek_fusion_ExprLinearDomain():
 class ExprLinearDomain(mosek_fusion_ExprDomain,object):
  __slots__ = ['dom','expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprLinearDomain.ctor(mosek.fusion.Expression,mosek.fusion.LinearDomain)')
  def toDJCTerm(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprLinearDomain.toDJCTerm()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprLinearDomain._match_toDJCTerm_(*args):
      return self._toDJCTerm_(*args)
    elif mosek_fusion_ExprLinearDomain._match_alt_toDJCTerm_(*args):
      return self._toDJCTerm_alt_(*args)
    else:
      raise ValueError('Invalid argument list toDJCTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprLinearDomain.toDJCTerm()')
  def __repr__(self): return 'mosek.fusion.ExprLinearDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(expr,dom):
    o = ExprLinearDomain.__new__(ExprLinearDomain)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(expr,dom)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(dom))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    expr,dom, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(dom))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,expr,dom):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(expr,dom)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,expr,dom):
   (self.expr) = expr
   (self.dom) = dom
  @staticmethod
  def _match_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toDJCTerm_(*args):
    if len(args) != 0: return False
    return True
  def _toDJCTerm_alt_(self,):
    return self._toDJCTerm_()
  def _toDJCTerm_(self,):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self.expr,self.dom))
 return ExprLinearDomain
mosek_fusion_ExprLinearDomain=__mk_mosek_fusion_ExprLinearDomain()
del __mk_mosek_fusion_ExprLinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_BaseExpression():
 class BaseExpression(mosek_fusion_Expression,object):
  __slots__ = ['_BaseExpression__owner','_BaseExpression__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I(*args):
      self._ctor_init_Lmosek_4fusion_4Model_2_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseExpression.ctor(mosek.fusion.Model,array(int32,ndim=1))')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.slice(int32,int32)
      mosek.fusion.BaseExpression.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    first : int32
    firsta : array(int32,ndim=1)
    last : int32
    lasta : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseExpression._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.slice(int32,int32)\n\tmosek.fusion.BaseExpression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getSize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.getSize()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_getSize_(*args):
      return self._getSize_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getSize_(*args):
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getSize()')
  def pick(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.pick(array(int32,ndim=1))
      mosek.fusion.BaseExpression.pick(array(int32,ndim=2))

    Description
    -----------

    

    Parameters
    ----------

    indexes : array(int32,ndim=1)
    indexrows : array(int32,ndim=2)
    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_pick__3I(*args):
      return self._pick__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3I(*args):
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseExpression._match_pick__3_5I(*args):
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3_5I(*args):
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=2))')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_BaseExpression._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.toString()')
  def getShape(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.getShape()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_getShape_(*args):
      return self._getShape_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getShape_(*args):
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getShape()')
  def getModel(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.getModel()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_getModel_(*args):
      return self._getModel_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getModel_(*args):
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getModel()')
  def getDim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.getDim(int32)

    Description
    -----------

    

    Parameters
    ----------

    d : int32
    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_getDim_I(*args):
      return self._getDim_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_getDim_I(*args):
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getDim(int32)')
  def getND(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.getND()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_getND_(*args):
      return self._getND_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getND_(*args):
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getND()')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseExpression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def index(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.BaseExpression.index(int32)
      mosek.fusion.BaseExpression.index(array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    indexes : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_BaseExpression._match_index_I(*args):
      return self._index_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index_I(*args):
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseExpression._match_index__3I(*args):
      return self._index__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index__3I(*args):
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.index(int32)\n\tmosek.fusion.BaseExpression.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BaseExpression'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I(owner,shape):
    o = BaseExpression.__new__(BaseExpression)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I(owner,shape)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I(*args):
    if len(args) != 2: return False
    owner,shape, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(owner) and __arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I(*args):
    if len(args) != 2: return False
    owner,shape, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(owner) and __arg_alt_match__3I__(shape))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I(self,owner,shape):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I(owner,numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I(self,owner,shape):
   (self.__shape) = shape
   (self.__owner) = owner
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("Expression()")
  def _printStack_alt_Lmosek_4fusion_4WorkStack_2(self,_t__a_0):
    return self._printStack_Lmosek_4fusion_4WorkStack_2(_a_0)
  def _printStack_Lmosek_4fusion_4WorkStack_2(self,_a_0):
   _a_1=(_a_0.i32)
   _a_2=(_a_0.i64)
   _a_3=(_a_0.f64)
   _a_4=(_a_0.ptr_base)
   _a_5=(_a_0.nidxs_base)
   _a_6=(_a_0.cof_base)
   _a_7=(_a_0.shape_base)
   _a_8=(_a_0.codeptr_base)
   _a_9=(_a_0.code_base)
   _a_10=(_a_0.cconst_base)
   _a_11=(_a_0.sp_base)
   _a_12=(_a_0.nelem)
   _a_13=(_a_0.nnz)
   _a_14=(_a_0.ncodeatom)
   _a_15=(_a_0.nd)
   _a_16=(_a_0.hassp)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5I__(_a_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5I__(_a_0))
  def _pick_alt__3_5I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3_5I(_a_0)
   return _1_res
  def _pick__3_5I(self,_a_0):
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_a_0))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _pick_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._pick__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _pick__3I(self,_a_0):
   _a_1=numpy.zeros((int((_a_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_333(_a_1,_a_0) 
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_a_1))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  def _index_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self._index__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _index__3I(self,_a_0):
   _a_1=numpy.zeros((1,int((_a_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_334(_a_1,_a_0) 
   return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_a_1)))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _index_alt_I(self,_t__a_0):
    return self._index_I(numpy.int32(__a_0))
  def _index_I(self,_a_0):
   _a_1=numpy.zeros((1,1,), dtype=numpy.dtype(numpy.int32))
   _a_1[0,0] = _a_0
   return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_a_1)))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,_a_0,_a_1))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _getDim_alt_I(self,_t__a_0):
    return self._getDim_I(numpy.int32(__a_0))
  def _getDim_I(self,_a_0):
   return numpy.int32(self.__shape[_a_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__owner)
  @staticmethod
  def _modelFrom_alt__3Lmosek_4fusion_4Expression_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_BaseExpression._modelFrom__3Lmosek_4fusion_4Expression_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _modelFrom__3Lmosek_4fusion_4Expression_2(_a_0):
   if (int((_a_0).shape[0])==0):
    return (None)
   else:
    _a_1=_a_0[0]._getModel_()
    for _a_2 in range(1,int((_a_0).shape[0])):
     _a_1 = mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(_a_1,_a_0[_a_2])
    return (_a_1)
  @staticmethod
  def _modelFrom_alt_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Model_2(_a_0,_a_1._getModel_()))
  @staticmethod
  def _modelFrom_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_BaseExpression._modelFrom_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _modelFrom_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Model_2(_a_0._getModel_(),_a_1._getModel_()))
  @staticmethod
  def _modelFrom_alt_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Model_2(_t__a_0,_t__a_1):
    return mosek_fusion_BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Model_2(_a_0,_a_1)
  @staticmethod
  def _modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Model_2(_a_0,_a_1):
   if (_a_0 is None):
    return (_a_1)
   elif ((_a_1 is not None) and (_a_0 is not _a_1)):
    raise mosek_fusion_ModelError._ctor_S("Mixing different models")
   else:
    return (_a_0)
 return BaseExpression
mosek_fusion_BaseExpression=__mk_mosek_fusion_BaseExpression()
del __mk_mosek_fusion_BaseExpression
#BEFORE CLASS
def __mk_mosek_fusion_ExprParameter():
 class ExprParameter(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprParameter__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprParameter.ctor(mosek.fusion.Parameter)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprParameter.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprParameter._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprParameter._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def slice(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprParameter.slice(int32,int32)
      mosek.fusion.ExprParameter.slice(array(int32,ndim=1),array(int32,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    start : array(int32,ndim=1)
    stop : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_ExprParameter._match_slice_II(*args):
      return self._slice_II(*args)
    elif mosek_fusion_ExprParameter._match_alt_slice_II(*args):
      return self._slice_alt_II(*args)
    elif mosek_fusion_ExprParameter._match_slice__3I_3I(*args):
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ExprParameter._match_alt_slice__3I_3I(*args):
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.slice(int32,int32)\n\tmosek.fusion.ExprParameter.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprParameter.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprParameter._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprParameter._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.toString()')
  def __repr__(self): return 'mosek.fusion.ExprParameter'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2(p):
    o = ExprParameter.__new__(ExprParameter)
    o._ctor_init_Lmosek_4fusion_4Parameter_2(p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    p, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2(self,p):
    self._ctor_init_Lmosek_4fusion_4Parameter_2(p)
  def _ctor_init_Lmosek_4fusion_4Parameter_2(self,p):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,p._getModel_(),p._getShape_())
   (self.__p) = p
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__p._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1))
  def _slice_alt__3I_3I(self,_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = self._slice__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _slice__3I_3I(self,_a_0,_a_1):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self.__p._slice__3I_3I(_a_0,_a_1)))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _slice_alt_II(self,_t__a_0,_t__a_1):
    return self._slice_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _slice_II(self,_a_0,_a_1):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self.__p._slice_II(_a_0,_a_1)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprParameter(")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprParameter
mosek_fusion_ExprParameter=__mk_mosek_fusion_ExprParameter()
del __mk_mosek_fusion_ExprParameter
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamScalarExpr():
 class ExprMulParamScalarExpr(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamScalarExpr__e','_ExprMulParamScalarExpr__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamScalarExpr.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamScalarExpr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamScalarExpr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamScalarExpr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalarExpr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamScalarExpr.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamScalarExpr._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamScalarExpr._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalarExpr.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamScalarExpr'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamScalarExpr.__new__(ExprMulParamScalarExpr)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(p._getModel_(),e),p._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (e._getND_()!=0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   if (_a_6!=0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.sp_base)
   _a_13=(_a_1.nidxs_base)
   _a_14=(_a_1.cof_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.codeptr_base)
   _a_17=(_a_1.code_base)
   _a_18=self.__p._getND_()
   _a_19=self.__p._getNumNonzero_()
   _a_20=(_a_8 * self.__p._getNumNonzero_())
   _a_21=(self.__p._getNumNonzero_() < self.__p._getSize_())
   _a_22=(((_a_11 * _a_19) + (_a_20 * 4)) if ((_a_11 > 0) ) else (_a_20 * 3))
   _a_23=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_24=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_24,_a_23)
   _a_0._alloc_1expr_IIIZI(_a_18,_a_19,_a_20,_a_21,_a_22)
   _a_25=(_a_0.i64)
   _a_26=(_a_0.f64)
   _a_27=(_a_0.i32)
   _a_28=(_a_0.ptr_base)
   _a_29=(_a_0.nidxs_base)
   _a_30=(_a_0.sp_base)
   _a_31=(_a_0.cof_base)
   _a_32=(_a_0.hassp)
   _a_33=(_a_0.shape_base)
   _a_34=(_a_0.codeptr_base)
   _a_35=(_a_0.code_base)
   _a_36=(_a_0.cconst_base)
   fragments._c_closure_335(_a_31,_a_26,_a_20) 
   fragments._c_closure_336(_a_8,_a_27,_a_19,_a_28) 
   for _a_37 in range(0,_a_18):
    _a_27[(_a_33 + _a_37)] = self.__p._getDim_I(_a_37)
   if _a_32:
    self.__p._getSp__3JI(_a_25,_a_30)
   fragments._c_closure_337(_a_25,_a_29,_a_20) 
   fragments._c_closure_338(_a_13,_a_8,_a_25,_a_19,_a_29,_a_4) 
   if (_a_22 > 0):
    _a_27[_a_34] = 0
   fragments._c_closure_339(_a_15,_a_17,_a_14,_a_11,_a_8,_a_23,_a_16,_a_36,_a_35,_a_34,_a_26,_a_27,_a_19,_a_5,_a_3,_a_24) 
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamScalarExpr(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamScalarExpr
mosek_fusion_ExprMulParamScalarExpr=__mk_mosek_fusion_ExprMulParamScalarExpr()
del __mk_mosek_fusion_ExprMulParamScalarExpr
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamScalar():
 class ExprMulParamScalar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamScalar__e','_ExprMulParamScalar__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamScalar.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamScalar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamScalar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamScalar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamScalar.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamScalar._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamScalar._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamScalar'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamScalar.__new__(ExprMulParamScalar)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(p._getModel_(),e),e._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.shape_base)
   _a_13=(_a_1.sp_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.cconst_base)
   _a_17=(_a_1.codeptr_base)
   _a_18=(_a_1.code_base)
   _a_19=_a_6
   _a_20=_a_7
   _a_21=_a_8
   _a_22=_a_9
   _a_23=((_a_8 * 3) if ((_a_11==0) ) else ((_a_8 * 4) + _a_11))
   _a_0._alloc_1expr_IIIZI(_a_19,_a_20,_a_21,_a_22,_a_23)
   _a_24=(_a_0.i64)
   _a_25=(_a_0.f64)
   _a_26=(_a_0.i32)
   _a_27=(_a_0.ptr_base)
   _a_28=(_a_0.nidxs_base)
   _a_29=(_a_0.sp_base)
   _a_30=(_a_0.cof_base)
   _a_31=(_a_0.hassp)
   _a_32=(_a_0.shape_base)
   _a_33=(_a_0.codeptr_base)
   _a_34=(_a_0.code_base)
   _a_35=(_a_0.cconst_base)
   _a_36=self.__p._getIndex_I(0)
   fragments._c_closure_340(_a_16,_a_18,_a_15,_a_11,_a_14,_a_8,_a_36,_a_10,_a_17,_a_35,_a_34,_a_33,_a_30,_a_25,_a_31,_a_26,_a_24,_a_23,_a_19,_a_20,_a_28,_a_21,_a_27,_a_32,_a_29,_a_12,_a_13,_a_5,_a_3,_a_4) 
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamScalar(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamScalar
mosek_fusion_ExprMulParamScalar=__mk_mosek_fusion_ExprMulParamScalar()
del __mk_mosek_fusion_ExprMulParamScalar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamDiagLeft():
 class ExprMulParamDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamDiagLeft__e','_ExprMulParamDiagLeft__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamDiagLeft.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamDiagLeft.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamDiagLeft._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamDiagLeft._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamDiagLeft'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamDiagLeft.__new__(ExprMulParamDiagLeft)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(p._getModel_(),e),numpy.array([e._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if ((p._getDim_I(1)!=e._getDim_I(0)) or (p._getDim_I(0)!=e._getDim_I(1))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.shape_base)
   _a_13=(_a_1.sp_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.cconst_base)
   _a_17=(_a_1.codeptr_base)
   _a_18=(_a_1.code_base)
   if ((_a_6!=2) or ((_a_3[_a_12]!=self.__p._getDim_I(1)) or (_a_3[(_a_12 + 1)]!=self.__p._getDim_I(0)))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   _a_19=self.__p._getNumNonzero_()
   _a_20=_a_2._alloci64_I(_a_19)
   _a_21=(_a_2.i64)
   self.__p._getSp__3JI(_a_21,_a_20)
   _a_22=self.__p._getDim_I(0)
   _a_23=self.__p._getDim_I(1)
   _a_24=_a_3[_a_12]
   _a_25=_a_3[(_a_12 + 1)]
   _a_26=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_27=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_27,_a_26)
   if _a_9:
    _a_28=_a_2._alloci32_I(_a_7)
    _a_29=_a_2._alloci32_I((_a_25 + 1))
    _a_30=(_a_2.i32)
    fragments._c_closure_341(_a_25,_a_29,_a_30) 
    fragments._c_closure_342(_a_25,_a_29,_a_7,_a_13,_a_4,_a_30) 
    fragments._c_closure_343(_a_25,_a_29,_a_30) 
    fragments._c_closure_344(_a_25,_a_28,_a_29,_a_7,_a_13,_a_4,_a_30) 
    _a_31=0
    _a_32=0
    _a_33=0
    _a_33,_a_31,_a_32 = fragments._c_closure_345(_a_17,_a_25,_a_28,_a_11,_a_7,_a_23,_a_19,_a_20,_a_10,_a_33,_a_31,_a_32,_a_13,_a_3,_a_4,_a_30,_a_21)
    _a_33 = numpy.int32(_a_33) # postprocess
    _a_31 = numpy.int32(_a_31) # postprocess
    _a_32 = numpy.int32(_a_32) # postprocess
    _a_34=1
    _a_35=(_a_31 < _a_22)
    _a_0._alloc_1expr_IIIZI(_a_34,_a_31,_a_32,_a_35,_a_33)
    _a_36=(_a_0.ptr_base)
    _a_37=(_a_0.nidxs_base)
    _a_38=((_a_0.sp_base) if (_a_35 ) else _a_0._alloci64_I(_a_31))
    _a_39=(_a_0.cof_base)
    _a_40=(_a_0.hassp)
    _a_41=(_a_0.shape_base)
    _a_42=(_a_0.codeptr_base)
    _a_43=(_a_0.code_base)
    _a_44=(_a_0.cconst_base)
    _a_45=(_a_0.i64)
    _a_46=(_a_0.f64)
    _a_47=(_a_0.i32)
    fragments._c_closure_346(_a_16,_a_18,_a_17,_a_15,_a_25,_a_28,_a_11,_a_7,_a_14,_a_22,_a_23,_a_26,_a_19,_a_20,_a_10,_a_44,_a_43,_a_42,_a_39,_a_46,_a_47,_a_45,_a_31,_a_37,_a_32,_a_36,_a_41,_a_38,_a_13,_a_5,_a_3,_a_4,_a_30,_a_21) 
    if (not _a_40):
     _a_0._popi64_I(_a_31)
    _a_2._clear_()
   else:
    _a_48=0
    _a_49=0
    _a_50=0
    _a_51=(_a_2.i32)
    _a_50,_a_48,_a_49 = fragments._c_closure_347(_a_17,_a_25,_a_11,_a_23,_a_19,_a_20,_a_10,_a_50,_a_48,_a_49,_a_3,_a_21)
    _a_50 = numpy.int32(_a_50) # postprocess
    _a_48 = numpy.int32(_a_48) # postprocess
    _a_49 = numpy.int32(_a_49) # postprocess
    _a_52=1
    _a_53=(_a_48 < _a_22)
    _a_0._alloc_1expr_IIIZI(_a_52,_a_48,_a_49,_a_53,_a_50)
    _a_54=(_a_0.ptr_base)
    _a_55=(_a_0.nidxs_base)
    _a_56=((_a_0.sp_base) if (_a_53 ) else _a_0._alloci64_I(_a_48))
    _a_57=(_a_0.cof_base)
    _a_58=(_a_0.hassp)
    _a_59=(_a_0.shape_base)
    _a_60=(_a_0.codeptr_base)
    _a_61=(_a_0.code_base)
    _a_62=(_a_0.cconst_base)
    _a_63=(_a_0.i64)
    _a_64=(_a_0.f64)
    _a_65=(_a_0.i32)
    fragments._c_closure_348(_a_16,_a_18,_a_17,_a_15,_a_25,_a_11,_a_14,_a_22,_a_23,_a_26,_a_19,_a_20,_a_10,_a_62,_a_61,_a_60,_a_57,_a_64,_a_65,_a_63,_a_50,_a_55,_a_54,_a_59,_a_56,_a_5,_a_3,_a_4,_a_51,_a_21) 
    if (not _a_58):
     _a_0._popi64_I(_a_48)
    _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamDiagLeft(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamDiagLeft
mosek_fusion_ExprMulParamDiagLeft=__mk_mosek_fusion_ExprMulParamDiagLeft()
del __mk_mosek_fusion_ExprMulParamDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamDiagRight():
 class ExprMulParamDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamDiagRight__e','_ExprMulParamDiagRight__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamDiagRight.ctor(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamDiagRight.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamDiagRight._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamDiagRight._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamDiagRight'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p):
    o = ExprMulParamDiagRight.__new__(ExprMulParamDiagRight)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(p._getModel_(),e),numpy.array([e._getDim_I(0)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if ((p._getDim_I(1)!=e._getDim_I(0)) or (p._getDim_I(0)!=e._getDim_I(1))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.shape_base)
   _a_13=(_a_1.sp_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.cconst_base)
   _a_17=(_a_1.codeptr_base)
   _a_18=(_a_1.code_base)
   if ((_a_6!=2) or ((_a_3[_a_12]!=self.__p._getDim_I(1)) or (_a_3[(_a_12 + 1)]!=self.__p._getDim_I(0)))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   _a_19=self.__p._getNumNonzero_()
   _a_20=_a_2._alloci64_I(_a_19)
   _a_21=(_a_2.i64)
   _a_22=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_23=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_23,_a_22)
   self.__p._getSp__3JI(_a_21,_a_20)
   _a_24=self.__p._getDim_I(0)
   _a_25=self.__p._getDim_I(1)
   _a_26=_a_3[_a_12]
   _a_27=_a_3[(_a_12 + 1)]
   _a_28=_a_2._alloci32_I(_a_19)
   _a_29=_a_2._alloci32_I((_a_25 + 1))
   _a_30=(_a_2.i32)
   fragments._c_closure_349(_a_25,_a_29,_a_30) 
   fragments._c_closure_350(_a_25,_a_19,_a_29,_a_20,_a_30,_a_21) 
   fragments._c_closure_351(_a_25,_a_29,_a_30) 
   fragments._c_closure_352(_a_25,_a_19,_a_28,_a_29,_a_20,_a_30,_a_21) 
   if _a_9:
    _a_31=0
    _a_32=0
    _a_33=0
    _a_34=0
    _a_35=0
    _a_35,_a_34,_a_31,_a_32,_a_33 = fragments._c_closure_353(_a_17,_a_27,_a_35,_a_34,_a_11,_a_7,_a_25,_a_19,_a_28,_a_20,_a_10,_a_31,_a_32,_a_33,_a_13,_a_3,_a_4,_a_30,_a_21)
    _a_35 = numpy.int32(_a_35) # postprocess
    _a_34 = numpy.int32(_a_34) # postprocess
    _a_31 = numpy.int32(_a_31) # postprocess
    _a_32 = numpy.int32(_a_32) # postprocess
    _a_33 = numpy.int32(_a_33) # postprocess
    _a_36=1
    _a_37=(_a_32 < _a_26)
    _a_0._alloc_1expr_IIIZI(_a_36,_a_32,_a_33,_a_37,_a_31)
    _a_38=(_a_0.ptr_base)
    _a_39=(_a_0.nidxs_base)
    _a_40=((_a_0.sp_base) if (_a_37 ) else _a_0._alloci64_I(_a_32))
    _a_41=(_a_0.cof_base)
    _a_42=(_a_0.hassp)
    _a_43=(_a_0.shape_base)
    _a_44=(_a_0.codeptr_base)
    _a_45=(_a_0.code_base)
    _a_46=(_a_0.cconst_base)
    _a_47=(_a_0.i64)
    _a_48=(_a_0.f64)
    _a_49=(_a_0.i32)
    if (_a_32 > 0):
     _a_49[_a_38] = 0
     if (_a_31 > 0):
      _a_49[_a_44] = 0
     _a_49[_a_43] = numpy.int32(_a_26)
     _a_50=0
     _a_51=0
     _a_52=0
     _a_53=0
     _a_54=0
     _a_50,_a_51,_a_54,_a_53,_a_52 = fragments._c_closure_354(_a_16,_a_18,_a_50,_a_17,_a_15,_a_27,_a_51,_a_54,_a_53,_a_11,_a_7,_a_14,_a_52,_a_25,_a_22,_a_19,_a_28,_a_20,_a_10,_a_46,_a_45,_a_44,_a_41,_a_48,_a_49,_a_47,_a_39,_a_38,_a_40,_a_13,_a_5,_a_3,_a_4,_a_30,_a_21)
     _a_50 = numpy.int32(_a_50) # postprocess
     _a_51 = numpy.int32(_a_51) # postprocess
     _a_54 = numpy.int32(_a_54) # postprocess
     _a_53 = numpy.int32(_a_53) # postprocess
     _a_52 = numpy.int32(_a_52) # postprocess
     if (_a_32 > _a_49[_a_43]):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid shape")
     if (_a_51!=_a_32):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
     if (_a_52!=_a_33):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
    if (not _a_42):
     _a_0._popi64_I(_a_32)
    _a_2._clear_()
   else:
    _a_55=0
    _a_56=0
    _a_57=0
    _a_58=0
    _a_58,_a_55,_a_56,_a_57 = fragments._c_closure_355(_a_17,_a_27,_a_58,_a_11,_a_25,_a_19,_a_28,_a_20,_a_10,_a_55,_a_56,_a_57,_a_3,_a_30,_a_21)
    _a_58 = numpy.int32(_a_58) # postprocess
    _a_55 = numpy.int32(_a_55) # postprocess
    _a_56 = numpy.int32(_a_56) # postprocess
    _a_57 = numpy.int32(_a_57) # postprocess
    _a_59=1
    _a_60=(_a_56 < _a_26)
    _a_0._alloc_1expr_IIIZI(_a_59,_a_56,_a_57,_a_60,_a_55)
    _a_61=(_a_0.ptr_base)
    _a_62=(_a_0.nidxs_base)
    _a_63=((_a_0.sp_base) if (_a_60 ) else _a_0._alloci64_I(_a_56))
    _a_64=(_a_0.cof_base)
    _a_65=(_a_0.hassp)
    _a_66=(_a_0.shape_base)
    _a_67=(_a_0.codeptr_base)
    _a_68=(_a_0.code_base)
    _a_69=(_a_0.cconst_base)
    _a_70=(_a_0.i64)
    _a_71=(_a_0.f64)
    _a_72=(_a_0.i32)
    _a_72[_a_61] = 0
    if (_a_55 > 0):
     _a_72[_a_67] = 0
    _a_72[_a_66] = numpy.int32(_a_26)
    _a_73=0
    _a_74=0
    _a_75=0
    _a_76=0
    _a_73,_a_74,_a_76,_a_75 = fragments._c_closure_356(_a_16,_a_18,_a_73,_a_17,_a_15,_a_27,_a_74,_a_76,_a_11,_a_14,_a_75,_a_25,_a_22,_a_19,_a_28,_a_20,_a_10,_a_69,_a_68,_a_67,_a_64,_a_71,_a_72,_a_70,_a_62,_a_61,_a_63,_a_5,_a_3,_a_4,_a_30,_a_21)
    _a_73 = numpy.int32(_a_73) # postprocess
    _a_74 = numpy.int32(_a_74) # postprocess
    _a_76 = numpy.int32(_a_76) # postprocess
    _a_75 = numpy.int32(_a_75) # postprocess
    if (_a_56 > _a_72[_a_66]):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid shape")
    if (_a_74!=_a_56):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
    if (_a_75!=_a_57):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
    if (not _a_65):
     _a_0._popi64_I(_a_56)
    _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamDiagRight(")._a_S(self.__e._toString_())._a_S(",")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprMulParamDiagRight
mosek_fusion_ExprMulParamDiagRight=__mk_mosek_fusion_ExprMulParamDiagRight()
del __mk_mosek_fusion_ExprMulParamDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprDotParam():
 class ExprDotParam(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDotParam__e','_ExprDotParam__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDotParam.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDotParam.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprDotParam._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDotParam._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDotParam.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDotParam.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprDotParam._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprDotParam._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDotParam.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDotParam'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprDotParam.__new__(ExprDotParam)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(p._getModel_(),e),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=e._getND_()):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   for _a_0 in range(0,p._getND_()):
    if (p._getDim_I(_a_0)!=e._getDim_I(_a_0)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.shape_base)
   _a_13=(_a_1.sp_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.cconst_base)
   _a_17=(_a_1.codeptr_base)
   _a_18=(_a_1.code_base)
   _a_19=self.__p._getNumNonzero_()
   _a_20=_a_2._alloci64_I(_a_19)
   self.__p._getSp__3JI((_a_2.i64),_a_20)
   _a_21=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_22=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_22,_a_21)
   _a_23=(_a_2.i64)
   _a_24=0
   _a_25=1
   _a_26=0
   _a_26,_a_24 = fragments._c_closure_357(_a_17,_a_9,_a_11,_a_7,_a_19,_a_20,_a_10,_a_26,_a_24,_a_13,_a_3,_a_4,_a_23)
   _a_26 = numpy.int32(_a_26) # postprocess
   _a_24 = numpy.int32(_a_24) # postprocess
   _a_27=1
   _a_27 = fragments._c_closure_358(_a_6,_a_27,_a_12,_a_3)
   _a_27 = numpy.int64(_a_27) # postprocess
   _a_0._alloc_1expr_IIIZI(0,_a_25,_a_24,False,_a_26)
   _a_28=(_a_0.ptr_base)
   _a_29=(_a_0.nidxs_base)
   _a_30=(_a_0.cof_base)
   _a_31=(_a_0.hassp)
   _a_32=(_a_0.shape_base)
   _a_33=(_a_0.codeptr_base)
   _a_34=(_a_0.code_base)
   _a_35=(_a_0.cconst_base)
   _a_36=(_a_0.i64)
   _a_37=(_a_0.f64)
   _a_38=(_a_0.i32)
   _a_38[_a_28] = 0
   _a_38[(_a_28 + 1)] = _a_24
   if (_a_26 > 0):
    _a_38[_a_33] = 0
   if _a_9:
    _a_39=0
    _a_40=0
    _a_41=0
    _a_42=0
    _a_43=0
    _a_39,_a_42,_a_40,_a_43 = fragments._c_closure_359(_a_16,_a_18,_a_39,_a_17,_a_15,_a_42,_a_11,_a_7,_a_14,_a_40,_a_43,_a_21,_a_19,_a_20,_a_10,_a_35,_a_34,_a_33,_a_30,_a_37,_a_38,_a_36,_a_29,_a_13,_a_5,_a_3,_a_4,_a_22,_a_23)
    _a_39 = numpy.int32(_a_39) # postprocess
    _a_42 = numpy.int32(_a_42) # postprocess
    _a_40 = numpy.int32(_a_40) # postprocess
    _a_43 = numpy.int32(_a_43) # postprocess
    if (_a_41!=_a_25):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken elmi")
    if (_a_40!=_a_24):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken nzi")
    if (_a_39!=_a_26):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken codei")
   else:
    _a_44=0
    _a_45=0
    _a_44,_a_45 = fragments._c_closure_360(_a_16,_a_18,_a_44,_a_17,_a_15,_a_11,_a_14,_a_45,_a_21,_a_19,_a_20,_a_10,_a_35,_a_34,_a_33,_a_30,_a_37,_a_38,_a_36,_a_29,_a_5,_a_3,_a_4,_a_22,_a_23)
    _a_44 = numpy.int32(_a_44) # postprocess
    _a_45 = numpy.int32(_a_45) # postprocess
    if (_a_45!=_a_24):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nzi")
    if (_a_44!=_a_26):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid codei")
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDotParam(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprDotParam
mosek_fusion_ExprDotParam=__mk_mosek_fusion_ExprDotParam()
del __mk_mosek_fusion_ExprDotParam
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamElem():
 class ExprMulParamElem(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamElem__e','_ExprMulParamElem__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamElem.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamElem.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamElem._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamElem._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamElem.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamElem.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamElem._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamElem._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamElem.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamElem'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamElem.__new__(ExprMulParamElem)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Expression_2(p._getModel_(),e),e._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=e._getND_()):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   for _a_0 in range(0,p._getND_()):
    if (p._getDim_I(_a_0)!=e._getDim_I(_a_0)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.shape_base)
   _a_13=(_a_1.sp_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.cconst_base)
   _a_17=(_a_1.codeptr_base)
   _a_18=(_a_1.code_base)
   _a_19=self.__p._getNumNonzero_()
   _a_20=_a_2._alloci64_I(_a_19)
   self.__p._getSp__3JI((_a_2.i64),_a_20)
   _a_21=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_22=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_22,_a_21)
   _a_23=(_a_2.i64)
   _a_24=_a_6
   _a_25=0
   _a_26=0
   _a_27=0
   _a_27,_a_26,_a_25 = fragments._c_closure_361(_a_17,_a_9,_a_11,_a_7,_a_19,_a_20,_a_10,_a_27,_a_26,_a_25,_a_13,_a_3,_a_4,_a_23)
   _a_27 = numpy.int32(_a_27) # postprocess
   _a_26 = numpy.int32(_a_26) # postprocess
   _a_25 = numpy.int32(_a_25) # postprocess
   _a_28=1
   _a_28 = fragments._c_closure_362(_a_6,_a_28,_a_12,_a_3)
   _a_28 = numpy.int64(_a_28) # postprocess
   _a_29=(_a_26 < _a_28)
   _a_0._alloc_1expr_IIIZI(_a_24,_a_26,_a_25,_a_29,_a_27)
   _a_30=(_a_0.ptr_base)
   _a_31=(_a_0.nidxs_base)
   _a_32=((_a_0.sp_base) if (_a_29 ) else _a_0._alloci64_I(_a_26))
   _a_33=(_a_0.cof_base)
   _a_34=(_a_0.hassp)
   _a_35=(_a_0.shape_base)
   _a_36=(_a_0.codeptr_base)
   _a_37=(_a_0.code_base)
   _a_38=(_a_0.cconst_base)
   _a_39=(_a_0.i64)
   _a_40=(_a_0.f64)
   _a_41=(_a_0.i32)
   fragments._c_closure_363(_a_6,_a_41,_a_35,_a_12,_a_3) 
   _a_41[_a_30] = 0
   if (_a_27 > 0):
    _a_41[_a_36] = 0
   if _a_9:
    _a_42=0
    _a_43=0
    _a_44=0
    _a_45=0
    _a_46=0
    _a_42,_a_45,_a_44,_a_43,_a_46 = fragments._c_closure_364(_a_16,_a_18,_a_42,_a_17,_a_15,_a_45,_a_44,_a_11,_a_7,_a_14,_a_43,_a_46,_a_21,_a_19,_a_20,_a_10,_a_38,_a_37,_a_36,_a_33,_a_40,_a_41,_a_39,_a_31,_a_30,_a_32,_a_13,_a_5,_a_3,_a_4,_a_22,_a_23)
    _a_42 = numpy.int32(_a_42) # postprocess
    _a_45 = numpy.int32(_a_45) # postprocess
    _a_44 = numpy.int32(_a_44) # postprocess
    _a_43 = numpy.int32(_a_43) # postprocess
    _a_46 = numpy.int32(_a_46) # postprocess
    if (_a_44!=_a_26):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken elmi")
    if (_a_43!=_a_25):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken nzi")
    if (_a_42!=_a_27):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken codei")
   else:
    _a_47=0
    _a_48=0
    _a_47,_a_48 = fragments._c_closure_365(_a_16,_a_18,_a_47,_a_17,_a_15,_a_11,_a_14,_a_48,_a_21,_a_19,_a_20,_a_10,_a_38,_a_37,_a_36,_a_33,_a_40,_a_41,_a_39,_a_31,_a_30,_a_32,_a_5,_a_3,_a_4,_a_22,_a_23)
    _a_47 = numpy.int32(_a_47) # postprocess
    _a_48 = numpy.int32(_a_48) # postprocess
    if (_a_27!=_a_47):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Invalid code list result")
   if (not _a_34):
    _a_0._popi64_I(_a_26)
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamElem(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamElem
mosek_fusion_ExprMulParamElem=__mk_mosek_fusion_ExprMulParamElem()
del __mk_mosek_fusion_ExprMulParamElem
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamRight():
 class ExprMulParamRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamRight__e','_ExprMulParamRight__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamRight.ctor(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamRight.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamRight._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamRight._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamRight'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p):
    o = ExprMulParamRight.__new__(ExprMulParamRight)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,p._getModel_(),numpy.array([e._getDim_I(0),p._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if (p._getDim_I(0)!=e._getDim_I(1)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.ncodeatom)
   _a_12=(_a_1.shape_base)
   _a_13=(_a_1.sp_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.cconst_base)
   _a_17=(_a_1.codeptr_base)
   _a_18=(_a_1.code_base)
   if ((_a_6!=2) or (self.__p._getDim_I(0)!=_a_3[(_a_12 + 1)])):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _a_19=_a_3[_a_12]
   _a_20=_a_3[(_a_12 + 1)]
   _a_21=self.__p._getDim_I(0)
   _a_22=self.__p._getDim_I(1)
   _a_23=self.__p._getNumNonzero_()
   _a_24=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_25=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_25,_a_24)
   _a_26=_a_2._alloci32_I(_a_23)
   _a_27=_a_2._alloci64_I(_a_23)
   self.__p._getSp__3JI((_a_2.i64),_a_27)
   _a_28=_a_2._alloci32_I((_a_22 + 1))
   _a_29=(_a_2.i32)
   _a_30=(_a_2.i64)
   fragments._c_closure_366(_a_22,_a_28,_a_29) 
   fragments._c_closure_367(_a_22,_a_23,_a_28,_a_27,_a_29,_a_30) 
   fragments._c_closure_368(_a_22,_a_28,_a_29) 
   fragments._c_closure_369(_a_22,_a_23,_a_26,_a_28,_a_27,_a_29,_a_30) 
   _a_31=(_a_2.i32)
   _a_32=(_a_2.i64)
   _a_33=0
   _a_34=0
   _a_35=0
   if ((not self.__p._isSparse_()) and (not _a_9)):
    _a_35 = (_a_8 * _a_22)
    _a_34 = (_a_19 * _a_22)
    _a_33 = (((_a_11 + (_a_8 * 4)) * _a_22) if ((_a_11 > 0) ) else ((_a_8 * _a_22) * 3))
   elif (not _a_9):
    _a_33,_a_34,_a_35 = fragments._c_closure_370(_a_17,_a_19,_a_20,_a_11,_a_22,_a_23,_a_26,_a_27,_a_10,_a_33,_a_34,_a_35,_a_3,_a_31,_a_32)
    _a_33 = numpy.int32(_a_33) # postprocess
    _a_34 = numpy.int32(_a_34) # postprocess
    _a_35 = numpy.int32(_a_35) # postprocess
   else:
    _a_33,_a_34,_a_35 = fragments._c_closure_371(_a_17,_a_20,_a_11,_a_7,_a_22,_a_23,_a_26,_a_27,_a_10,_a_33,_a_34,_a_35,_a_13,_a_3,_a_4,_a_31,_a_32)
    _a_33 = numpy.int32(_a_33) # postprocess
    _a_34 = numpy.int32(_a_34) # postprocess
    _a_35 = numpy.int32(_a_35) # postprocess
   _a_36=2
   _a_37=(_a_34 < (_a_22 * _a_19))
   _a_0._alloc_1expr_IIIZI(_a_36,_a_34,_a_35,_a_37,_a_33)
   _a_38=(_a_0.ptr_base)
   _a_39=(_a_0.nidxs_base)
   _a_40=((_a_0.sp_base) if (_a_37 ) else _a_0._alloci64_I(_a_34))
   _a_41=(_a_0.cof_base)
   _a_42=(_a_0.hassp)
   _a_43=(_a_0.shape_base)
   _a_44=(_a_0.codeptr_base)
   _a_45=(_a_0.code_base)
   _a_46=(_a_0.cconst_base)
   _a_47=(_a_0.i64)
   _a_48=(_a_0.f64)
   _a_49=(_a_0.i32)
   _a_49[_a_38] = 0
   if (_a_33 > 0):
    _a_49[_a_44] = 0
   _a_49[_a_43] = _a_19
   _a_49[(_a_43 + 1)] = _a_22
   _a_50=0
   _a_51=0
   _a_52=0
   _a_50,_a_51,_a_52 = fragments._c_closure_372(_a_16,_a_18,_a_50,_a_17,_a_15,_a_19,_a_20,_a_51,_a_9,_a_11,_a_7,_a_14,_a_52,_a_22,_a_24,_a_23,_a_26,_a_27,_a_10,_a_46,_a_45,_a_44,_a_41,_a_48,_a_49,_a_47,_a_39,_a_38,_a_40,_a_13,_a_5,_a_3,_a_4,_a_31,_a_32)
   _a_50 = numpy.int32(_a_50) # postprocess
   _a_51 = numpy.int32(_a_51) # postprocess
   _a_52 = numpy.int32(_a_52) # postprocess
   if (not _a_42):
    _a_0._popi64_I(_a_34)
   if (_a_51!=_a_34):
    raise mosek_fusion_UnexpectedError._ctor_S("broken elmi")
   if (_a_52!=_a_35):
    raise mosek_fusion_UnexpectedError._ctor_S("broken nzi")
   if (_a_50!=_a_33):
    raise mosek_fusion_UnexpectedError._ctor_S("broken codei")
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamRight(")._a_S(self.__e._toString_())._a_S(",")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprMulParamRight
mosek_fusion_ExprMulParamRight=__mk_mosek_fusion_ExprMulParamRight()
del __mk_mosek_fusion_ExprMulParamRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamLeft():
 class ExprMulParamLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamLeft__e','_ExprMulParamLeft__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamLeft.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulParamLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulParamLeft.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulParamLeft._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamLeft._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamLeft'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamLeft.__new__(ExprMulParamLeft)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,p._getModel_(),numpy.array([p._getDim_I(0),e._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if (p._getDim_I(1)!=e._getDim_I(0)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ncodeatom)
   _a_11=(_a_1.ptr_base)
   _a_12=(_a_1.code_base)
   _a_13=(_a_1.cconst_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.shape_base)
   _a_16=(_a_1.sp_base)
   _a_17=(_a_1.nidxs_base)
   _a_18=(_a_1.cof_base)
   _a_19=(_a_1.cconst_base)
   if ((_a_6!=2) or (_a_3[_a_15]!=self.__p._getDim_I(1))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _a_20=self.__p._getDim_I(0)
   _a_21=self.__p._getDim_I(1)
   _a_22=_a_3[_a_15]
   _a_23=_a_3[(_a_15 + 1)]
   _a_24=self.__p._getNumNonzero_()
   _a_25=_a_2._alloci32_I(self.__p._getNumNonzero_())
   _a_26=(_a_2.i32)
   self.__p._getAllIndexes__3II(_a_26,_a_25)
   if ((not _a_9) and (not self.__p._isSparse_())):
    _a_27=2
    _a_28=(_a_23 * self.__p._getDim_I(0))
    _a_29=(_a_8 * self.__p._getDim_I(0))
    _a_30=(((self.__p._getDim_I(0) * _a_10) + (4 * _a_29)) if ((_a_10 > 0) ) else (3 * _a_29))
    _a_31=False
    _a_0._alloc_1expr_IIIZI(_a_27,_a_28,_a_29,_a_31,_a_30)
    _a_32=(_a_0.i64)
    _a_33=(_a_0.f64)
    _a_34=(_a_0.i32)
    _a_35=(_a_0.ptr_base)
    _a_36=(_a_0.nidxs_base)
    _a_37=(_a_0.cof_base)
    _a_38=(_a_0.code_base)
    _a_39=(_a_0.codeptr_base)
    _a_40=(_a_0.cconst_base)
    _a_41=(_a_0.hassp)
    _a_42=(_a_0.shape_base)
    _a_34[_a_42] = _a_20
    _a_34[(_a_42 + 1)] = _a_23
    _a_34[_a_35] = 0
    _a_34[_a_39] = 0
    _a_43=0
    _a_44=0
    _a_45=0
    for _a_46 in range(0,self.__p._getDim_I(0)):
     for _a_47 in range(0,self.__e._getDim_I(1)):
      for _a_48 in range(0,self.__p._getDim_I(1)):
       _a_45,_a_43 = fragments._c_closure_373(_a_13,_a_12,_a_45,_a_14,_a_18,_a_23,_a_46,_a_47,_a_48,_a_10,_a_17,_a_43,_a_21,_a_25,_a_11,_a_40,_a_38,_a_39,_a_37,_a_33,_a_34,_a_32,_a_36,_a_5,_a_3,_a_4,_a_26)
       _a_45 = numpy.int32(_a_45) # postprocess
       _a_43 = numpy.int32(_a_43) # postprocess
      _a_34[((_a_35 + _a_44) + 1)] = _a_43
      _a_44 += 1
    if (_a_45!=_a_30):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect a-code length")
    if (_a_43!=_a_29):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_a_44!=_a_28):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    for _a_49 in range(0,_a_28):
     if (_a_34[(_a_35 + _a_49)] > _a_34[((_a_35 + _a_49) + 1)]):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr indexes")
   elif (not _a_9):
    _a_50=_a_7
    _a_51=_a_24
    _a_52=_a_2._alloci64_I(_a_51)
    _a_53=(_a_2.i64)
    self.__p._getSp__3JI(_a_53,_a_52)
    _a_54=0
    _a_55=0
    _a_56=0
    _a_56,_a_54,_a_55 = fragments._c_closure_374(_a_14,_a_23,_a_10,_a_21,_a_24,_a_11,_a_56,_a_54,_a_55,_a_3,_a_53,_a_52)
    _a_56 = numpy.int32(_a_56) # postprocess
    _a_54 = numpy.int32(_a_54) # postprocess
    _a_55 = numpy.int32(_a_55) # postprocess
    _a_57=(_a_54 < (_a_20 * _a_23))
    _a_58=2
    _a_0._alloc_1expr_IIIZI(_a_58,_a_54,_a_55,_a_57,_a_56)
    _a_59=(_a_0.ptr_base)
    _a_60=(_a_0.nidxs_base)
    _a_61=((_a_0.sp_base) if (_a_57 ) else _a_0._alloci64_I(_a_54))
    _a_62=(_a_0.cof_base)
    _a_63=(_a_0.hassp)
    _a_64=(_a_0.shape_base)
    _a_65=(_a_0.codeptr_base)
    _a_66=(_a_0.code_base)
    _a_67=(_a_0.cconst_base)
    _a_68=(_a_0.i64)
    _a_69=(_a_0.f64)
    _a_70=(_a_0.i32)
    _a_70[_a_64] = _a_20
    _a_70[(_a_64 + 1)] = _a_23
    _a_71=0
    _a_72=0
    _a_73=0
    if (_a_56 > 0):
     _a_70[_a_65] = 0
    _a_70[_a_59] = 0
    fragments._c_closure_375(_a_62,_a_69,_a_55) 
    _a_74=0
    _a_73,_a_72,_a_74,_a_71 = fragments._c_closure_376(_a_13,_a_12,_a_73,_a_14,_a_18,_a_23,_a_72,_a_74,_a_10,_a_17,_a_71,_a_21,_a_25,_a_24,_a_11,_a_67,_a_66,_a_65,_a_69,_a_70,_a_68,_a_60,_a_59,_a_61,_a_5,_a_3,_a_4,_a_26,_a_53,_a_52)
    _a_73 = numpy.int32(_a_73) # postprocess
    _a_72 = numpy.int32(_a_72) # postprocess
    _a_74 = numpy.int32(_a_74) # postprocess
    _a_71 = numpy.int32(_a_71) # postprocess
    if (_a_73!=_a_56):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect code list")
    if (_a_71!=_a_55):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_a_72!=_a_54):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    if (_a_70[(_a_59 + _a_54)]!=_a_55):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr")
    if (not _a_63):
     _a_0._popi64_I(_a_54)
    _a_2._clear_()
   else:
    _a_75=_a_7
    _a_76=_a_2._alloci32_I(_a_75)
    _a_77=self.__p._getNumNonzero_()
    _a_78=_a_2._alloci64_I(_a_77)
    _a_79=_a_2._alloci32_I((_a_3[(_a_15 + 1)] + 1))
    _a_80=(_a_2.i32)
    _a_81=(_a_2.i64)
    self.__p._getSp__3JI(_a_81,_a_78)
    fragments._c_closure_377(_a_7,_a_15,_a_16,_a_3,_a_4,_a_80,_a_76,_a_79) 
    _a_82=0
    _a_83=0
    _a_84=0
    _a_85=_a_3[(_a_15 + 1)]
    _a_86=_a_3[_a_15]
    _a_87=self.__p._getDim_I(1)
    _a_88=self.__p._getDim_I(0)
    _a_84,_a_82,_a_83 = fragments._c_closure_378(_a_14,_a_85,_a_10,_a_7,_a_87,_a_77,_a_11,_a_84,_a_82,_a_83,_a_16,_a_3,_a_4,_a_80,_a_81,_a_76,_a_78)
    _a_84 = numpy.int32(_a_84) # postprocess
    _a_82 = numpy.int32(_a_82) # postprocess
    _a_83 = numpy.int32(_a_83) # postprocess
    _a_89=2
    _a_90=(_a_82 < (_a_88 * _a_85))
    _a_0._alloc_1expr_IIIZI(_a_89,_a_82,_a_83,_a_90,_a_84)
    _a_91=(_a_0.ptr_base)
    _a_92=(_a_0.nidxs_base)
    _a_93=((_a_0.sp_base) if (_a_90 ) else _a_0._alloci64_I(_a_82))
    _a_94=(_a_0.cof_base)
    _a_95=(_a_0.shape_base)
    _a_96=(_a_0.codeptr_base)
    _a_97=(_a_0.code_base)
    _a_98=(_a_0.cconst_base)
    _a_99=(_a_0.i64)
    _a_100=(_a_0.f64)
    _a_101=(_a_0.i32)
    fragments._c_closure_379(_a_101,_a_82,_a_91) 
    _a_101[_a_91] = 0
    if (_a_84 > 0):
     _a_101[_a_96] = 0
    _a_101[_a_95] = _a_88
    _a_101[(_a_95 + 1)] = _a_85
    _a_102=0
    _a_103=0
    _a_104=0
    fragments._c_closure_380(_a_94,_a_100,_a_83) 
    _a_105=0
    _a_104,_a_103,_a_102,_a_105 = fragments._c_closure_381(_a_13,_a_12,_a_104,_a_14,_a_18,_a_85,_a_103,_a_10,_a_7,_a_17,_a_102,_a_87,_a_25,_a_77,_a_105,_a_11,_a_98,_a_97,_a_96,_a_100,_a_101,_a_99,_a_92,_a_91,_a_93,_a_16,_a_5,_a_3,_a_4,_a_80,_a_81,_a_76,_a_78)
    _a_104 = numpy.int32(_a_104) # postprocess
    _a_103 = numpy.int32(_a_103) # postprocess
    _a_102 = numpy.int32(_a_102) # postprocess
    _a_105 = numpy.int32(_a_105) # postprocess
    if (_a_104!=_a_84):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect a-code length")
    if (_a_102!=_a_83):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_a_103!=_a_82):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    if (_a_101[(_a_91 + _a_103)]!=_a_83):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr")
    if (not _a_90):
     _a_0._popi64_I(_a_82)
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamLeft(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamLeft
mosek_fusion_ExprMulParamLeft=__mk_mosek_fusion_ExprMulParamLeft()
del __mk_mosek_fusion_ExprMulParamLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprOptimizeCode():
 class ExprOptimizeCode(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprOptimizeCode__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprOptimizeCode.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprOptimizeCode.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprOptimizeCode._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprOptimizeCode._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprOptimizeCode.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprOptimizeCode.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprOptimizeCode._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprOptimizeCode._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprOptimizeCode.toString()')
  def __repr__(self): return 'mosek.fusion.ExprOptimizeCode'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprOptimizeCode.__new__(ExprOptimizeCode)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def __compress_1code_alt_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8,_t__a_9,_t__a_10,_t__a_11,_t__a_12):
   _a_0=_t__a_0
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int32))
   _a_5=numpy.int32(_t__a_5)
   _a_6=numpy.array(_t__a_6,dtype=numpy.dtype(numpy.float64))
   _a_7=numpy.int32(_t__a_7)
   _a_8=numpy.array(_t__a_8,dtype=numpy.dtype(numpy.float64))
   _a_9=numpy.int32(_t__a_9)
   _a_10=numpy.int32(_t__a_10)
   _a_11=numpy.int32(_t__a_11)
   _a_12=numpy.int32(_t__a_12)
   _1_res = mosek_fusion_ExprOptimizeCode.__compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9,_a_10,_a_11,_a_12)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_6[:] = _a_6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_8[:] = _a_8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9,_a_10,_a_11,_a_12):
   _a_13=_a_4[(_a_5 + _a_1)]
   _a_14=_a_0._alloci32_I((_a_13 + 2))
   _a_15=0
   _a_16=_a_0._alloci32_I((_a_13 + 2))
   _a_17=_a_0._alloci32_I((_a_13 + 3))
   _a_18=_a_0._allocf64_I((_a_13 + 2))
   _a_19=_a_0._alloci32_I((_a_13 + 2))
   _a_20=0
   _a_21=(- 1)
   _a_22=(_a_0.i32)
   _a_23=(_a_0.f64)
   _a_24=_a_22
   _a_25=_a_23
   _a_26=_a_22
   _a_27=(_a_0.pi32)
   _a_28=(_a_0.pi64)
   _a_29=(_a_0.pf64)
   _a_26[_a_12] = 0
   _a_30=0
   _a_30,_a_21,_a_15,_a_20 = fragments._c_closure_382(_a_16,_a_17,_a_2,_a_3,_a_8,_a_9,_a_30,_a_21,_a_6,_a_7,_a_1,_a_4,_a_5,_a_14,_a_15,_a_24,_a_10,_a_25,_a_11,_a_26,_a_12,_a_18,_a_19,_a_20,_a_23,_a_22)
   _a_30 = numpy.int32(_a_30) # postprocess
   _a_21 = numpy.int32(_a_21) # postprocess
   _a_15 = numpy.int32(_a_15) # postprocess
   _a_20 = numpy.int32(_a_20) # postprocess
   (_a_0.pi32) = _a_27
   (_a_0.pi64) = _a_28
   (_a_0.pf64) = _a_29
   if (_a_21 >= 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid parameterization code list")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._peek_1expr_()
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.ncodeatom)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   if (_a_8==0):
    _a_0._alloc_1expr_IIIZI(_a_3,_a_5,_a_6,_a_7,0)
    _a_19=(_a_0.ptr_base)
    _a_20=(_a_0.sp_base)
    _a_21=(_a_0.nidxs_base)
    _a_22=(_a_0.cof_base)
    _a_23=(_a_0.shape_base)
    _a_24=(_a_0.i32)
    _a_25=(_a_0.i64)
    _a_26=(_a_0.f64)
    fragments._c_closure_383(_a_5,_a_9,_a_24,_a_19,_a_16) 
    fragments._c_closure_384(_a_3,_a_24,_a_23,_a_4,_a_16) 
    fragments._c_closure_385(_a_11,_a_6,_a_25,_a_21,_a_17) 
    fragments._c_closure_386(_a_12,_a_6,_a_22,_a_26,_a_18) 
    fragments._c_closure_387(_a_7,_a_5,_a_25,_a_20,_a_10,_a_17) 
   else:
    _a_27=_a_2._alloci32_I((_a_8 + (_a_6 * 2)))
    _a_28=_a_2._alloci32_I((_a_6 + 1))
    _a_29=_a_2._allocf64_I((_a_8 + (_a_6 * 2)))
    mosek.fusion.ExprOptimizeCode.__compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_a_2,_a_6,_a_16,_a_13,_a_16,_a_14,_a_18,_a_12,_a_18,_a_15,_a_27,_a_29,_a_28)
    _a_30=(_a_2.i32)
    _a_31=(_a_2.f64)
    _a_32=0
    _a_33=0
    _a_34=0
    _a_32,_a_34,_a_33 = fragments._c_closure_388(_a_12,_a_5,_a_9,_a_32,_a_34,_a_33,_a_18,_a_16,_a_27,_a_28,_a_30)
    _a_32 = numpy.int32(_a_32) # postprocess
    _a_34 = numpy.int32(_a_34) # postprocess
    _a_33 = numpy.int32(_a_33) # postprocess
    _a_35=False
    _a_35 = fragments._c_closure_389(_a_3,_a_35,_a_34,_a_4,_a_16)
    _a_0._alloc_1expr_IIIZI(_a_3,_a_34,_a_33,_a_35,_a_32)
    _a_36=(_a_0.ptr_base)
    _a_37=(_a_0.sp_base)
    _a_38=(_a_0.shape_base)
    _a_39=(_a_0.nidxs_base)
    _a_40=(_a_0.cof_base)
    _a_41=(_a_0.code_base)
    _a_42=(_a_0.codeptr_base)
    _a_43=(_a_0.cconst_base)
    _a_44=(_a_0.i32)
    _a_45=(_a_0.i64)
    _a_46=(_a_0.f64)
    fragments._c_closure_390(_a_3,_a_44,_a_38,_a_4,_a_16) 
    if (_a_8==0):
     fragments._c_closure_391(_a_12,_a_7,_a_5,_a_11,_a_6,_a_9,_a_40,_a_46,_a_44,_a_45,_a_39,_a_36,_a_37,_a_10,_a_18,_a_17) 
    else:
     _a_47=0
     _a_48=0
     _a_49=0
     _a_44[_a_36] = 0
     if (_a_32 > 0):
      _a_44[_a_42] = 0
     _a_47,_a_48,_a_49 = fragments._c_closure_392(_a_47,_a_12,_a_48,_a_7,_a_5,_a_11,_a_49,_a_9,_a_43,_a_41,_a_42,_a_40,_a_46,_a_35,_a_44,_a_45,_a_39,_a_36,_a_37,_a_10,_a_18,_a_16,_a_17,_a_29,_a_27,_a_28,_a_31,_a_30)
     _a_47 = numpy.int32(_a_47) # postprocess
     _a_48 = numpy.int32(_a_48) # postprocess
     _a_49 = numpy.int32(_a_49) # postprocess
     if (_a_48!=_a_34):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result nelem")
     if (_a_49!=_a_33):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result nnz")
     if (_a_47!=_a_32):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result num code atoms")
     if (_a_32 > 0):
      if (_a_44[(_a_42 + _a_33)]!=_a_32):
       raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprOptimizeCode(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprOptimizeCode
mosek_fusion_ExprOptimizeCode=__mk_mosek_fusion_ExprOptimizeCode()
del __mk_mosek_fusion_ExprOptimizeCode
#BEFORE CLASS
def __mk_mosek_fusion_ExprCompress():
 class ExprCompress(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCompress__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCompress.ctor(mosek.fusion.Expression)')
  @staticmethod
  def arg_sort(*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCompress.arg_sort(mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    nelem : int32
    nidxs : int32
    nnz : int32
    perm : int32
    ptr : int32
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprCompress._match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
      return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    elif mosek_fusion_ExprCompress._match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
      return mosek_fusion_ExprCompress._arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    else:
      raise ValueError('Invalid argument list arg_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.arg_sort(mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32)')
  @staticmethod
  def merge_sort(*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCompress.merge_sort(int32,int32,int32,int32,int32,int32,array(int32,ndim=1),array(int64,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    nelem : int32
    nidxs_base : int32
    nnz : int32
    origperm1 : int32
    origperm2 : int32
    ptr_base : int32
    wi32 : array(int32,ndim=1)
    wi64 : array(int64,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_ExprCompress._match_merge_1sort_IIIIII_3I_3J(*args):
      return mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(*args)
    elif mosek_fusion_ExprCompress._match_alt_merge_1sort_IIIIII_3I_3J(*args):
      return mosek_fusion_ExprCompress._merge_1sort_alt_IIIIII_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list merge_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.merge_sort(int32,int32,int32,int32,int32,int32,array(int32,ndim=1),array(int64,ndim=1))')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCompress.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprCompress._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCompress._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCompress.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprCompress._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprCompress._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCompress'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCompress.__new__(ExprCompress)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_I__(_a_2) and __arg_match_I__(_a_3) and __arg_match_I__(_a_4) and __arg_match_I__(_a_5) and __arg_match_I__(_a_6))
  @staticmethod
  def _match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_I__(_a_3) and __arg_alt_match_I__(_a_4) and __arg_alt_match_I__(_a_5) and __arg_alt_match_I__(_a_6))
  @staticmethod
  def _arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6):
    return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_a_0,_a_1,numpy.int32(__a_2),numpy.int32(__a_3),numpy.int32(__a_4),numpy.int32(__a_5),numpy.int32(__a_6))
  @staticmethod
  def _arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6):
   _a_7=0
   _a_8=(_a_0.i32)
   _a_7 = fragments._c_closure_393(_a_7,_a_3,_a_5,_a_8)
   _a_7 = numpy.int32(_a_7) # postprocess
   _a_9=(_a_1._alloci32_I((_a_7 * 2)) if ((_a_7 > 2) ) else 99999)
   _a_10=(_a_1.i32)
   _a_8 = (_a_0.i32)
   _a_11=(_a_0.i64)
   fragments._c_closure_394(_a_3,_a_6,_a_2,_a_5,_a_8,_a_11,_a_9,_a_10) 
  @staticmethod
  def _match_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_I__(_a_3) and __arg_match_I__(_a_4) and __arg_match_I__(_a_5) and __arg_match__3I__(_a_6) and __arg_match__3J__(_a_7))
  @staticmethod
  def _match_alt_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_I__(_a_3) and __arg_alt_match_I__(_a_4) and __arg_alt_match_I__(_a_5) and __arg_alt_match__3I__(_a_6) and __arg_alt_match__3J__(_a_7))
  @staticmethod
  def _merge_1sort_alt_IIIIII_3I_3J(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.int32(_t__a_3)
   _a_4=numpy.int32(_t__a_4)
   _a_5=numpy.int32(_t__a_5)
   _a_6=numpy.array(_t__a_6,dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.array(_t__a_7,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7)
   try:
     _t__a_6[:] = _a_6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_7[:] = _a_7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _merge_1sort_IIIIII_3I_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7):
   fragments._c_closure_395(_a_2,_a_5,_a_3,_a_0,_a_1,_a_4,_a_6,_a_7) 
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.ncodeatom)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=True
   _a_20=(_a_2.i32)
   _a_21=(_a_2.i64)
   _a_22=(_a_2.f64)
   _a_19 = fragments._c_closure_396(_a_19,_a_5,_a_11,_a_9,_a_16,_a_17)
   _a_19 = fragments._c_closure_397(_a_15,_a_13,_a_14,_a_12,_a_19,_a_8,_a_6,_a_18,_a_16)
   if _a_19:
    _a_0._alloc_1expr_IIIZI(_a_3,_a_5,_a_6,_a_7,_a_8)
    _a_23=(_a_0.ptr_base)
    _a_24=(_a_0.nidxs_base)
    _a_25=(_a_0.sp_base)
    _a_26=(_a_0.cof_base)
    _a_27=(_a_0.shape_base)
    _a_28=(_a_0.code_base)
    _a_29=(_a_0.codeptr_base)
    _a_30=(_a_0.cconst_base)
    _a_31=(_a_0.i32)
    _a_32=(_a_0.i64)
    _a_33=(_a_0.f64)
    fragments._c_closure_398(_a_15,_a_13,_a_14,_a_12,_a_7,_a_8,_a_3,_a_5,_a_11,_a_6,_a_9,_a_30,_a_28,_a_29,_a_26,_a_33,_a_31,_a_32,_a_24,_a_23,_a_27,_a_25,_a_4,_a_10,_a_18,_a_16,_a_17) 
    if (_a_8 > 0):
     if (_a_31[(_a_29 + _a_6)]!=_a_8):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
   else:
    _a_34=_a_2._alloci32_I(_a_6)
    mosek.fusion.ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_a_1,_a_2,_a_34,_a_5,_a_6,_a_9,_a_11)
    _a_35=(_a_2.i32)
    _a_36=0
    _a_37=_a_8
    _a_38=(_a_0.i32)
    _a_37,_a_36 = fragments._c_closure_399(_a_12,_a_8,_a_5,_a_11,_a_34,_a_9,_a_37,_a_36,_a_18,_a_16,_a_17,_a_35)
    _a_37 = numpy.int32(_a_37) # postprocess
    _a_36 = numpy.int32(_a_36) # postprocess
    _a_0._alloc_1expr_IIIZI(_a_3,_a_5,_a_36,_a_7,_a_37)
    _a_39=(_a_0.nidxs_base)
    _a_40=(_a_0.shape_base)
    _a_41=(_a_0.sp_base)
    _a_42=(_a_0.cof_base)
    _a_43=(_a_0.ptr_base)
    _a_44=(_a_0.code_base)
    _a_45=(_a_0.codeptr_base)
    _a_46=(_a_0.cconst_base)
    _a_47=(_a_0.i32)
    _a_48=(_a_0.i64)
    _a_49=(_a_0.f64)
    fragments._c_closure_400(_a_3,_a_47,_a_40,_a_4,_a_16) 
    fragments._c_closure_401(_a_7,_a_5,_a_48,_a_41,_a_10,_a_17) 
    _a_50=0
    _a_51=0
    _a_51,_a_50 = fragments._c_closure_402(_a_15,_a_13,_a_51,_a_14,_a_12,_a_8,_a_5,_a_11,_a_50,_a_34,_a_9,_a_46,_a_44,_a_45,_a_42,_a_49,_a_47,_a_48,_a_37,_a_39,_a_43,_a_18,_a_16,_a_17,_a_35)
    _a_51 = numpy.int32(_a_51) # postprocess
    _a_50 = numpy.int32(_a_50) # postprocess
    if (_a_37!=_a_51):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ncodeatom")
    if (_a_50!=_a_36):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
    if (_a_36!=_a_47[(_a_43 + _a_5)]):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
    if (_a_37 > 0):
     if (_a_47[(_a_45 + _a_36)]!=_a_37):
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCompress(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCompress
mosek_fusion_ExprCompress=__mk_mosek_fusion_ExprCompress()
del __mk_mosek_fusion_ExprCompress
#BEFORE CLASS
def __mk_mosek_fusion_ExprConst():
 class ExprConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprConst__sparsity','_ExprConst__bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I_3J_3D(*args):
      self._ctor_init__3I_3J_3D(*args)
    elif self.__match_alt_ctor__3I_3J_3D(*args):
      self._ctor_alt_init__3I_3J_3D(*args)
    elif self.__match_ctor__3I_3JD(*args):
      self._ctor_init__3I_3JD(*args)
    elif self.__match_alt_ctor__3I_3JD(*args):
      self._ctor_alt_init__3I_3JD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),double)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprConst.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprConst._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprConst._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprConst'
  @staticmethod
  def _ctor__3I_3J_3D(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3J_3D(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3D__(bfix))
  def _ctor_alt_init__3I_3J_3D(self,shape,sparsity,bfix):
    self._ctor_init__3I_3J_3D(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,shape,sparsity,bfix):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,None,shape)
   (self.__bfix) = mosek.fusion.Utils.Tools._arraycopy__3D(bfix)
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,bfix,sparsity)
  @staticmethod
  def _ctor__3I_3JD(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3JD(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match_D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match_D__(bfix))
  def _ctor_alt_init__3I_3JD(self,shape,sparsity,bfix):
    self._ctor_init__3I_3JD(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.float64(bfix))
  def _ctor_init__3I_3JD(self,shape,sparsity,bfix):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,None,shape)
   _a_0=(mosek.fusion.Set._size__3I(shape) if ((sparsity is None) ) else int((sparsity).shape[0]))
   (self.__bfix) = numpy.array([bfix for _a_1 in range(0,_a_0)], dtype=numpy.dtype(numpy.float64))
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,(self.__bfix),sparsity)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=self._getShape_()
   _a_4=int((_a_3).shape[0])
   _a_5=0
   _a_5 = fragments._c_closure_403(self.__bfix,_a_5)
   _a_5 = numpy.int32(_a_5) # postprocess
   _a_6=int((self.__bfix).shape[0])
   _a_7=((self.__sparsity is not None) and (int((self.__sparsity).shape[0]) < mosek.fusion.Set._size__3I(_a_3)))
   _a_0._alloc_1expr_IIIZI(_a_4,_a_6,_a_5,_a_7,0)
   _a_8=(_a_0.shape_base)
   _a_9=(_a_0.ptr_base)
   _a_10=(_a_0.sp_base)
   _a_11=(_a_0.nidxs_base)
   _a_12=(_a_0.cof_base)
   _a_13=(_a_0.i32)
   _a_14=(_a_0.i64)
   _a_15=(_a_0.f64)
   fragments._c_closure_404(_a_4,_a_13,_a_8,_a_3) 
   _a_16=0
   _a_13[_a_9] = 0
   fragments._c_closure_405(_a_7,_a_6,_a_14,_a_10,self.__sparsity) 
   _a_16 = fragments._c_closure_406(self.__bfix,_a_6,_a_16,_a_12,_a_15,_a_13,_a_14,_a_11,_a_9)
   _a_16 = numpy.int32(_a_16) # postprocess
  @staticmethod
  def __validate_alt__3I_3D_3J(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_ExprConst.__validate__3I_3D_3J(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __validate__3I_3D_3J(_a_0,_a_1,_a_2):
   _a_3=mosek.fusion.Set._size__3I(_a_0)
   if (_a_2 is not None):
    if (int((_a_2).shape[0])!=int((_a_1).shape[0])):
     raise mosek_fusion_LengthError._ctor_S("Mismatching data lengths")
    _a_4=False
    _a_4 = fragments._c_closure_407(_a_4,_a_2,_a_3)
    if _a_4:
     raise mosek_fusion_IndexError._ctor_S("Invalid sparsity index")
   else:
    if (int((_a_1).shape[0])!=_a_3):
     raise mosek_fusion_LengthError._ctor_S("Mismatching data length")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprConst()")
 return ExprConst
mosek_fusion_ExprConst=__mk_mosek_fusion_ExprConst()
del __mk_mosek_fusion_ExprConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprPick():
 class ExprPick(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPick__idxs','_ExprPick__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int32,ndim=2))\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int64,ndim=1))')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprPick.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprPick._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPick._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprPick.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprPick._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprPick._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.toString()')
  def __repr__(self): return 'mosek.fusion.ExprPick'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3_5I__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3_5I__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   _a_0=expr._getShape_()
   _a_1=int((_a_0).shape[0])
   (self.__expr) = expr
   (self.__idxs) = numpy.zeros((int((idxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _a_2=(self.__idxs)
   if (int((idxs).shape[1])!=_a_1):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and index dimensions")
   _a_3=False
   _a_3 = fragments._c_closure_408(idxs,_a_1,_a_0,_a_3)
   if _a_3:
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   fragments._c_closure_409(idxs,_a_1,_a_0,_a_2) 
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3J__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3J__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr
   _a_0=expr._getShape_()
   _a_1=mosek.fusion.Set._size__3I(_a_0)
   _a_2=False
   _a_2 = fragments._c_closure_410(idxs,_a_1,_a_2)
   if _a_2:
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   (self.__idxs) = mosek.fusion.Utils.Tools._arraycopy__3J(idxs)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.hassp)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=(self.__idxs)
   if (not _a_8):
    _a_20=int((_a_19).shape[0])
    _a_21=1
    _a_22=0
    _a_23=0
    _a_23,_a_22 = fragments._c_closure_411(_a_14,_a_19,_a_7,_a_9,_a_23,_a_22,_a_16)
    _a_23 = numpy.int32(_a_23) # postprocess
    _a_22 = numpy.int32(_a_22) # postprocess
    _a_0._alloc_1expr_IIIZI(_a_21,_a_20,_a_22,False,_a_23)
    _a_24=(_a_0.cof_base)
    _a_25=(_a_0.nidxs_base)
    _a_26=(_a_0.ptr_base)
    _a_27=(_a_0.shape_base)
    _a_28=(_a_0.code_base)
    _a_29=(_a_0.codeptr_base)
    _a_30=(_a_0.cconst_base)
    pass
    _a_31=(_a_0.i32)
    _a_32=(_a_0.i64)
    _a_33=(_a_0.f64)
    _a_31[_a_27] = int((_a_19).shape[0])
    _a_34=0
    _a_35=0
    _a_31[_a_26] = 0
    if (_a_23 > 0):
     _a_31[_a_29] = 0
    _a_34,_a_35 = fragments._c_closure_412(_a_15,_a_13,_a_34,_a_14,_a_12,_a_19,_a_35,_a_11,_a_9,_a_30,_a_28,_a_29,_a_24,_a_33,_a_31,_a_32,_a_23,_a_25,_a_26,_a_18,_a_16,_a_17)
    _a_34 = numpy.int32(_a_34) # postprocess
    _a_35 = numpy.int32(_a_35) # postprocess
   else:
    _a_36=1
    _a_37=int((_a_19).shape[0])
    _a_38=0
    _a_39=0
    _a_40=(self.__idxs)
    _a_41=_a_2._alloci32_I(int((_a_40).shape[0]))
    _a_42=(_a_2.i32)
    _a_39,_a_38 = fragments._c_closure_413(_a_14,_a_40,_a_7,_a_5,_a_9,_a_39,_a_38,_a_10,_a_41,_a_16,_a_17,_a_42)
    _a_39 = numpy.int32(_a_39) # postprocess
    _a_38 = numpy.int32(_a_38) # postprocess
    _a_0._alloc_1expr_IIIZI(_a_36,_a_37,_a_38,False,_a_39)
    _a_43=(_a_0.ptr_base)
    _a_44=(_a_0.nidxs_base)
    _a_45=(_a_0.cof_base)
    _a_46=(_a_0.shape_base)
    _a_47=(_a_0.code_base)
    _a_48=(_a_0.codeptr_base)
    _a_49=(_a_0.cconst_base)
    _a_50=(_a_0.i32)
    _a_51=(_a_0.i64)
    _a_52=(_a_0.f64)
    _a_50[_a_46] = int((_a_40).shape[0])
    _a_50[_a_43] = 0
    if (_a_39 > 0):
     _a_50[_a_48] = 0
    _a_53=0
    _a_54=0
    _a_53,_a_54 = fragments._c_closure_414(_a_15,_a_13,_a_53,_a_14,_a_12,_a_40,_a_54,_a_11,_a_9,_a_49,_a_47,_a_48,_a_45,_a_52,_a_50,_a_51,_a_39,_a_44,_a_43,_a_41,_a_18,_a_16,_a_17,_a_42)
    _a_53 = numpy.int32(_a_53) # postprocess
    _a_54 = numpy.int32(_a_54) # postprocess
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprPick()")
 return ExprPick
mosek_fusion_ExprPick=__mk_mosek_fusion_ExprPick()
del __mk_mosek_fusion_ExprPick
#BEFORE CLASS
def __mk_mosek_fusion_ExprSlice():
 class ExprSlice(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSlice__last','_ExprSlice__first','_ExprSlice__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSlice.ctor(mosek.fusion.Expression,array(int32,ndim=1),array(int32,ndim=1))')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSlice.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprSlice._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSlice._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSlice.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprSlice._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprSlice._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSlice'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last):
    o = ExprSlice.__new__(ExprSlice)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3I__(first) and __arg_match__3I__(last))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3I__(first) and __arg_alt_match__3I__(last))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,numpy.array(first,dtype=numpy.dtype(numpy.int32)),numpy.array(last,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprSlice.__makeShape__3I_3I_3I(expr._getShape_(),first,last))
   (self.__expr) = expr
   (self.__first) = first
   (self.__last) = last
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nelem)
   _a_5=(_a_1.nnz)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_19[(_a_3 - 1)] = 1
   fragments._c_closure_415(_a_3,_a_8,_a_19,_a_16) 
   _a_20=0
   _a_21=0
   _a_22=0
   _a_20,_a_21,_a_22 = fragments._c_closure_416(_a_14,self.__first,_a_7,self.__last,_a_6,_a_3,_a_4,_a_9,_a_20,_a_21,_a_22,_a_8,_a_10,_a_19,_a_16,_a_17)
   _a_20 = numpy.int32(_a_20) # postprocess
   _a_21 = numpy.int32(_a_21) # postprocess
   _a_22 = numpy.int32(_a_22) # postprocess
   _a_23=numpy.array([(self.__last[_a_24] - self.__first[_a_24]) for _a_24 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32))
   _a_25=(_a_21 < mosek.fusion.Set._size__3I(_a_23))
   _a_0._alloc_1expr_IIIZI(_a_3,_a_21,_a_22,_a_25,_a_20)
   _a_26=(_a_0.shape_base)
   _a_27=(_a_0.cof_base)
   _a_28=(_a_0.nidxs_base)
   _a_29=((_a_0.sp_base) if (_a_25 ) else _a_0._alloci64_I(_a_21))
   _a_30=(_a_0.ptr_base)
   _a_31=(_a_0.code_base)
   _a_32=(_a_0.codeptr_base)
   _a_33=(_a_0.cconst_base)
   _a_34=(_a_0.i32)
   _a_35=(_a_0.i64)
   _a_36=(_a_0.f64)
   fragments._c_closure_417(_a_3,_a_34,_a_23,_a_26) 
   _a_34[_a_30] = 0
   if (_a_20 > 0):
    _a_34[_a_32] = 0
   _a_37=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_37[(_a_3 - 1)] = 1
   fragments._c_closure_418(_a_3,_a_23,_a_37) 
   _a_38=0
   _a_39=0
   _a_40=0
   _a_38,_a_39,_a_40 = fragments._c_closure_419(_a_15,_a_13,_a_38,_a_14,_a_12,self.__first,_a_7,_a_39,_a_40,self.__last,_a_3,_a_4,_a_11,_a_9,_a_33,_a_31,_a_32,_a_27,_a_36,_a_34,_a_35,_a_20,_a_28,_a_30,_a_29,_a_37,_a_8,_a_10,_a_19,_a_18,_a_16,_a_17)
   _a_38 = numpy.int32(_a_38) # postprocess
   _a_39 = numpy.int32(_a_39) # postprocess
   _a_40 = numpy.int32(_a_40) # postprocess
   if (not _a_25):
    _a_0._popi64_I(_a_21)
  @staticmethod
  def __makeShape_alt__3I_3I_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprSlice.__makeShape__3I_3I_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __makeShape__3I_3I_3I(_a_0,_a_1,_a_2):
   if ((int((_a_0).shape[0])!=int((_a_1).shape[0])) or (int((_a_0).shape[0])!=int((_a_2).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Invalid or mismatching index lengths")
   for _a_3 in range(0,int((_a_0).shape[0])):
    if ((_a_1[_a_3] < 0) or ((_a_2[_a_3] < _a_1[_a_3]) or (_a_2[_a_3] > _a_0[_a_3]))):
     raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   return (numpy.array([(_a_2[_a_4] - _a_1[_a_4]) for _a_4 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()._a_S("ExprSlice([")._a_I(self.__first[0])._a_S(":")._a_I(self.__last[0])
   for _a_1 in range(1,int((self.__first).shape[0])):
    _a_0._a_S(",")._a_I(self.__first[_a_1])._a_S(":")._a_I(self.__last[_a_1])
   _a_0._a_S("],")._a_S(self.__expr._toString_())._a_S(")")
   return (_a_0._toString_())
 return ExprSlice
mosek_fusion_ExprSlice=__mk_mosek_fusion_ExprSlice()
del __mk_mosek_fusion_ExprSlice
#BEFORE CLASS
def __mk_mosek_fusion_ExprPermuteDims():
 class ExprPermuteDims(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPermuteDims__dperm','_ExprPermuteDims__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args):
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPermuteDims.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprPermuteDims.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprPermuteDims._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPermuteDims._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPermuteDims.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprPermuteDims'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(perm,expr):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(perm,expr)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
   mosek_fusion_ExprPermuteDims._ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,1)
   _a_0=expr._getShape_()
   if (int((perm).shape[0])!=int((_a_0).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation length")
   _a_1=numpy.array([0 for _a_2 in range(0,int((perm).shape[0]))], dtype=numpy.dtype(numpy.int32))
   for _a_3 in range(0,int((_a_1).shape[0])):
    if ((perm[_a_3] < 0) or (perm[_a_3] > int((_a_0).shape[0]))):
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation index")
    _a_1[perm[_a_3]] += 1
   for _a_4 in range(0,int((_a_1).shape[0])):
    if ((_a_1[_a_4] < 1) or (_a_1[_a_4] > 1)):
     raise mosek_fusion_LengthError._ctor_S("Dimension permutation contains duplicates")
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2I(perm,expr,validated):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2I(perm,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
    self._ctor_init__3ILmosek_4fusion_4Expression_2I(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr,numpy.int32(validated))
  def _ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprPermuteDims.__computeshape__3I_3I(perm,expr._getShape_()))
   (self.__expr) = expr
   self.__dperm = mosek.fusion.Utils.Tools._arraycopy__3I(perm)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nelem)
   _a_5=(_a_1.nnz)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_9[(_a_3 - 1)] = 1
   for _a_10 in range(1,_a_3):
    _a_9[((_a_3 - _a_10) - 1)] = (_a_9[(_a_3 - _a_10)] * (_a_1.i32)[((_a_8 + _a_3) - _a_10)])
   _a_11=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_11[(_a_3 - 1)] = 1
   for _a_12 in range(1,_a_3):
    _a_11[((_a_3 - _a_12) - 1)] = (_a_11[(_a_3 - _a_12)] * (_a_1.i32)[(_a_8 + self.__dperm[(_a_3 - _a_12)])])
   _a_13=(_a_1.ptr_base)
   _a_14=(_a_1.sp_base)
   _a_15=(_a_1.nidxs_base)
   _a_16=(_a_1.cof_base)
   _a_17=(_a_1.code_base)
   _a_18=(_a_1.codeptr_base)
   _a_19=(_a_1.cconst_base)
   _a_20=(_a_1.i32)
   _a_21=(_a_1.i64)
   _a_22=(_a_1.f64)
   _a_0._alloc_1expr_IIIZI(_a_3,_a_4,_a_5,_a_7,_a_6)
   _a_23=(_a_0.ptr_base)
   _a_24=(_a_0.shape_base)
   _a_25=(_a_0.nidxs_base)
   _a_26=(_a_0.sp_base)
   _a_27=(_a_0.cof_base)
   _a_28=(_a_0.code_base)
   _a_29=(_a_0.codeptr_base)
   _a_30=(_a_0.cconst_base)
   _a_31=(_a_0.i32)
   _a_32=(_a_0.i64)
   _a_33=(_a_0.f64)
   fragments._c_closure_420(self.__dperm,_a_3,_a_31,_a_24,_a_8,_a_20) 
   if _a_7:
    _a_34=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_421(self.__dperm,_a_14,_a_3,_a_4,_a_31,_a_24,_a_34,_a_9,_a_21) 
    _a_35=numpy.array([_a_36 for _a_36 in range(0,_a_4)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_35,_a_34,None,0,_a_4)
    _a_31[_a_23] = 0
    if (_a_6 > 0):
     _a_31[_a_29] = 0
    _a_37=0
    _a_38=0
    _a_39=0
    _a_37,_a_38,_a_39 = fragments._c_closure_422(_a_19,_a_17,_a_37,_a_18,_a_16,_a_15,_a_13,_a_38,_a_39,_a_6,_a_4,_a_35,_a_30,_a_28,_a_29,_a_27,_a_33,_a_31,_a_32,_a_25,_a_23,_a_26,_a_34,_a_22,_a_20,_a_21)
    _a_37 = numpy.int32(_a_37) # postprocess
    _a_38 = numpy.int32(_a_38) # postprocess
    _a_39 = numpy.int32(_a_39) # postprocess
   else:
    fragments._c_closure_423(_a_19,_a_17,_a_18,self.__dperm,_a_11,_a_16,_a_15,_a_13,_a_6,_a_3,_a_4,_a_30,_a_28,_a_29,_a_27,_a_33,_a_31,_a_32,_a_25,_a_23,_a_9,_a_22,_a_20,_a_21) 
  @staticmethod
  def __computeshape_alt__3I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprPermuteDims.__computeshape__3I_3I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __computeshape__3I_3I(_a_0,_a_1):
   return (numpy.array([_a_1[_a_0[_a_2]] for _a_2 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
 return ExprPermuteDims
mosek_fusion_ExprPermuteDims=__mk_mosek_fusion_ExprPermuteDims()
del __mk_mosek_fusion_ExprPermuteDims
#BEFORE CLASS
def __mk_mosek_fusion_ExprTranspose():
 class ExprTranspose(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprTranspose__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprTranspose.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprTranspose.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprTranspose._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprTranspose._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprTranspose.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprTranspose._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprTranspose._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.toString()')
  def __repr__(self): return 'mosek.fusion.ExprTranspose'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprTranspose.__new__(ExprTranspose)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprTranspose.__transposeShape__3I(expr._getShape_()))
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_4=self.__expr
   if   isinstance(_a_4,mosek_fusion_ExprTranspose):
    e=_a_4
    (e.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
   else:
    expr=_a_4
    expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
    _a_1._pop_1expr_()
    if ((_a_1.nd)!=2):
     raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
    else:
     _a_4=(_a_1.shape_base)
     _a_5=(_a_1.nelem)
     _a_6=(_a_1.nnz)
     _a_7=(_a_1.hassp)
     _a_8=(_a_1.ncodeatom)
     _a_9=(_a_1.ptr_base)
     _a_10=(_a_1.sp_base)
     _a_11=(_a_1.nidxs_base)
     _a_12=(_a_1.cof_base)
     _a_13=(_a_1.code_base)
     _a_14=(_a_1.codeptr_base)
     _a_15=(_a_1.cconst_base)
     _a_16=(_a_1.i32)[_a_4]
     _a_17=(_a_1.i32)[(_a_4 + 1)]
     _a_18=(_a_1.i32)
     _a_19=(_a_1.i64)
     _a_20=(_a_1.f64)
     _a_0._alloc_1expr_IIIZI(2,_a_5,_a_6,_a_7,_a_8)
     _a_21=(_a_0.ptr_base)
     _a_22=(_a_0.nidxs_base)
     _a_23=(_a_0.sp_base)
     _a_24=(_a_0.cof_base)
     _a_25=(_a_0.shape_base)
     _a_26=(_a_0.code_base)
     _a_27=(_a_0.codeptr_base)
     _a_28=(_a_0.cconst_base)
     _a_29=(_a_0.i32)
     _a_30=(_a_0.i64)
     _a_31=(_a_0.f64)
     _a_29[_a_25] = _a_17
     _a_29[(_a_25 + 1)] = _a_16
     _a_29[_a_21] = 0
     if (_a_8 > 0):
      _a_29[_a_27] = 0
     if _a_7:
      _a_32=_a_2._alloci32_I(_a_5)
      _a_33=_a_2._alloci32_I((_a_17 + 1))
      _a_34=(_a_2.i32)
      fragments._c_closure_424(_a_15,_a_13,_a_14,_a_16,_a_17,_a_12,_a_11,_a_9,_a_10,_a_8,_a_5,_a_32,_a_33,_a_28,_a_26,_a_27,_a_24,_a_31,_a_29,_a_30,_a_22,_a_21,_a_23,_a_20,_a_18,_a_19,_a_34) 
     else:
      fragments._c_closure_425(_a_15,_a_13,_a_14,_a_16,_a_17,_a_12,_a_11,_a_9,_a_8,_a_28,_a_26,_a_27,_a_24,_a_31,_a_29,_a_30,_a_22,_a_21,_a_20,_a_18,_a_19) 
     _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprTranspose(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
  @staticmethod
  def __transposeShape_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprTranspose.__transposeShape__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __transposeShape__3I(_a_0):
   if (int((_a_0).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    return (numpy.array([_a_0[1],_a_0[0]], dtype=numpy.dtype(numpy.int32)))
 return ExprTranspose
mosek_fusion_ExprTranspose=__mk_mosek_fusion_ExprTranspose()
del __mk_mosek_fusion_ExprTranspose
#BEFORE CLASS
def __mk_mosek_fusion_ExprRepeat():
 class ExprRepeat(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprRepeat__n','_ExprRepeat__dim','_ExprRepeat__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2II(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2II(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2II(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprRepeat.ctor(mosek.fusion.Expression,int32,int32)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprRepeat.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprRepeat._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprRepeat._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRepeat.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprRepeat.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprRepeat._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprRepeat._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRepeat.toString()')
  def __repr__(self): return 'mosek.fusion.ExprRepeat'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2II(expr,dim,n):
    o = ExprRepeat.__new__(ExprRepeat)
    o._ctor_init_Lmosek_4fusion_4Expression_2II(expr,dim,n)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    expr,dim,n, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(dim) and __arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    expr,dim,n, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(dim) and __arg_alt_match_I__(n))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2II(self,expr,dim,n):
    self._ctor_init_Lmosek_4fusion_4Expression_2II(expr,numpy.int32(dim),numpy.int32(n))
  def _ctor_init_Lmosek_4fusion_4Expression_2II(self,expr,dim,n):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprRepeat.__getshape_Lmosek_4fusion_4Expression_2II(expr,dim,n))
   (self.__expr) = expr
   (self.__dim) = dim
   (self.__n) = n
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.hassp)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=(_a_3 if ((self.__dim < _a_3) ) else (_a_3 + 1))
   _a_20=(_a_5 * self.__n)
   _a_21=(_a_6 * self.__n)
   _a_22=(_a_7 * self.__n)
   _a_0._alloc_1expr_IIIZI(_a_19,_a_20,_a_21,_a_8,_a_22)
   _a_23=(_a_0.i32)
   _a_24=(_a_0.i64)
   _a_25=(_a_0.f64)
   _a_26=(_a_0.shape_base)
   _a_27=(_a_0.ptr_base)
   _a_28=(_a_0.sp_base)
   _a_29=(_a_0.nidxs_base)
   _a_30=(_a_0.cof_base)
   _a_31=(_a_0.code_base)
   _a_32=(_a_0.codeptr_base)
   _a_33=(_a_0.cconst_base)
   _a_34=1
   _a_34 = fragments._c_closure_426(_a_34,self.__dim,_a_4,_a_16)
   _a_34 = numpy.int32(_a_34) # postprocess
   _a_35=(_a_16[(_a_4 + self.__dim)] if ((self.__dim < _a_3) ) else 1)
   _a_36=(self.__n * _a_35)
   _a_37=1
   _a_37 = fragments._c_closure_427(_a_37,self.__dim,_a_3,_a_4,_a_16)
   _a_37 = numpy.int32(_a_37) # postprocess
   fragments._c_closure_428(_a_15,_a_13,_a_14,_a_12,_a_34,_a_35,_a_37,self.__dim,_a_8,self.__n,_a_7,_a_3,_a_5,_a_11,_a_9,_a_33,_a_31,_a_32,_a_30,_a_36,_a_25,_a_23,_a_24,_a_22,_a_29,_a_27,_a_26,_a_28,_a_4,_a_10,_a_18,_a_16,_a_17) 
  @staticmethod
  def __getshape_alt_Lmosek_4fusion_4Expression_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_ExprRepeat.__getshape_Lmosek_4fusion_4Expression_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def __getshape_Lmosek_4fusion_4Expression_2II(_a_0,_a_1,_a_2):
   _a_3=_a_0._getShape_()
   _a_4=int((_a_3).shape[0])
   if (_a_1 < _a_4):
    _a_3[_a_1] *= _a_2
    return (_a_3)
   else:
    _a_5=(numpy.zeros(((_a_4 + 1),), dtype=numpy.dtype(numpy.int32)) if ((_a_1==_a_4) ) else _a_3)
    fragments._c_closure_429(_a_4,_a_5,_a_3) 
    _a_5[_a_1] = _a_2
    return (_a_5)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprRepeat(dim=")._a_I(self.__dim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprRepeat
mosek_fusion_ExprRepeat=__mk_mosek_fusion_ExprRepeat()
del __mk_mosek_fusion_ExprRepeat
#BEFORE CLASS
def __mk_mosek_fusion_ExprStack():
 class ExprStack(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprStack__dim','_ExprStack__exprs']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2I(*args):
      self._ctor_init__3Lmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprStack.ctor(array(mosek.fusion.Expression,ndim=1),int32)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprStack.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprStack._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprStack._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprStack.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprStack._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprStack._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.toString()')
  def __repr__(self): return 'mosek.fusion.ExprStack'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2I(exprs,dim):
    o = ExprStack.__new__(ExprStack)
    o._ctor_init__3Lmosek_4fusion_4Expression_2I(exprs,dim)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_match_I__(dim))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_alt_match_I__(dim))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
    self._ctor_init__3Lmosek_4fusion_4Expression_2I(numpy.array(exprs,dtype=numpy.dtype(object)),numpy.int32(dim))
  def _ctor_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom__3Lmosek_4fusion_4Expression_2(exprs),mosek.fusion.ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(exprs,dim))
   (self.__exprs) = numpy.array([exprs[_a_0] for _a_0 in range(0,int((exprs).shape[0]))], dtype=numpy.dtype(object))
   (self.__dim) = dim
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=int((self.__exprs).shape[0])
   if (_a_3==1):
    self.__exprs[0]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
   else:
    for _a_4 in range(0,_a_3):
     self.__exprs[((_a_3 - _a_4) - 1)]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
    _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_6=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_7=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_8=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_9=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_10=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_11=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_12=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_13=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_14=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_15=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_16=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_17=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    for _a_18 in range(0,_a_3):
     _a_1._pop_1expr_()
     _a_5[_a_18] = (_a_1.nd)
     _a_6[_a_18] = (_a_1.shape_base)
     _a_7[_a_18] = (_a_1.nelem)
     _a_8[_a_18] = (_a_1.nnz)
     _a_9[_a_18] = (_a_1.ncodeatom)
     _a_10[_a_18] = (1 if ((_a_1.hassp) ) else 0)
     _a_11[_a_18] = (_a_1.ptr_base)
     _a_13[_a_18] = (_a_1.sp_base)
     _a_12[_a_18] = (_a_1.nidxs_base)
     _a_14[_a_18] = (_a_1.cof_base)
     _a_15[_a_18] = (_a_1.code_base)
     _a_16[_a_18] = (_a_1.codeptr_base)
     _a_17[_a_18] = (_a_1.cconst_base)
    _a_19=(_a_1.i32)
    _a_20=(_a_1.i64)
    _a_21=(_a_1.f64)
    _a_22=_a_5[0]
    _a_23=_a_6[0]
    _a_24=(_a_10[0]==0)
    _a_25=False
    _a_24,_a_25 = fragments._c_closure_430(_a_24,self.__dim,_a_10,_a_25,_a_3,_a_22,_a_5,_a_23,_a_6,_a_19)
    if _a_25:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
    _a_26=0
    _a_26 = fragments._c_closure_431(self.__dim,_a_3,_a_22,_a_26,_a_6,_a_19)
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_27=(_a_22 if ((self.__dim < _a_22) ) else (_a_22 + 1))
    if (_a_27!=self._getND_()):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Mismatching dimensions")
    _a_28=0
    _a_29=0
    _a_30=0
    _a_31=False
    _a_31,_a_28,_a_29,_a_30 = fragments._c_closure_432(_a_3,_a_9,_a_7,_a_8,_a_31,_a_28,_a_29,_a_30)
    _a_28 = numpy.int32(_a_28) # postprocess
    _a_29 = numpy.int32(_a_29) # postprocess
    _a_30 = numpy.int32(_a_30) # postprocess
    _a_32=1
    _a_32 = fragments._c_closure_433(_a_32,self.__dim,_a_23,_a_19)
    _a_32 = numpy.int32(_a_32) # postprocess
    _a_33=(numpy.array([_a_19[(_a_6[_a_34] + self.__dim)] for _a_34 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32)) if ((self.__dim < _a_22) ) else numpy.array([1 for _a_35 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32)))
    _a_36=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_36[0] = 0
    fragments._c_closure_434(_a_33,_a_3,_a_36) 
    _a_37=0
    _a_37 = fragments._c_closure_435(_a_37,_a_33,_a_3)
    _a_37 = numpy.int32(_a_37) # postprocess
    _a_38=1
    _a_38 = fragments._c_closure_436(_a_38,self.__dim,_a_22,_a_23,_a_19)
    _a_38 = numpy.int32(_a_38) # postprocess
    if _a_24:
     _a_0._alloc_1expr_IIIZI(_a_27,_a_29,_a_30,False,_a_28)
     _a_39=(_a_0.ptr_base)
     _a_40=(_a_0.shape_base)
     _a_41=(_a_0.nidxs_base)
     _a_42=(_a_0.cof_base)
     _a_43=(_a_0.code_base)
     _a_44=(_a_0.codeptr_base)
     _a_45=(_a_0.cconst_base)
     _a_46=(_a_0.i32)
     _a_47=(_a_0.i64)
     _a_48=(_a_0.f64)
     _a_49=(_a_2._alloci32_I((_a_29 + 1)) if ((_a_28 > 0) ) else (- 9999))
     _a_50=(_a_2.i32)
     fragments._c_closure_437(_a_22,_a_46,_a_40,_a_23,_a_19) 
     _a_46[(_a_40 + self.__dim)] = _a_26
     fragments._c_closure_438(_a_17,_a_15,_a_16,_a_14,_a_32,_a_33,_a_38,_a_3,_a_9,_a_12,_a_31,_a_11,_a_45,_a_43,_a_44,_a_42,_a_48,_a_46,_a_47,_a_41,_a_39,_a_21,_a_19,_a_20) 
    else:
     _a_51=1
     _a_51 = fragments._c_closure_439(self.__dim,_a_51,_a_23,_a_19)
     _a_51 = numpy.int32(_a_51) # postprocess
     _a_51 *= _a_26
     _a_51 = fragments._c_closure_440(self.__dim,_a_22,_a_51,_a_23,_a_19)
     _a_51 = numpy.int32(_a_51) # postprocess
     _a_52=(_a_29 < _a_51)
     _a_0._alloc_1expr_IIIZI(_a_27,_a_29,_a_30,_a_52,_a_28)
     _a_53=(_a_0.ptr_base)
     _a_54=(_a_0.nidxs_base)
     _a_55=((_a_0.sp_base) if (_a_52 ) else _a_0._alloci64_I(_a_29))
     _a_56=(_a_0.cof_base)
     _a_57=(_a_0.code_base)
     _a_58=(_a_0.codeptr_base)
     _a_59=(_a_0.cconst_base)
     _a_60=(_a_0.shape_base)
     for _a_61 in range(0,_a_22):
      (_a_0.i32)[(_a_60 + _a_61)] = _a_19[(_a_23 + _a_61)]
     (_a_0.i32)[(_a_60 + self.__dim)] = _a_26
     _a_62=(_a_0.i32)
     _a_63=(_a_0.i64)
     _a_64=(_a_0.f64)
     if (self.__dim==0):
      fragments._c_closure_441(_a_17,_a_15,_a_16,_a_14,_a_10,_a_3,_a_9,_a_22,_a_7,_a_12,_a_11,_a_59,_a_57,_a_58,_a_56,_a_64,_a_62,_a_63,_a_28,_a_54,_a_53,_a_55,_a_6,_a_13,_a_21,_a_19,_a_20) 
     else:
      _a_65=0
      _a_65 = fragments._c_closure_442(_a_65,_a_62,_a_27,_a_60)
      _a_65 = numpy.int32(_a_65) # postprocess
      _a_66=_a_2._alloci64_I(_a_29)
      _a_67=_a_2._alloci32_I(_a_29)
      _a_68=_a_2._alloci32_I(_a_29)
      _a_69=_a_2._alloci32_I(_a_29)
      _a_70=_a_2._alloci32_I(_a_29)
      _a_71=_a_2._alloci32_I((_a_65 + 1))
      _a_72=(_a_2.i32)
      _a_73=(_a_2.i64)
      fragments._c_closure_443(_a_33,_a_38,_a_10,_a_3,_a_7,_a_36,_a_26,_a_13,_a_67,_a_68,_a_66,_a_20,_a_72,_a_73) 
      _a_69,_a_70 = fragments._c_closure_444(_a_69,_a_62,_a_27,_a_29,_a_60,_a_70,_a_66,_a_72,_a_73,_a_71)
      _a_69 = numpy.int32(_a_69) # postprocess
      _a_70 = numpy.int32(_a_70) # postprocess
      fragments._c_closure_445(_a_17,_a_15,_a_16,_a_14,_a_69,_a_9,_a_12,_a_31,_a_11,_a_59,_a_57,_a_58,_a_56,_a_64,_a_62,_a_63,_a_28,_a_29,_a_54,_a_53,_a_55,_a_67,_a_68,_a_66,_a_21,_a_19,_a_20,_a_72,_a_73) 
     if (not _a_52):
      _a_0._popi64_I(_a_29)
  @staticmethod
  def __getshape_alt__3Lmosek_4fusion_4Expression_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __getshape__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1):
   if (int((_a_0).shape[0])==0):
    raise mosek_fusion_LengthError._ctor_S("Cannot stack empty list")
   elif (int((_a_0).shape[0])==1):
    return (_a_0[0]._getShape_())
   else:
    _a_2=_monty.initJaggedArray([_a_0[_a_3]._getShape_() for _a_3 in range(0,int((_a_0).shape[0]))], 1)
    _a_4=_a_2[0]
    _a_5=int((_a_4).shape[0])
    for _a_6 in range(1,int((_a_2).shape[0])):
     if (_a_5!=int((_a_2[_a_6]).shape[0])):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
     for _a_7 in range(0,_a_1):
      if (_a_4[_a_7]!=_a_2[_a_6][_a_7]):
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
     for _a_8 in range((_a_1 + 1),_a_5):
      if (_a_4[_a_8]!=_a_2[_a_6][_a_8]):
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
    if (_a_1==_a_5):
     _a_9=numpy.zeros(((_a_5 + 1),), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_446(_a_5,_a_9,_a_4) 
     _a_9[_a_5] = int((_a_2).shape[0])
     return (_a_9)
    else:
     _a_10=_a_4
     fragments._c_closure_447(_a_1,_a_10,_a_2) 
     return (_a_10)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()._a_S("ExprStack(dim=")._a_I(self.__dim)._a_S(",[")._a_S(self.__exprs[0]._toString_())
   for _a_1 in range(1,int((self.__exprs).shape[0])):
    _a_0._a_S(",")._a_S(self.__exprs[_a_1]._toString_())
   _a_0._a_S("])")
   return (_a_0._toString_())
 return ExprStack
mosek_fusion_ExprStack=__mk_mosek_fusion_ExprStack()
del __mk_mosek_fusion_ExprStack
#BEFORE CLASS
def __mk_mosek_fusion_ExprInner():
 class ExprInner(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprInner__vcof','_ExprInner__vsub','_ExprInner__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int32,ndim=2),array(double,ndim=1))')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprInner.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprInner._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprInner._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprInner.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprInner._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprInner._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.toString()')
  def __repr__(self): return 'mosek.fusion.ExprInner'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J_3D(expr3,vsub3,vcof3):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr3,vsub3,vcof3)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr3,vsub3,vcof3, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr3) and __arg_match__3J__(vsub3) and __arg_match__3D__(vcof3))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr3,vsub3,vcof3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr3) and __arg_alt_match__3J__(vsub3) and __arg_alt_match__3D__(vcof3))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr3,vsub3,vcof3):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr3,numpy.array(vsub3,dtype=numpy.dtype(numpy.int64)),numpy.array(vcof3,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr3,vsub3,vcof3):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr3._getModel_(),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr3
   (self.__vsub) = vsub3
   (self.__vcof) = vcof3
   if (int((vsub3).shape[0])!=int((vcof3).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of vcof and vsub")
   _a_0=expr3._getShape_()
   _a_1=mosek.fusion.Set._size__3I(_a_0)
   _a_2=False
   _a_3=False
   _a_3,_a_2 = fragments._c_closure_448(_a_3,_a_2,_a_1,vsub3)
   if _a_2:
    raise mosek_fusion_IndexError._ctor_S("Unordered coefficcient subscripts")
   if _a_3:
    raise mosek_fusion_IndexError._ctor_S("Coefficient subscript out of bounds")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3D(expr2,vcof2):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr2,vcof2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr2,vcof2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr2) and __arg_match__3D__(vcof2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr2,vcof2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr2) and __arg_alt_match__3D__(vcof2))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(self,expr2,vcof2):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr2,numpy.array(vcof2,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3D(self,expr2,vcof2):
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr2,mosek.fusion.ExprInner.__range_I(int((vcof2).shape[0])),vcof2)
   _a_0=expr2._getShape_()
   if ((int((_a_0).shape[0])!=1) or (_a_0[0]!=int((vcof2).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(expr1,vsub1,vcof1):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr1,vsub1,vcof1)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr1,vsub1,vcof1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr1) and __arg_match__3_5I__(vsub1) and __arg_match__3D__(vcof1))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr1,vsub1,vcof1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr1) and __arg_alt_match__3_5I__(vsub1) and __arg_alt_match__3D__(vcof1))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr1,vsub1,vcof1):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr1,numpy.array(vsub1,dtype=numpy.dtype(numpy.int32)),numpy.array(vcof1,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr1,vsub1,vcof1):
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr1,mosek.fusion.ExprInner.__convert__3I_3_5I(expr1._getShape_(),vsub1),vcof1)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nelem)
   _a_5=(_a_1.nnz)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.nidxs_base)
   _a_11=(_a_1.sp_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=0
   _a_19 = fragments._c_closure_449(_a_7,_a_4,_a_9,_a_19,_a_11,self.__vsub,_a_16,_a_17)
   _a_19 = numpy.int32(_a_19) # postprocess
   _a_20=((_a_6 + (2 * _a_5)) if ((_a_6 > 0) ) else 0)
   _a_0._alloc_1expr_IIIZI(0,1,_a_19,False,_a_20)
   _a_21=(_a_0.ptr_base)
   _a_22=(_a_0.nidxs_base)
   _a_23=(_a_0.cof_base)
   _a_24=(_a_0.code_base)
   _a_25=(_a_0.codeptr_base)
   _a_26=(_a_0.cconst_base)
   _a_27=(_a_0.i32)
   _a_28=(_a_0.i64)
   _a_29=(_a_0.f64)
   _a_27[_a_21] = 0
   _a_27[(_a_21 + 1)] = _a_19
   if (_a_20 > 0):
    _a_27[_a_25] = 0
   _a_30=0
   _a_31=0
   _a_30,_a_31 = fragments._c_closure_450(_a_15,_a_13,_a_30,_a_14,_a_12,_a_7,_a_31,_a_4,_a_10,_a_9,_a_26,_a_24,_a_25,_a_23,_a_29,_a_27,_a_28,_a_20,_a_22,_a_11,self.__vcof,self.__vsub,_a_18,_a_16,_a_17)
   _a_30 = numpy.int32(_a_30) # postprocess
   _a_31 = numpy.int32(_a_31) # postprocess
  @staticmethod
  def __range_alt_I(_t__a_0):
    return mosek_fusion_ExprInner.__range_I(numpy.int32(__a_0))
  @staticmethod
  def __range_I(_a_0):
   return (numpy.array([_a_1 for _a_1 in range(0,_a_0)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __convert_alt__3I_3_5I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprInner.__convert__3I_3_5I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __convert__3I_3_5I(_a_0,_a_1):
   _a_2=int((_a_0).shape[0])
   _a_3=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int64))
   _a_3[(_a_2 - 1)] = 1
   fragments._c_closure_451(_a_2,_a_3,_a_0) 
   _a_4=numpy.zeros((int((_a_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_452(_a_2,_a_4,_a_3,_a_1) 
   return (_a_4)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprInner()")
 return ExprInner
mosek_fusion_ExprInner=__mk_mosek_fusion_ExprInner()
del __mk_mosek_fusion_ExprInner
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagRight():
 class ExprMulDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagRight__expr','_ExprMulDiagRight__mval','_ExprMulDiagRight__msubj','_ExprMulDiagRight__msubi','_ExprMulDiagRight__mdim1','_ExprMulDiagRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulDiagRight.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulDiagRight'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),numpy.array([mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprMulDiagRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nnz)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.codeptr_base)
   _a_14=(_a_1.code_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=_a_16[_a_8]
   _a_20=_a_16[(_a_8 + 1)]
   _a_21=int((self.__mval).shape[0])
   _a_22=_a_2._alloci32_I(_a_21)
   _a_23=_a_2._alloci32_I((self.__mdim1 + 1))
   _a_24=(_a_2.i32)
   fragments._c_closure_453(self.__mdim1,_a_21,self.__msubj,_a_24,_a_23,_a_22) 
   _a_25=0
   _a_26=0
   _a_27=0
   _a_25,_a_27,_a_26 = fragments._c_closure_454(_a_13,_a_20,_a_7,self.__mdim1,_a_21,self.__msubi,self.__msubj,_a_6,_a_5,_a_9,_a_25,_a_27,_a_26,_a_10,_a_16,_a_17,_a_24,_a_22)
   _a_25 = numpy.int32(_a_25) # postprocess
   _a_27 = numpy.int32(_a_27) # postprocess
   _a_26 = numpy.int32(_a_26) # postprocess
   _a_28=(_a_27 < _a_19)
   _a_0._alloc_1expr_IIIZI(1,_a_27,_a_26,_a_28,_a_25)
   _a_29=(_a_0.ptr_base)
   _a_30=(_a_0.nidxs_base)
   _a_31=((_a_0.sp_base) if (_a_28 ) else _a_0._alloci64_I(_a_27))
   _a_32=(_a_0.cof_base)
   _a_33=(_a_0.shape_base)
   _a_34=(_a_0.code_base)
   _a_35=(_a_0.codeptr_base)
   _a_36=(_a_0.cconst_base)
   _a_37=(_a_0.i64)
   _a_38=(_a_0.f64)
   _a_39=(_a_0.i32)
   _a_40=(_a_2.i32)
   _a_41=0
   _a_42=0
   _a_43=0
   _a_39[_a_29] = 0
   if (_a_25 > 0):
    _a_39[_a_35] = 0
   _a_39[_a_33] = self.__mdim1
   _a_41,_a_43,_a_42 = fragments._c_closure_455(_a_15,_a_14,_a_41,_a_13,_a_12,_a_20,_a_43,_a_7,self.__mdim1,_a_21,self.__msubi,self.__msubj,self.__mval,_a_6,_a_5,_a_11,_a_42,_a_9,_a_36,_a_34,_a_35,_a_32,_a_38,_a_39,_a_37,_a_30,_a_29,_a_31,_a_10,_a_18,_a_16,_a_17,_a_40,_a_22)
   _a_41 = numpy.int32(_a_41) # postprocess
   _a_43 = numpy.int32(_a_43) # postprocess
   _a_42 = numpy.int32(_a_42) # postprocess
   if (not _a_28):
    _a_0._popi64_I(_a_27)
   if (not (_a_26==_a_42)):
    raise mosek_fusion_UnexpectedError._ctor_S("Incorrect number of non-zeros")
   if (not (_a_27==_a_43)):
    raise mosek_fusion_UnexpectedError._ctor_S("Incorrect number of elements")
   _a_2._clear_()
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _a_5=_t__a_5
   _1_res = mosek_fusion_ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   _a_6=_a_5._getShape_()
   if (int((_a_6).shape[0]) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _a_7=_a_6[0]
   _a_8=_a_6[1]
   if ((_a_0 < 0) or ((_a_1 < 0) or ((_a_7 < 0) or (_a_8 < 0)))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_a_0!=_a_8) or (_a_1!=_a_7)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_a_2).shape[0])!=int((_a_3).shape[0])) or (int((_a_2).shape[0])!=int((_a_4).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _a_9=int((_a_2).shape[0])
   _a_10=False
   _a_11=False
   _a_10,_a_11 = fragments._c_closure_456(_a_10,_a_11,_a_0,_a_1,_a_9,_a_2,_a_3)
   if _a_10:
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _a_11:
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulDiagRight(")._a_S(self.__expr._toString_())._a_S(",m)")._toString_())
 return ExprMulDiagRight
mosek_fusion_ExprMulDiagRight=__mk_mosek_fusion_ExprMulDiagRight()
del __mk_mosek_fusion_ExprMulDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagLeft():
 class ExprMulDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagLeft__expr','_ExprMulDiagLeft__mval','_ExprMulDiagLeft__msubj','_ExprMulDiagLeft__msubi','_ExprMulDiagLeft__mdim1','_ExprMulDiagLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulDiagLeft.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulDiagLeft'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),numpy.array([mdim0], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprMulDiagLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ncodeatom)
   _a_11=(_a_1.ptr_base)
   _a_12=(_a_1.code_base)
   _a_13=(_a_1.cconst_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.shape_base)
   _a_16=(_a_1.sp_base)
   _a_17=(_a_1.nidxs_base)
   _a_18=(_a_1.cof_base)
   _a_19=(_a_1.cconst_base)
   if (_a_6!=2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _a_20=_a_3[_a_15]
   _a_21=_a_3[(_a_15 + 1)]
   _a_22=int((self.__msubi).shape[0])
   if (not _a_9):
    _a_23=0
    _a_24=0
    _a_25=0
    _a_26=0
    _a_26,_a_25,_a_24,_a_23 = fragments._c_closure_457(_a_14,_a_21,_a_26,self.__msubi,self.__msubj,_a_10,_a_11,_a_25,_a_24,_a_23,_a_3)
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_25 = numpy.int32(_a_25) # postprocess
    _a_24 = numpy.int32(_a_24) # postprocess
    _a_23 = numpy.int32(_a_23) # postprocess
    _a_27=(_a_24 < self.__mdim0)
    _a_0._alloc_1expr_IIIZI(1,_a_24,_a_23,_a_27,_a_25)
    _a_28=(_a_0.ptr_base)
    _a_29=(_a_0.nidxs_base)
    _a_30=((_a_0.sp_base) if (_a_27 ) else _a_0._alloci64_I(_a_24))
    _a_31=(_a_0.cof_base)
    _a_32=(_a_0.shape_base)
    _a_33=(_a_0.code_base)
    _a_34=(_a_0.codeptr_base)
    _a_35=(_a_0.cconst_base)
    _a_36=(_a_0.i64)
    _a_37=(_a_0.f64)
    _a_38=(_a_0.i32)
    fragments._c_closure_458(_a_13,_a_12,_a_14,_a_18,_a_21,self.__mdim0,self.__msubi,self.__msubj,self.__mval,_a_10,_a_17,_a_11,_a_35,_a_33,_a_34,_a_31,_a_37,_a_38,_a_36,_a_25,_a_29,_a_28,_a_32,_a_30,_a_5,_a_3,_a_4) 
    if (not _a_27):
     _a_0._popi64_I(_a_24)
   else:
    _a_39=_a_2._alloci32_I((_a_21 + 1))
    _a_40=_a_2._alloci32_I(_a_7)
    _a_41=_a_2._alloci32_I((self.__mdim0 + 1))
    _a_42=(_a_2.i32)
    _a_43=0
    _a_44=0
    _a_45=0
    _a_43,_a_45,_a_44 = fragments._c_closure_459(_a_14,_a_21,self.__msubi,self.__msubj,_a_10,_a_7,_a_11,_a_43,_a_45,_a_44,_a_16,_a_3,_a_4,_a_39,_a_40,_a_42)
    _a_43 = numpy.int32(_a_43) # postprocess
    _a_45 = numpy.int32(_a_45) # postprocess
    _a_44 = numpy.int32(_a_44) # postprocess
    _a_46=(_a_45 < self.__mdim0)
    _a_0._alloc_1expr_IIIZI(1,_a_45,_a_44,_a_46,_a_43)
    _a_47=(_a_0.ptr_base)
    _a_48=(_a_0.nidxs_base)
    _a_49=((_a_0.sp_base) if (_a_46 ) else _a_0._alloci64_I(_a_45))
    _a_50=(_a_0.cof_base)
    _a_51=(_a_0.shape_base)
    _a_52=(_a_0.code_base)
    _a_53=(_a_0.codeptr_base)
    _a_54=(_a_0.cconst_base)
    _a_55=(_a_0.i64)
    _a_56=(_a_0.f64)
    _a_57=(_a_0.i32)
    _a_58=0
    _a_59=0
    _a_60=0
    _a_61=0
    _a_62=0
    _a_57[_a_47] = 0
    if (_a_10 > 0):
     _a_57[_a_53] = 0
    _a_57[_a_51] = self.__mdim0
    _a_60,_a_58,_a_61,_a_62,_a_59 = fragments._c_closure_460(_a_13,_a_12,_a_60,_a_14,_a_18,_a_21,_a_58,_a_61,_a_62,self.__msubi,self.__msubj,self.__mval,_a_10,_a_7,_a_17,_a_59,_a_11,_a_54,_a_52,_a_53,_a_50,_a_56,_a_57,_a_55,_a_48,_a_47,_a_49,_a_16,_a_5,_a_3,_a_4,_a_40,_a_42)
    _a_60 = numpy.int32(_a_60) # postprocess
    _a_58 = numpy.int32(_a_58) # postprocess
    _a_61 = numpy.int32(_a_61) # postprocess
    _a_62 = numpy.int32(_a_62) # postprocess
    _a_59 = numpy.int32(_a_59) # postprocess
    if (_a_59!=_a_44):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
    if (_a_58!=_a_45):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
    if (not _a_46):
     _a_0._popi64_I(_a_45)
   _a_2._clear_()
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _a_5=_t__a_5
   _1_res = mosek_fusion_ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   _a_6=_a_5._getShape_()
   if (int((_a_6).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _a_7=_a_6[0]
   _a_8=_a_6[1]
   if ((_a_0 < 0) or (_a_1 < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_a_1!=_a_7) or (_a_0!=_a_8)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_a_2).shape[0])!=int((_a_3).shape[0])) or (int((_a_2).shape[0])!=int((_a_4).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _a_9=int((_a_2).shape[0])
   _a_10=False
   _a_11=False
   _a_10,_a_11 = fragments._c_closure_461(_a_10,_a_11,_a_0,_a_1,_a_9,_a_2,_a_3)
   if _a_10:
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _a_11:
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulDiagLeft(m,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulDiagLeft
mosek_fusion_ExprMulDiagLeft=__mk_mosek_fusion_ExprMulDiagLeft()
del __mk_mosek_fusion_ExprMulDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulElement():
 class ExprMulElement(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulElement__expr','_ExprMulElement__msp','_ExprMulElement__mcof']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
      self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulElement.ctor(array(double,ndim=1),array(int64,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulElement.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulElement._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulElement._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulElement.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulElement._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulElement._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulElement'
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_match__3D__(mcof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_alt_match__3D__(mcof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr)
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
   mosek_fusion_ExprMulElement._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,mcof,msp,expr,1)
   _a_0=expr._getShape_()
   if (int((mcof).shape[0])!=int((msp).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix specification")
   _a_1=mosek.fusion.Set._size__3I(_a_0)
   _a_2=False
   _a_3=False
   _a_2,_a_3 = fragments._c_closure_462(_a_2,_a_3,msp,_a_1)
   if _a_2:
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
   if _a_3:
    raise mosek_fusion_IndexError._ctor_S("Matrix data not sorted")
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2I(cof,msp,expr,validated):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(cof,msp,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    cof,msp,expr,validated, = args
    return (__arg_match__3D__(cof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    cof,msp,expr,validated, = args
    return (__arg_alt_match__3D__(cof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2I(self,cof,msp,expr,validated):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr,numpy.int32(validated))
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,cof,msp,expr,validated):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
   (self.__mcof) = cof
   (self.__msp) = msp
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nelem)
   _a_5=(_a_1.nnz)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.nidxs_base)
   _a_11=(_a_1.sp_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=0
   _a_20=0
   _a_21=0
   _a_19,_a_21,_a_20 = fragments._c_closure_463(_a_14,_a_7,self.__msp,_a_6,_a_4,_a_9,_a_19,_a_21,_a_20,_a_11,_a_16,_a_17)
   _a_19 = numpy.int32(_a_19) # postprocess
   _a_21 = numpy.int32(_a_21) # postprocess
   _a_20 = numpy.int32(_a_20) # postprocess
   _a_22=1
   _a_22 = fragments._c_closure_464(_a_3,_a_22,_a_8,_a_16)
   _a_22 = numpy.int64(_a_22) # postprocess
   _a_23=(_a_21 < _a_22)
   _a_24=_a_3
   _a_0._alloc_1expr_IIIZI(_a_24,_a_21,_a_20,_a_23,_a_19)
   _a_25=(_a_0.ptr_base)
   _a_26=(_a_0.shape_base)
   _a_27=(_a_0.nidxs_base)
   _a_28=((_a_0.sp_base) if (_a_23 ) else _a_0._alloci64_I(_a_21))
   _a_29=(_a_0.cof_base)
   _a_30=(_a_0.code_base)
   _a_31=(_a_0.codeptr_base)
   _a_32=(_a_0.cconst_base)
   _a_33=(_a_0.i32)
   _a_34=(_a_0.i64)
   _a_35=(_a_0.f64)
   fragments._c_closure_465(_a_15,_a_13,_a_14,_a_12,_a_7,self.__mcof,self.__msp,_a_6,_a_4,_a_10,_a_9,_a_32,_a_30,_a_31,_a_29,_a_35,_a_33,_a_34,_a_19,_a_24,_a_27,_a_25,_a_26,_a_28,_a_8,_a_11,_a_18,_a_16,_a_17) 
   if (not _a_23):
    _a_0._popi64_I(_a_21)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulElement(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulElement
mosek_fusion_ExprMulElement=__mk_mosek_fusion_ExprMulElement()
del __mk_mosek_fusion_ExprMulElement
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarConst():
 class ExprMulScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarConst__expr','_ExprMulScalarConst__c']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_DLmosek_4fusion_4Expression_2(*args):
      self._ctor_init_DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarConst.ctor(double,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulScalarConst.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulScalarConst'
  @staticmethod
  def _ctor_DLmosek_4fusion_4Expression_2(c,expr):
    o = ExprMulScalarConst.__new__(ExprMulScalarConst)
    o._ctor_init_DLmosek_4fusion_4Expression_2(c,expr)
    return o
  @staticmethod
  def __match_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_match_D__(c) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_alt_match_D__(c) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_DLmosek_4fusion_4Expression_2(self,c,expr):
    self._ctor_init_DLmosek_4fusion_4Expression_2(numpy.float64(c),expr)
  def _ctor_init_DLmosek_4fusion_4Expression_2(self,c,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__c) = c
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.i32)
   _a_4=(_a_1.i64)
   _a_5=(_a_1.f64)
   _a_6=(_a_1.nd)
   _a_7=(_a_1.nelem)
   _a_8=(_a_1.nnz)
   _a_9=(_a_1.hassp)
   _a_10=(_a_1.ncodeatom)
   _a_11=(_a_1.ptr_base)
   _a_12=(_a_1.code_base)
   _a_13=(_a_1.cconst_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.shape_base)
   _a_16=(_a_1.sp_base)
   _a_17=(_a_1.nidxs_base)
   _a_18=(_a_1.cof_base)
   _a_19=(_a_1.cconst_base)
   _a_20=(0 if ((_a_10==0) ) else (_a_10 + (2 * _a_8)))
   _a_0._alloc_1expr_IIIZI(_a_6,_a_7,_a_8,_a_9,_a_20)
   _a_21=(_a_0.i64)
   _a_22=(_a_0.f64)
   _a_23=(_a_0.i32)
   _a_24=(_a_0.ptr_base)
   _a_25=(_a_0.nidxs_base)
   _a_26=(_a_0.cof_base)
   _a_27=(_a_0.code_base)
   _a_28=(_a_0.codeptr_base)
   _a_29=(_a_0.cconst_base)
   _a_30=(_a_0.hassp)
   _a_31=(_a_0.shape_base)
   _a_32=(_a_0.sp_base)
   fragments._c_closure_466(self.__c,_a_13,_a_12,_a_14,_a_18,_a_9,_a_10,_a_6,_a_7,_a_17,_a_8,_a_11,_a_29,_a_27,_a_28,_a_26,_a_22,_a_23,_a_21,_a_25,_a_24,_a_31,_a_32,_a_15,_a_16,_a_5,_a_3,_a_4) 
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulScalarConst()")
 return ExprMulScalarConst
mosek_fusion_ExprMulScalarConst=__mk_mosek_fusion_ExprMulScalarConst()
del __mk_mosek_fusion_ExprMulScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprScalarMul():
 class ExprScalarMul(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprScalarMul__expr','_ExprScalarMul__mval','_ExprScalarMul__msubj','_ExprScalarMul__msubi','_ExprScalarMul__mdim1','_ExprScalarMul__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprScalarMul.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprScalarMul.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprScalarMul.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.toString()')
  def __repr__(self): return 'mosek.fusion.ExprScalarMul'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),numpy.array([mdim0,mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprScalarMul._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nelem)
   _a_5=(_a_1.nnz)
   _a_6=(_a_1.hassp)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.ptr_base)
   _a_9=(_a_1.sp_base)
   _a_10=(_a_1.nidxs_base)
   _a_11=(_a_1.cof_base)
   _a_12=(_a_1.code_base)
   _a_13=(_a_1.codeptr_base)
   _a_14=(_a_1.cconst_base)
   _a_15=(_a_1.i32)
   _a_16=(_a_1.i64)
   _a_17=(_a_1.f64)
   _a_18=int((self.__mval).shape[0])
   if (_a_3!=0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression shape")
   if (_a_4==0):
    _a_0._alloc_1expr_IIIZ(2,0,0,True)
    (_a_0.i32)[(_a_0.shape_base)] = self.__mdim0
    (_a_0.i32)[((_a_0.shape_base) + 1)] = self.__mdim1
   else:
    _a_19=(_a_18 * (_a_7 + ((2 * _a_5) if ((_a_7 > 0) ) else 0)))
    _a_0._alloc_1expr_IIIZI(2,_a_18,(_a_18 * _a_5),True,_a_19)
    _a_20=(_a_0.ptr_base)
    _a_21=(_a_0.nidxs_base)
    _a_22=(_a_0.sp_base)
    _a_23=(_a_0.cof_base)
    _a_24=(_a_0.shape_base)
    _a_25=(_a_0.code_base)
    _a_26=(_a_0.codeptr_base)
    _a_27=(_a_0.cconst_base)
    _a_28=(_a_0.i32)
    _a_29=(_a_0.i64)
    _a_30=(_a_0.f64)
    _a_28[_a_24] = self.__mdim0
    _a_28[(_a_24 + 1)] = self.__mdim1
    _a_31=0
    _a_32=0
    _a_28[_a_20] = 0
    _a_31,_a_32 = fragments._c_closure_467(_a_14,_a_12,_a_31,_a_13,_a_11,self.__mdim1,_a_18,self.__msubi,self.__msubj,self.__mval,_a_7,_a_10,_a_5,_a_32,_a_27,_a_25,_a_26,_a_23,_a_30,_a_28,_a_29,_a_21,_a_20,_a_22,_a_17,_a_15,_a_16)
    _a_31 = numpy.int32(_a_31) # postprocess
    _a_32 = numpy.int32(_a_32) # postprocess
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _a_5=_t__a_5
   _1_res = mosek_fusion_ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   _a_6=_a_5._getND_()
   if (_a_6!=0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_a_0 < 0) or (_a_1 < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((int((_a_2).shape[0])!=int((_a_3).shape[0])) or (int((_a_2).shape[0])!=int((_a_4).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _a_7=int((_a_2).shape[0])
   _a_8=False
   _a_9=False
   _a_8,_a_9 = fragments._c_closure_468(_a_8,_a_9,_a_0,_a_1,_a_7,_a_2,_a_3)
   if _a_8:
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _a_9:
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprScalarMul(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprScalarMul
mosek_fusion_ExprScalarMul=__mk_mosek_fusion_ExprScalarMul()
del __mk_mosek_fusion_ExprScalarMul
#BEFORE CLASS
def __mk_mosek_fusion_ExprCrossDot():
 class ExprCrossDot(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCrossDot__expr','_ExprCrossDot__mval','_ExprCrossDot__msubj','_ExprCrossDot__msubi','_ExprCrossDot__mdim1','_ExprCrossDot__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_II_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_init_II_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_II_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCrossDot.ctor(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.ExprCrossDot.ctor(int32,int32,array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.ExprCrossDot.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCrossDot.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprCrossDot._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCrossDot._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCrossDot.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCrossDot.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprCrossDot._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprCrossDot._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCrossDot.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCrossDot'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(m,expr):
    o = ExprCrossDot.__new__(ExprCrossDot)
    o._ctor_init_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(m,expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    m,expr, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    m,expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(self,m,expr):
    self._ctor_init_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(m,expr)
  def _ctor_init_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(self,m,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprCrossDot.__computeshape_II_3I(m._numRows_(),m._numColumns_(),expr._getShape_()))
   _a_0=m._numNonzeros_()
   self.__mdim0 = m._numRows_()
   self.__mdim1 = m._numColumns_()
   if m._isSparse_():
    self.__msubi = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
    self.__msubj = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
    self.__mval = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.float64))
    m._getDataAsTriplets__3I_3I_3D(self.__msubi,self.__msubj,self.__mval)
   else:
    self.__mval = m._getDataAsArray_()
    self.__msubi = None
    self.__msubj = None
   mosek.fusion.ExprCrossDot.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(self.__mdim0,self.__mdim1,self.__msubi,self.__msubj,self.__mval,expr)
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprCrossDot.__new__(ExprCrossDot)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprCrossDot.__computeshape_II_3I(mdim0,mdim1,expr._getShape_()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3DLmosek_4fusion_4Expression_2(mdim0__,mdim1__,mval__,expr__):
    o = ExprCrossDot.__new__(ExprCrossDot)
    o._ctor_init_II_3DLmosek_4fusion_4Expression_2(mdim0__,mdim1__,mval__,expr__)
    return o
  @staticmethod
  def __match_ctor_II_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    mdim0__,mdim1__,mval__,expr__, = args
    return (__arg_match_I__(mdim0__) and __arg_match_I__(mdim1__) and __arg_match__3D__(mval__) and __arg_match_Lmosek_4fusion_4Expression_2__(expr__))
  @staticmethod
  def __match_alt_ctor_II_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    mdim0__,mdim1__,mval__,expr__, = args
    return (__arg_alt_match_I__(mdim0__) and __arg_alt_match_I__(mdim1__) and __arg_alt_match__3D__(mval__) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr__))
  def _ctor_alt_init_II_3DLmosek_4fusion_4Expression_2(self,mdim0__,mdim1__,mval__,expr__):
    self._ctor_init_II_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0__),numpy.int32(mdim1__),numpy.array(mval__,dtype=numpy.dtype(numpy.float64)),expr__)
  def _ctor_init_II_3DLmosek_4fusion_4Expression_2(self,mdim0__,mdim1__,mval__,expr__):
   mosek_fusion_ExprCrossDot._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0__,mdim1__,None,None,mval__,expr__,mosek.fusion.ExprCrossDot.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0__,mdim1__,None,None,mval__,expr__))
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0_,mdim1_,msubi_,msubj_,mval_,expr_):
    o = ExprCrossDot.__new__(ExprCrossDot)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0_,mdim1_,msubi_,msubj_,mval_,expr_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0_,mdim1_,msubi_,msubj_,mval_,expr_, = args
    return (__arg_match_I__(mdim0_) and __arg_match_I__(mdim1_) and __arg_match__3I__(msubi_) and __arg_match__3I__(msubj_) and __arg_match__3D__(mval_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0_,mdim1_,msubi_,msubj_,mval_,expr_, = args
    return (__arg_alt_match_I__(mdim0_) and __arg_alt_match_I__(mdim1_) and __arg_alt_match__3I__(msubi_) and __arg_alt_match__3I__(msubj_) and __arg_alt_match__3D__(mval_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr_))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0_,mdim1_,msubi_,msubj_,mval_,expr_):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0_),numpy.int32(mdim1_),numpy.array(msubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(mval_,dtype=numpy.dtype(numpy.float64)),expr_)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0_,mdim1_,msubi_,msubj_,mval_,expr_):
   mosek_fusion_ExprCrossDot._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0_,mdim1_,msubi_,msubj_,mval_,expr_,1)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nnz)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.codeptr_base)
   _a_14=(_a_1.code_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=0
   _a_20=0
   _a_21=False
   _a_22=0
   _a_23=_a_16[(_a_8 + 0)]
   _a_24=_a_16[(_a_8 + 1)]
   _a_25=int((self.__mval).shape[0])
   _a_22,_a_20,_a_19 = fragments._c_closure_469(_a_13,_a_23,_a_24,_a_7,self.__mdim0,_a_25,self.__msubi,self.__msubj,_a_6,_a_5,_a_4,_a_9,_a_22,_a_20,_a_19,_a_10,_a_16,_a_17)
   _a_22 = numpy.int32(_a_22) # postprocess
   _a_20 = numpy.int32(_a_20) # postprocess
   _a_19 = numpy.int32(_a_19) # postprocess
   _a_26=(_a_20 < (_a_23 * self.__mdim0))
   _a_0._alloc_1expr_IIIZI(2,_a_20,_a_19,_a_26,_a_22)
   _a_27=(_a_0.i32)
   _a_28=(_a_0.i64)
   _a_29=(_a_0.f64)
   _a_30=(_a_0.ncodeatom)
   _a_31=(_a_0.shape_base)
   _a_32=(_a_0.ptr_base)
   _a_33=((_a_0.sp_base) if (_a_26 ) else (- 9999))
   _a_34=(_a_0.nidxs_base)
   _a_35=(_a_0.cof_base)
   _a_36=(_a_0.codeptr_base)
   _a_37=(_a_0.code_base)
   _a_38=(_a_0.cconst_base)
   _a_27[_a_31] = self.__mdim0
   _a_27[(_a_31 + 1)] = _a_23
   _a_27[_a_32] = 0
   if (_a_30 > 0):
    _a_27[_a_36] = 0
   if ((self.__msubi is None) or (self.__msubj is None)):
    if (not _a_7):
     _a_39=0
     _a_40=0
     for _a_41 in range(0,self.__mdim0):
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_17,_a_11,_a_28,(_a_34 + _a_39),_a_4)
      _a_42=0
      _a_42,_a_40,_a_39 = fragments._c_closure_470(_a_12,_a_23,_a_42,_a_40,_a_41,self.__mdim1,self.__mval,_a_39,_a_9,_a_35,_a_29,_a_27,_a_32,_a_18,_a_16)
      _a_42 = numpy.int32(_a_42) # postprocess
      _a_40 = numpy.int32(_a_40) # postprocess
      _a_39 = numpy.int32(_a_39) # postprocess
     fragments._c_closure_471(_a_15,_a_14,_a_13,_a_23,self.__mdim0,self.__mdim1,self.__mval,_a_9,_a_38,_a_37,_a_36,_a_29,_a_27,_a_30,_a_18,_a_16) 
    else:
     _a_43=0
     _a_44=0
     for _a_45 in range(0,self.__mdim0):
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_17,_a_11,_a_28,(_a_34 + _a_43),_a_4)
      _a_46=0
      _a_44,_a_43 = fragments._c_closure_472(_a_12,_a_23,_a_24,_a_44,_a_45,self.__mdim1,self.__mval,_a_5,_a_43,_a_9,_a_35,_a_29,_a_26,_a_27,_a_28,_a_32,_a_33,_a_10,_a_18,_a_16,_a_17)
      _a_44 = numpy.int32(_a_44) # postprocess
      _a_43 = numpy.int32(_a_43) # postprocess
     fragments._c_closure_473(_a_15,_a_14,_a_13,_a_23,_a_24,self.__mdim0,self.__mval,_a_5,_a_9,_a_38,_a_37,_a_36,_a_29,_a_27,_a_30,_a_10,_a_18,_a_16,_a_17) 
   elif (not _a_7):
    _a_47=0
    _a_48=0
    _a_49=0
    _a_49,_a_48,_a_47 = fragments._c_closure_474(_a_15,_a_14,_a_49,_a_13,_a_12,_a_23,_a_24,_a_48,_a_25,self.__msubi,self.__msubj,self.__mval,_a_11,_a_47,_a_9,_a_38,_a_37,_a_36,_a_35,_a_29,_a_26,_a_27,_a_28,_a_30,_a_34,_a_32,_a_33,_a_18,_a_16,_a_17)
    _a_49 = numpy.int32(_a_49) # postprocess
    _a_48 = numpy.int32(_a_48) # postprocess
    _a_47 = numpy.int32(_a_47) # postprocess
    if (_a_47!=_a_19):
     raise mosek_fusion_UnexpectedError._ctor_S("Error in evaluation: Incorrect number of nonzeros")
    if (_a_48!=_a_20):
     raise mosek_fusion_UnexpectedError._ctor_S("Error in evaluation: Incorrect number of elements")
    if (_a_49!=_a_30):
     raise mosek_fusion_UnexpectedError._ctor_S("Error in evaluation: Incorrect number of code elements")
   else:
    _a_50=0
    _a_51=0
    _a_51,_a_50 = fragments._c_closure_475(_a_12,_a_23,_a_24,_a_51,_a_25,self.__msubi,self.__msubj,self.__mval,_a_5,_a_11,_a_50,_a_9,_a_35,_a_29,_a_26,_a_27,_a_28,_a_34,_a_32,_a_33,_a_10,_a_18,_a_16,_a_17)
    _a_51 = numpy.int32(_a_51) # postprocess
    _a_50 = numpy.int32(_a_50) # postprocess
    if (_a_50!=_a_19):
     raise mosek_fusion_UnexpectedError._ctor_S("Error in evaluation: Incorrect number of nonzeros")
    if (_a_51!=_a_20):
     raise mosek_fusion_UnexpectedError._ctor_S("Error in evaluation: Incorrect number of elements")
    if (_a_30 > 0):
     _a_52=0
     _a_53=0
     _a_53,_a_52 = fragments._c_closure_476(_a_15,_a_14,_a_53,_a_13,_a_24,_a_25,self.__msubi,self.__msubj,self.__mval,_a_5,_a_52,_a_9,_a_38,_a_37,_a_36,_a_29,_a_27,_a_10,_a_18,_a_16,_a_17)
     _a_53 = numpy.int32(_a_53) # postprocess
     _a_52 = numpy.int32(_a_52) # postprocess
     if (_a_53!=_a_30):
      raise mosek_fusion_UnexpectedError._ctor_S("Error in evaluation: Incorrect number of code elements")
  @staticmethod
  def __computeshape_alt_II_3I(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprCrossDot.__computeshape_II_3I(_a_0,_a_1,_a_2)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __computeshape_II_3I(_a_0,_a_1,_a_2):
   if (int((_a_2).shape[0])!=2):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   elif (_a_1!=_a_2[1]):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   return (numpy.array([_a_0,_a_2[0]], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _a_5=_t__a_5
   _1_res = mosek_fusion_ExprCrossDot.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   if (_a_5._getND_()!=2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _a_6=_a_5._getDim_I(0)
   _a_7=_a_5._getDim_I(1)
   if ((_a_0 < 0) or (_a_1 < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_a_1!=_a_7):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((_a_2 is not None) and (_a_3 is not None)):
    if ((int((_a_2).shape[0])!=int((_a_3).shape[0])) or (int((_a_2).shape[0])!=int((_a_4).shape[0]))):
     raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   else:
    if (int((_a_4).shape[0])!=(_a_0 * _a_1)):
     raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _a_8=int((_a_4).shape[0])
   _a_9=False
   _a_10=False
   _a_9,_a_10 = fragments._c_closure_477(_a_9,_a_10,_a_0,_a_1,_a_8,_a_2,_a_3)
   if _a_9:
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _a_10:
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCrossDot(M(")._a_I(self.__mdim0)._a_S(",")._a_I(self.__mdim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCrossDot
mosek_fusion_ExprCrossDot=__mk_mosek_fusion_ExprCrossDot()
del __mk_mosek_fusion_ExprCrossDot
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVar():
 class ExprMulVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVar__left','_ExprMulVar__x','_ExprMulVar__mcof','_ExprMulVar__msubj','_ExprMulVar__msubi','_ExprMulVar__mdimj','_ExprMulVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
      self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
      self._ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVar.ctor(bool,int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval_right(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulVar.eval_right(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_right('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_right(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulVar.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulVar._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVar._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.toString()')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def eval_left(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulVar.eval_left(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_left('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_left(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprMulVar'
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
   mosek_fusion_ExprMulVar._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,1)
   _a_0=x._getShape_()
   _a_1=int((_a_0).shape[0])
   if (_a_1!=2):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif (left and (_a_0[0]!=mdimj)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif ((not left) and (_a_0[1]!=mdimi)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching matrix data lengths")
   self.__validate_II_3I_3I_3D(mdimi,mdimj,msubi,msubj,mcof)
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,x._getModel_(),mosek.fusion.ExprMulVar.__resshape_II_3IZ(mdimi,mdimj,x._getShape_(),left))
   (self.__left) = left
   (self.__x) = x
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = mosek.fusion.Utils.Tools._arraycopy__3I(msubi)
   (self.__msubj) = mosek.fusion.Utils.Tools._arraycopy__3I(msubj)
   (self.__mcof) = mosek.fusion.Utils.Tools._arraycopy__3D(mcof)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   if self.__left:
    self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
   else:
    self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=(_a_1.pi32)
   _a_4=(_a_1.pi64)
   _a_5=self.__x._numInst_()
   _a_6=_a_1._alloci64_I(_a_5)
   _a_7=_a_1._alloci64_I(_a_5)
   _a_8=_a_1._alloci32_I(_a_5)
   _a_9=_a_1._alloci32_I(_a_5)
   _a_10=self.__x._getShape_()
   _a_11=int((_a_10).shape[0])
   _a_12=(_a_10[0] * _a_10[1])
   _a_13=_a_10[1]
   _a_14=_a_10[0]
   _a_15=_a_1._alloci32_I((_a_14 + 1))
   _a_16=int(((self.__msubi)).shape[0])
   _a_17=(self.__msubi)
   _a_18=(self.__msubj)
   _a_19=(self.__mcof)
   _a_20=(self.__mdimi)
   _a_21=(self.__mdimj)
   _a_22=((_a_16 // _a_20)==_a_21)
   _a_23=_a_1._alloci32_I(_a_16)
   _a_24=_a_1._alloci32_I((self.__mdimj + 1))
   _a_25=(_a_1.i32)
   _a_26=(_a_1.i64)
   _a_27=0
   _a_28=0
   self.__x._inst_I_3JI_3J(_a_7,_a_26,_a_6,_a_26)
   if _a_22:
    _a_29=0
    _a_29 = fragments._c_closure_478(_a_5,_a_7,_a_26,_a_29,_a_14,_a_13)
    _a_29 = numpy.int32(_a_29) # postprocess
    _a_28 = (_a_29 * _a_21)
    _a_27 = (_a_5 * _a_21)
    _a_30=(_a_29 < _a_14)
    _a_0._alloc_1expr_IIIZ(2,_a_28,_a_27,_a_30)
    _a_31=(_a_0.ptr_base)
    _a_32=(_a_0.shape_base)
    _a_33=(_a_0.nidxs_base)
    _a_34=((_a_0.sp_base) if (_a_30 ) else _a_0._alloci64_I(_a_28))
    _a_35=(_a_0.cof_base)
    _a_36=(_a_0.i32)
    _a_37=(_a_0.i64)
    _a_38=(_a_0.f64)
    _a_36[_a_32] = _a_14
    _a_36[(_a_32 + 1)] = _a_21
    fragments._c_closure_479(_a_19,_a_21,_a_6,_a_5,_a_35,_a_38,_a_36,_a_37,_a_33,_a_31,_a_34,_a_7,_a_26,_a_13) 
    if (not _a_30):
     _a_0._popi64_I(_a_28)
   else:
    fragments._c_closure_480(_a_21,self.__mdimj,_a_24,_a_18,_a_16,_a_23,_a_25) 
    if ((_a_5 // _a_14)==_a_13):
     _a_39=0
     _a_39 = fragments._c_closure_481(_a_18,_a_39,_a_16,_a_23,_a_25)
     _a_39 = numpy.int32(_a_39) # postprocess
     _a_28 = (_a_39 * _a_14)
     _a_27 = (_a_16 * _a_14)
     _a_40=(_a_39 < _a_21)
     _a_0._alloc_1expr_IIIZ(2,_a_28,_a_27,_a_40)
     _a_41=(_a_0.ptr_base)
     _a_42=(_a_0.shape_base)
     _a_43=(_a_0.nidxs_base)
     _a_44=((_a_0.sp_base) if (_a_40 ) else _a_0._alloci64_I(_a_28))
     _a_45=(_a_0.cof_base)
     (_a_0.i32)[_a_42] = _a_14
     (_a_0.i32)[(_a_42 + 1)] = _a_21
     _a_46=(_a_0.i32)
     _a_47=(_a_0.i64)
     _a_48=(_a_0.f64)
     _a_46[_a_41] = 0
     _a_49=0
     _a_50=0
     _a_49,_a_50 = fragments._c_closure_482(_a_49,_a_50,_a_19,_a_21,_a_17,_a_18,_a_6,_a_16,_a_23,_a_45,_a_48,_a_46,_a_47,_a_43,_a_41,_a_44,_a_25,_a_26,_a_14,_a_13)
     _a_49 = numpy.int32(_a_49) # postprocess
     _a_50 = numpy.int32(_a_50) # postprocess
     if (not _a_40):
      _a_0._popi64_I(_a_28)
    else:
     fragments._c_closure_483(_a_15,_a_25,_a_14) 
     fragments._c_closure_484(_a_11,_a_5,_a_15,_a_7,_a_25,_a_26,_a_14,_a_10,_a_8,_a_9) 
     _a_28,_a_27 = fragments._c_closure_485(self.__mdimj,_a_24,_a_17,_a_28,_a_27,_a_23,_a_15,_a_25,_a_14,_a_9)
     _a_28 = numpy.int32(_a_28) # postprocess
     _a_27 = numpy.int32(_a_27) # postprocess
     _a_51=(_a_28 < (_a_13 * self.__mdimi))
     _a_0._alloc_1expr_IIIZ(2,_a_28,_a_27,_a_51)
     _a_52=(_a_0.ptr_base)
     _a_53=(_a_0.shape_base)
     _a_54=(_a_0.nidxs_base)
     _a_55=(_a_0.sp_base)
     _a_56=(_a_0.cof_base)
     (_a_0.i32)[_a_53] = _a_14
     (_a_0.i32)[(_a_53 + 1)] = self.__mdimj
     _a_57=(_a_0.i32)
     _a_58=(_a_0.i64)
     _a_59=(_a_0.f64)
     fragments._c_closure_486(_a_19,self.__mdimj,_a_24,_a_17,_a_6,_a_23,_a_15,_a_56,_a_59,_a_51,_a_57,_a_58,_a_54,_a_52,_a_55,_a_25,_a_26,_a_14,_a_9) 
   (_a_1.pi32) = _a_3
   (_a_1.pi64) = _a_4
  @staticmethod
  def _match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=self.__x._numInst_()
   _a_4=self.__x._getShape_()
   _a_5=int((_a_4).shape[0])
   _a_6=_a_2._alloci64_I(_a_3)
   _a_7=_a_2._alloci64_I(_a_3)
   _a_8=_a_2._alloci32_I(_a_3)
   _a_9=_a_2._alloci32_I(_a_3)
   _a_10=_a_2._alloci32_I(_a_3)
   _a_11=_a_2._alloci32_I((self.__mdimi + 1))
   _a_12=self.__x._getShape_()
   _a_13=int((_a_12).shape[0])
   _a_14=(1 if ((_a_13==1) ) else _a_12[1])
   _a_15=_a_12[0]
   _a_16=_a_2._alloci32_I((_a_14 + 1))
   _a_17=(self.__msubi)
   _a_18=(self.__msubj)
   _a_19=(self.__mcof)
   _a_20=(self.__mdimi)
   _a_21=(self.__mdimj)
   _a_22=0
   _a_23=0
   _a_24=(_a_2.i32)
   _a_25=(_a_2.i64)
   _a_26=int((_a_19).shape[0])
   self.__x._inst_I_3JI_3J(_a_7,_a_25,_a_6,_a_25)
   if (self.__x._numInst_() < self.__x._getSize_()):
    _a_23,_a_22 = fragments._c_closure_487(_a_20,_a_11,_a_17,_a_18,_a_13,_a_3,_a_10,_a_16,_a_23,_a_22,_a_7,_a_14,_a_24,_a_25,_a_8,_a_9)
    _a_23 = numpy.int32(_a_23) # postprocess
    _a_22 = numpy.int32(_a_22) # postprocess
   else:
    _a_23,_a_22 = fragments._c_closure_488(_a_26,_a_17,_a_23,_a_22,_a_14)
    _a_23 = numpy.int32(_a_23) # postprocess
    _a_22 = numpy.int32(_a_22) # postprocess
   _a_27=(True if ((_a_23 < (_a_14 * _a_20)) ) else False)
   _a_28=_a_13
   _a_0._alloc_1expr_IIIZ(_a_28,_a_23,_a_22,_a_27)
   _a_29=(_a_0.ptr_base)
   _a_30=(_a_0.shape_base)
   _a_31=(_a_0.nidxs_base)
   _a_32=((_a_0.sp_base) if (_a_27 ) else _a_0._alloci64_I(_a_23))
   _a_33=(_a_0.cof_base)
   _a_34=(_a_0.i32)
   _a_35=(_a_0.i64)
   _a_36=(_a_0.f64)
   _a_34[_a_30] = _a_20
   if (_a_13 > 1):
    _a_34[(_a_30 + 1)] = _a_14
   if (self.__x._numInst_() < self.__x._getSize_()):
    fragments._c_closure_489(_a_19,_a_20,_a_11,_a_18,_a_6,_a_10,_a_16,_a_33,_a_36,_a_34,_a_35,_a_31,_a_29,_a_32,_a_14,_a_24,_a_25,_a_8) 
   else:
    fragments._c_closure_490(_a_19,_a_26,_a_17,_a_18,_a_6,_a_33,_a_36,_a_34,_a_35,_a_31,_a_29,_a_32,_a_14,_a_25) 
   if (not _a_27):
    _a_0._popi64_I(_a_23)
   _a_2._clear_()
  def __validate_alt_II_3I_3I_3D(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _1_res = self.__validate_II_3I_3I_3D(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __validate_II_3I_3I_3D(self,_a_0,_a_1,_a_2,_a_3,_a_4):
   _a_5=True
   _a_5 = fragments._c_closure_491(_a_0,_a_1,_a_2,_a_3,_a_5)
   if (not _a_5):
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
  @staticmethod
  def __resshape_alt_II_3IZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=_t__a_3
   _1_res = mosek_fusion_ExprMulVar.__resshape_II_3IZ(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __resshape_II_3IZ(_a_0,_a_1,_a_2,_a_3):
   if _a_3:
    return (numpy.array([_a_0,_a_2[1]], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_a_2[0],_a_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   if self.__left:
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(M,")._a_S(self.__x._toString_())._a_S(")")._toString_())
   else:
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(")._a_S(self.__x._toString_())._a_S(",M)")._toString_())
 return ExprMulVar
mosek_fusion_ExprMulVar=__mk_mosek_fusion_ExprMulVar()
del __mk_mosek_fusion_ExprMulVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarVar():
 class ExprMulScalarVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarVar__x','_ExprMulScalarVar__mcof','_ExprMulScalarVar__msubj','_ExprMulScalarVar__msubi','_ExprMulScalarVar__mdimj','_ExprMulScalarVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarVar.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulScalarVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulScalarVar.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulScalarVar'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
   mosek_fusion_ExprMulScalarVar._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,mosek.fusion.Utils.Tools._arraycopy__3I(msubi),mosek.fusion.Utils.Tools._arraycopy__3I(msubj),mosek.fusion.Utils.Tools._arraycopy__3D(mcof),x,1)
   if (x._getND_()!=0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid Variable size")
   if ((mdimi < 0) or ((mdimj < 0) or ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))))):
    raise mosek_fusion_LengthError._ctor_S("Invalid Matrix data")
   _a_0=False
   _a_0 = fragments._c_closure_492(_a_0,mdimi,mdimj,msubi,msubj)
   if _a_0:
    raise mosek_fusion_IndexError._ctor_S("Invalid Matrix data")
   _a_1=False
   _a_1 = fragments._c_closure_493(_a_1,msubi,msubj)
   if _a_1:
    raise mosek_fusion_IndexError._ctor_S("Matrix data not correctly sorted")
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,x._getModel_(),numpy.array([mdimi,mdimj], dtype=numpy.dtype(numpy.int32)))
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mcof) = mcof
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   if (self.__x._numInst_()==0):
    _a_0._alloc_1expr_IIIZ(2,0,0,False)
    (_a_0.i32)[(_a_0.shape_base)] = self.__mdimi
    (_a_0.i32)[((_a_0.shape_base) + 1)] = self.__mdimj
   else:
    _a_3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
    self.__x._inst_I_3J(0,_a_3)
    _a_4=_a_3[0]
    _a_5=int((self.__msubi).shape[0])
    _a_6=_a_5
    _a_7=(_a_5 < (self.__mdimi * self.__mdimj))
    _a_0._alloc_1expr_IIIZ(2,_a_5,_a_6,_a_7)
    _a_8=(_a_0.ptr_base)
    (_a_0.i32)[(_a_0.shape_base)] = self.__mdimi
    (_a_0.i32)[((_a_0.shape_base) + 1)] = self.__mdimj
    _a_9=(_a_0.nidxs_base)
    _a_10=(_a_0.sp_base)
    _a_11=(_a_0.cof_base)
    _a_12=(_a_0.i32)
    _a_13=(_a_0.i64)
    _a_14=(_a_0.f64)
    fragments._c_closure_494(_a_11,_a_14,_a_7,_a_12,_a_13,self.__mcof,self.__mdimj,self.__msubi,self.__msubj,_a_5,_a_9,_a_6,_a_8,_a_10,_a_4) 
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulScalarVar(M(")._a_I(self.__mdimi)._a_S(",")._a_I(self.__mdimj)._a_S("), ")._a_S(self.__x._toString_())._a_S(")")._toString_())
 return ExprMulScalarVar
mosek_fusion_ExprMulScalarVar=__mk_mosek_fusion_ExprMulScalarVar()
del __mk_mosek_fusion_ExprMulScalarVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVarScalarConst():
 class ExprMulVarScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVarScalarConst__c','_ExprMulVarScalarConst__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2D(*args):
      self._ctor_init_Lmosek_4fusion_4Variable_2D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVarScalarConst.ctor(mosek.fusion.Variable,double)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulVarScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprMulVarScalarConst.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulVarScalarConst'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2D(x,c):
    o = ExprMulVarScalarConst.__new__(ExprMulVarScalarConst)
    o._ctor_init_Lmosek_4fusion_4Variable_2D(x,c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_D__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_D__(c))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2D(self,x,c):
    self._ctor_init_Lmosek_4fusion_4Variable_2D(x,numpy.float64(c))
  def _ctor_init_Lmosek_4fusion_4Variable_2D(self,x,c):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,x._getModel_(),x._getShape_())
   (self.__x) = x
   (self.__c) = c
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=self.__x._numInst_()
   _a_4=_a_3
   _a_5=self.__x._getShape_()
   _a_6=int((_a_5).shape[0])
   _a_7=(mosek.fusion.Set._size__3I(_a_5) > _a_4)
   _a_0._alloc_1expr_IIIZ(_a_6,_a_4,_a_3,_a_7)
   _a_8=(_a_0.ptr_base)
   _a_9=(_a_0.nidxs_base)
   _a_10=(_a_0.sp_base)
   _a_11=(_a_0.cof_base)
   _a_12=(_a_0.shape_base)
   if _a_7:
    self.__x._inst_I_3JI_3J(_a_10,(_a_0.i64),_a_9,(_a_0.i64))
   else:
    self.__x._inst_I_3J(_a_9,(_a_0.i64))
   _a_13=(_a_0.i32)
   _a_14=(_a_0.i64)
   _a_15=(_a_0.f64)
   fragments._c_closure_495(_a_11,_a_15,_a_13,_a_6,_a_4,_a_3,_a_8,_a_12,_a_5) 
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulVarScalarConst()")
 return ExprMulVarScalarConst
mosek_fusion_ExprMulVarScalarConst=__mk_mosek_fusion_ExprMulVarScalarConst()
del __mk_mosek_fusion_ExprMulVarScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprSumReduceEnd():
 class ExprSumReduceEnd(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSumReduceEnd__ndim','_ExprSumReduceEnd__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ILmosek_4fusion_4Expression_2(*args):
      self._ctor_init_ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSumReduceEnd.ctor(int32,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSumReduceEnd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprSumReduceEnd._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSumReduceEnd._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduceEnd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSumReduceEnd.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprSumReduceEnd._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprSumReduceEnd._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduceEnd.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSumReduceEnd'
  @staticmethod
  def _ctor_ILmosek_4fusion_4Expression_2(ndim,expr):
    o = ExprSumReduceEnd.__new__(ExprSumReduceEnd)
    o._ctor_init_ILmosek_4fusion_4Expression_2(ndim,expr)
    return o
  @staticmethod
  def __match_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    ndim,expr, = args
    return (__arg_match_I__(ndim) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    ndim,expr, = args
    return (__arg_alt_match_I__(ndim) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_ILmosek_4fusion_4Expression_2(self,ndim,expr):
    self._ctor_init_ILmosek_4fusion_4Expression_2(numpy.int32(ndim),expr)
  def _ctor_init_ILmosek_4fusion_4Expression_2(self,ndim,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprSumReduceEnd.__computeShape_I_3I(ndim,expr._getShape_()))
   (self.__expr) = expr
   (self.__ndim) = ndim
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.hassp)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=1
   _a_19 = fragments._c_closure_496(_a_19,_a_3,self.__ndim,_a_4,_a_16)
   _a_19 = numpy.int64(_a_19) # postprocess
   _a_20=1
   _a_20 = fragments._c_closure_497(_a_20,_a_3,self.__ndim,_a_4,_a_16)
   _a_20 = numpy.int64(_a_20) # postprocess
   if _a_8:
    _a_21=0
    _a_21 = fragments._c_closure_498(_a_20,_a_5,_a_21,_a_10,_a_17)
    _a_21 = numpy.int32(_a_21) # postprocess
    _a_22=_a_6
    _a_23=(_a_3 - self.__ndim)
    _a_24=_a_7
    _a_25=1
    _a_25 = fragments._c_closure_499(_a_3,self.__ndim,_a_25,_a_4,_a_16)
    _a_25 = numpy.int64(_a_25) # postprocess
    _a_26=(_a_21 < _a_25)
    _a_0._alloc_1expr_IIIZI(_a_23,_a_21,_a_22,_a_26,_a_24)
    _a_27=(_a_0.ptr_base)
    _a_28=(_a_0.nidxs_base)
    _a_29=((_a_0.sp_base) if (_a_26 ) else _a_0._alloci64_I(_a_21))
    _a_30=(_a_0.cof_base)
    _a_31=(_a_0.shape_base)
    _a_32=(_a_0.code_base)
    _a_33=(_a_0.codeptr_base)
    _a_34=(_a_0.cconst_base)
    _a_35=(_a_0.i32)
    _a_36=(_a_0.i64)
    _a_37=(_a_0.f64)
    _a_38=0
    _a_39=0
    _a_40=0
    _a_35[_a_27] = 0
    fragments._c_closure_500(_a_35,_a_23,_a_31,_a_4,_a_16) 
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_17,_a_11,_a_36,_a_28,_a_6)
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_18,_a_12,_a_37,_a_30,_a_6)
    if (_a_24 > 0):
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_16,_a_13,_a_35,_a_32,_a_24)
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_18,_a_15,_a_37,_a_34,_a_24)
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_16,_a_14,_a_35,_a_33,(_a_6 + 1))
    _a_41=0
    _a_41 = fragments._c_closure_501(_a_20,_a_5,_a_9,_a_26,_a_35,_a_36,_a_21,_a_27,_a_29,_a_41,_a_10,_a_16,_a_17)
    _a_41 = numpy.int32(_a_41) # postprocess
   else:
    _a_42=numpy.int32(_a_19)
    _a_43=_a_6
    _a_44=_a_7
    _a_45=(_a_3 - self.__ndim)
    _a_0._alloc_1expr_IIIZI(_a_45,_a_42,_a_43,False,_a_44)
    _a_46=(_a_0.ptr_base)
    _a_47=(_a_0.nidxs_base)
    _a_48=(_a_0.cof_base)
    _a_49=(_a_0.shape_base)
    _a_50=(_a_0.code_base)
    _a_51=(_a_0.codeptr_base)
    _a_52=(_a_0.cconst_base)
    _a_53=(_a_0.i32)
    _a_54=(_a_0.i64)
    _a_55=(_a_0.f64)
    _a_56=0
    fragments._c_closure_502(_a_53,_a_45,_a_49,_a_4,_a_16) 
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_17,_a_11,_a_54,_a_47,_a_6)
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_18,_a_12,_a_55,_a_48,_a_6)
    if (_a_44 > 0):
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_16,_a_13,_a_53,_a_50,_a_44)
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_18,_a_15,_a_55,_a_52,_a_44)
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_16,_a_14,_a_53,_a_51,(_a_6 + 1))
    _a_53[_a_46] = 0
    fragments._c_closure_503(_a_20,_a_53,_a_42,_a_46) 
  @staticmethod
  def __computeShape_alt_I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprSumReduceEnd.__computeShape_I_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __computeShape_I_3I(_a_0,_a_1):
   if (int((_a_1).shape[0]) <= _a_0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid summing dimension")
   _a_2=numpy.zeros(((int((_a_1).shape[0]) - _a_0),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_504(_a_2,_a_1) 
   return (_a_2)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSumReduceEnd(")._a_I(self.__ndim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSumReduceEnd
mosek_fusion_ExprSumReduceEnd=__mk_mosek_fusion_ExprSumReduceEnd()
del __mk_mosek_fusion_ExprSumReduceEnd
#BEFORE CLASS
def __mk_mosek_fusion_ExprAdd():
 class ExprAdd(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprAdd__m2','_ExprAdd__m1','_ExprAdd__e2','_ExprAdd__e1']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprAdd.ctor(mosek.fusion.Expression,mosek.fusion.Expression,double,double)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprAdd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprAdd._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprAdd._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprAdd.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprAdd._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprAdd._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.toString()')
  def __repr__(self): return 'mosek.fusion.ExprAdd'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2):
    o = ExprAdd.__new__(ExprAdd)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_match_D__(m1) and __arg_match_D__(m2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_alt_match_D__(m1) and __arg_alt_match_D__(m2))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,numpy.float64(m1),numpy.float64(m2))
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(e1,e2),e1._getShape_())
   (self.__e1) = e1
   (self.__e2) = e2
   (self.__m1) = m1
   (self.__m2) = m2
   if (e1._getND_()!=e2._getND_()):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _a_0 in range(0,e1._getND_()):
    if (e1._getDim_I(_a_0)!=e2._getDim_I(_a_0)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__e1._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   self.__e2._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.hassp)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_1._pop_1expr_()
   _a_16=(_a_1.nd)
   _a_17=(_a_1.shape_base)
   _a_18=(_a_1.nelem)
   _a_19=(_a_1.nnz)
   _a_20=(_a_1.ncodeatom)
   _a_21=(_a_1.hassp)
   _a_22=(_a_1.ptr_base)
   _a_23=(_a_1.sp_base)
   _a_24=(_a_1.nidxs_base)
   _a_25=(_a_1.cof_base)
   _a_26=(_a_1.code_base)
   _a_27=(_a_1.codeptr_base)
   _a_28=(_a_1.cconst_base)
   _a_29=(_a_1.i32)
   _a_30=(_a_1.i64)
   _a_31=(_a_1.f64)
   _a_32=((_a_20 > 0) or (_a_7 > 0))
   if (_a_16!=_a_3):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _a_33 in range(0,_a_16):
    if (_a_29[(_a_17 + _a_33)]!=_a_29[(_a_4 + _a_33)]):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   if ((not _a_21) and (not _a_8)):
    _a_34=_a_18
    _a_35=(_a_19 + _a_6)
    _a_36=0
    if _a_32:
     _a_36 += ((_a_20 + (_a_19 * 2)) if ((_a_20 > 0) ) else _a_19)
     _a_36 += ((_a_7 + (_a_6 * 2)) if ((_a_7 > 0) ) else _a_6)
    _a_37=_a_16
    _a_0._alloc_1expr_IIIZI(_a_37,_a_34,_a_35,False,_a_36)
    _a_38=(_a_0.shape_base)
    _a_39=(_a_0.ptr_base)
    _a_40=(_a_0.sp_base)
    _a_41=(_a_0.nidxs_base)
    _a_42=(_a_0.cof_base)
    _a_43=(_a_0.code_base)
    _a_44=(_a_0.codeptr_base)
    _a_45=(_a_0.cconst_base)
    _a_46=(_a_0.i32)
    _a_47=(_a_0.i64)
    _a_48=(_a_0.f64)
    fragments._c_closure_505(_a_46,_a_37,_a_38,_a_17,_a_29) 
    _a_49=0
    _a_50=0
    if (_a_36 > 0):
     _a_46[_a_44] = 0
    _a_46[_a_39] = 0
    _a_49,_a_50 = fragments._c_closure_506(_a_28,_a_15,_a_26,_a_13,_a_49,_a_27,_a_14,_a_25,_a_12,_a_50,self.__m1,self.__m2,_a_20,_a_7,_a_24,_a_11,_a_22,_a_9,_a_45,_a_43,_a_44,_a_42,_a_48,_a_46,_a_47,_a_36,_a_34,_a_41,_a_39,_a_31,_a_29,_a_30)
    _a_49 = numpy.int32(_a_49) # postprocess
    _a_50 = numpy.int32(_a_50) # postprocess
   elif ((not _a_21) or (not _a_8)):
    if (not _a_8):
     _a_51=_a_5
     _a_52=_a_6
     _a_53=_a_9
     _a_54=_a_10
     _a_55=_a_11
     _a_56=_a_7
     _a_57=_a_14
     _a_58=_a_13
     _a_59=_a_15
     _a_60=_a_12
     _a_5 = _a_18
     _a_6 = _a_19
     _a_9 = _a_22
     _a_10 = _a_23
     _a_11 = _a_24
     _a_7 = _a_20
     _a_14 = _a_27
     _a_13 = _a_26
     _a_15 = _a_28
     _a_12 = _a_25
     _a_18 = _a_51
     _a_19 = _a_52
     _a_22 = _a_53
     _a_23 = _a_54
     _a_24 = _a_55
     _a_20 = _a_56
     _a_27 = _a_57
     _a_26 = _a_58
     _a_28 = _a_59
     _a_25 = _a_60
    _a_61=((self.__m1) if ((not _a_21) ) else (self.__m2))
    _a_62=((self.__m2) if ((not _a_21) ) else (self.__m1))
    _a_63=_a_18
    _a_64=(_a_19 + _a_6)
    _a_65=_a_16
    _a_66=(_a_20 + _a_7)
    if _a_32:
     _a_66 += ((2 * _a_19) if ((_a_20 > 0) ) else _a_19)
     _a_66 += ((2 * _a_6) if ((_a_7 > 0) ) else _a_6)
    _a_0._alloc_1expr_IIIZI(_a_65,_a_63,_a_64,False,_a_66)
    _a_67=(_a_0.shape_base)
    _a_68=(_a_0.ptr_base)
    _a_69=(_a_0.sp_base)
    _a_70=(_a_0.nidxs_base)
    _a_71=(_a_0.cof_base)
    _a_72=(_a_0.code_base)
    _a_73=(_a_0.codeptr_base)
    _a_74=(_a_0.cconst_base)
    _a_75=(_a_0.i32)
    _a_76=(_a_0.i64)
    _a_77=(_a_0.f64)
    _a_78=0
    _a_79=0
    _a_80=0
    fragments._c_closure_507(_a_75,_a_65,_a_67,_a_17,_a_29) 
    _a_75[_a_68] = 0
    if (_a_66 > 0):
     _a_75[_a_73] = 0
    _a_81=0
    _a_78,_a_79,_a_81,_a_80 = fragments._c_closure_508(_a_28,_a_15,_a_26,_a_13,_a_78,_a_27,_a_14,_a_25,_a_12,_a_79,_a_81,_a_61,_a_62,_a_20,_a_7,_a_18,_a_5,_a_24,_a_11,_a_80,_a_22,_a_9,_a_74,_a_72,_a_73,_a_71,_a_77,_a_75,_a_76,_a_66,_a_70,_a_68,_a_10,_a_31,_a_29,_a_30)
    _a_78 = numpy.int32(_a_78) # postprocess
    _a_79 = numpy.int32(_a_79) # postprocess
    _a_81 = numpy.int32(_a_81) # postprocess
    _a_80 = numpy.int32(_a_80) # postprocess
    if (_a_79!=_a_63):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nelem")
    if (_a_80!=_a_64):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
    if (_a_78!=_a_66):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid codei")
   else:
    _a_82=(_a_19 + _a_6)
    _a_83=0
    _a_84=_a_16
    _a_85=(_a_20 + _a_7)
    if _a_32:
     _a_85 += ((2 * _a_19) if ((_a_20 > 0) ) else _a_19)
     _a_85 += ((2 * _a_6) if ((_a_7 > 0) ) else _a_6)
    _a_86=1
    _a_86 = fragments._c_closure_509(_a_84,_a_17,_a_86,_a_29)
    _a_86 = numpy.int64(_a_86) # postprocess
    _a_83 = fragments._c_closure_510(_a_18,_a_5,_a_83,_a_23,_a_10,_a_30)
    _a_83 = numpy.int32(_a_83) # postprocess
    _a_87=(_a_83 < _a_86)
    _a_0._alloc_1expr_IIIZI(_a_84,_a_83,_a_82,_a_87,_a_85)
    _a_88=(_a_0.shape_base)
    _a_89=(_a_0.ptr_base)
    _a_90=((_a_0.sp_base) if (_a_87 ) else _a_0._alloci64_I(_a_83))
    _a_91=(_a_0.nidxs_base)
    _a_92=(_a_0.cof_base)
    _a_93=(_a_0.code_base)
    _a_94=(_a_0.codeptr_base)
    _a_95=(_a_0.cconst_base)
    _a_96=(_a_0.i32)
    _a_97=(_a_0.i64)
    _a_98=(_a_0.f64)
    fragments._c_closure_511(_a_96,_a_84,_a_88,_a_17,_a_29) 
    fragments._c_closure_512(_a_28,_a_15,_a_26,_a_13,_a_27,_a_14,_a_25,_a_12,self.__m1,self.__m2,_a_20,_a_7,_a_18,_a_5,_a_24,_a_11,_a_22,_a_9,_a_95,_a_93,_a_94,_a_92,_a_98,_a_96,_a_97,_a_85,_a_91,_a_89,_a_90,_a_23,_a_10,_a_31,_a_29,_a_30) 
    if (not _a_87):
     _a_0._popi64_I(_a_83)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprAdd(")._a_S(self.__e1._toString_())._a_S(",")._a_S(self.__e2._toString_())._a_S("; ")._a_D(self.__m1)._a_S(",")._a_D(self.__m2)._a_S(")")._toString_())
 return ExprAdd
mosek_fusion_ExprAdd=__mk_mosek_fusion_ExprAdd()
del __mk_mosek_fusion_ExprAdd
#BEFORE CLASS
def __mk_mosek_fusion_ExprWSum():
 class ExprWSum(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprWSum__w','_ExprWSum__es']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
      self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprWSum.ctor(array(mosek.fusion.Expression,ndim=1),array(double,ndim=1))')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprWSum.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprWSum._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprWSum._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprWSum.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprWSum._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprWSum._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.toString()')
  def __repr__(self): return 'mosek.fusion.ExprWSum'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2_3D(es,w):
    o = ExprWSum.__new__(ExprWSum)
    o._ctor_init__3Lmosek_4fusion_4Expression_2_3D(es,w)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_match__3D__(w))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_alt_match__3D__(w))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
    self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(numpy.array(es,dtype=numpy.dtype(object)),numpy.array(w,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,mosek.fusion.BaseExpression._modelFrom__3Lmosek_4fusion_4Expression_2(es),es[0]._getShape_())
   if (int((w).shape[0])!=int((es).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching weights and expressions array lengths")
   (self.__w) = mosek.fusion.Utils.Tools._arraycopy__3D(w)
   _a_0=es[0]._getShape_()
   _a_1=int((_a_0).shape[0])
   for _a_2 in range(1,int((es).shape[0])):
    _a_3=es[_a_2]._getShape_()
    if (_a_1!=int((_a_3).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
    else:
     for _a_4 in range(0,_a_1):
      if (_a_0[_a_4]!=_a_3[_a_4]):
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
   (self.__es) = numpy.array([es[_a_5] for _a_5 in range(0,int((es).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=int((self.__es).shape[0])
   for _a_4 in range(0,_a_3):
    self.__es[_a_4]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_9=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_10=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_11=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_12=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_13=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_14=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_15=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_16=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_17=numpy.zeros((_a_3,), dtype=numpy.dtype(bool))
   for _a_18 in range(0,_a_3):
    _a_1._pop_1expr_()
    _a_5[((_a_3 - 1) - _a_18)] = (_a_1.nd)
    _a_6[((_a_3 - 1) - _a_18)] = (_a_1.nelem)
    _a_7[((_a_3 - 1) - _a_18)] = (_a_1.nnz)
    _a_8[((_a_3 - 1) - _a_18)] = (_a_1.ncodeatom)
    _a_9[((_a_3 - 1) - _a_18)] = (_a_1.ptr_base)
    _a_11[((_a_3 - 1) - _a_18)] = (_a_1.sp_base)
    _a_10[((_a_3 - 1) - _a_18)] = (_a_1.nidxs_base)
    _a_12[((_a_3 - 1) - _a_18)] = (_a_1.cof_base)
    _a_13[((_a_3 - 1) - _a_18)] = (_a_1.shape_base)
    _a_14[((_a_3 - 1) - _a_18)] = (_a_1.code_base)
    _a_15[((_a_3 - 1) - _a_18)] = (_a_1.codeptr_base)
    _a_16[((_a_3 - 1) - _a_18)] = (_a_1.cconst_base)
    _a_17[((_a_3 - 1) - _a_18)] = (_a_1.hassp)
   _a_19=(_a_1.i32)
   _a_20=(_a_1.i64)
   _a_21=(_a_1.f64)
   _a_22=True
   _a_22 = fragments._c_closure_513(_a_3,_a_5,_a_22,_a_13,_a_19)
   if (not _a_22):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   _a_23=numpy.array([_a_19[(_a_13[0] + _a_24)] for _a_24 in range(0,_a_5[0])], dtype=numpy.dtype(numpy.int32))
   _a_25=False
   for _a_26 in range(0,_a_3):
    if (not _a_17[_a_26]):
     _a_25 = True
   _a_27=False
   _a_27 = fragments._c_closure_514(_a_27,_a_3,_a_8)
   _a_28=0
   _a_29=0
   _a_30=0
   if _a_25:
    _a_29 = numpy.int32(mosek.fusion.Set._size__3I(_a_23))
    _a_28,_a_30 = fragments._c_closure_515(_a_27,_a_3,_a_8,_a_7,_a_28,_a_30)
    _a_28 = numpy.int32(_a_28) # postprocess
    _a_30 = numpy.int32(_a_30) # postprocess
   else:
    _a_28,_a_29,_a_30 = fragments._c_closure_516(_a_27,_a_3,_a_8,_a_6,_a_7,_a_28,_a_29,_a_30,_a_11,_a_20)
    _a_28 = numpy.int32(_a_28) # postprocess
    _a_29 = numpy.int32(_a_29) # postprocess
    _a_30 = numpy.int32(_a_30) # postprocess
   _a_0._alloc_1expr_IIIZI(_a_5[0],_a_29,_a_30,(not _a_25),_a_28)
   _a_31=(_a_0.ptr_base)
   _a_32=(_a_0.nidxs_base)
   _a_33=(_a_0.sp_base)
   _a_34=(_a_0.shape_base)
   _a_35=(_a_0.cof_base)
   _a_36=(_a_0.code_base)
   _a_37=(_a_0.codeptr_base)
   _a_38=(_a_0.cconst_base)
   _a_39=(_a_0.i32)
   _a_40=(_a_0.i64)
   _a_41=(_a_0.f64)
   fragments._c_closure_517(_a_5,_a_39,_a_34,_a_13,_a_19) 
   if (_a_28 > 0):
    _a_39[_a_37] = 0
   fragments._c_closure_518(_a_39,_a_29,_a_31) 
   if _a_25:
    _a_42=(- 9999)
    if (_a_28 > 0):
     _a_42 = _a_2._alloci32_I((_a_29 + 1))
    _a_43=(_a_2.i32)
    fragments._c_closure_519(_a_28,_a_29,_a_42,_a_43) 
    for _a_44 in range(0,_a_3):
     if _a_17[_a_44]:
      fragments._c_closure_520(_a_27,_a_15,_a_44,_a_8,_a_6,_a_9,_a_39,_a_31,_a_11,_a_19,_a_20,_a_42,_a_43) 
     else:
      fragments._c_closure_521(_a_27,_a_15,_a_44,_a_8,_a_6,_a_9,_a_39,_a_31,_a_19,_a_42,_a_43) 
    fragments._c_closure_522(_a_39,_a_29,_a_31) 
    fragments._c_closure_523(_a_28,_a_29,_a_42,_a_43) 
    for _a_45 in range(0,_a_3):
     if _a_17[_a_45]:
      fragments._c_closure_524(_a_27,_a_16,_a_14,_a_15,_a_12,_a_45,_a_8,_a_6,_a_10,_a_9,_a_38,_a_36,_a_37,_a_35,_a_41,_a_39,_a_40,_a_32,_a_31,_a_11,self.__w,_a_21,_a_19,_a_20,_a_42,_a_43) 
     else:
      fragments._c_closure_525(_a_27,_a_16,_a_14,_a_15,_a_12,_a_45,_a_8,_a_6,_a_10,_a_9,_a_38,_a_36,_a_37,_a_35,_a_41,_a_39,_a_40,_a_32,_a_31,self.__w,_a_21,_a_19,_a_20,_a_42,_a_43) 
    fragments._c_closure_526(_a_39,_a_29,_a_31) 
    _a_39[_a_31] = 0
   else:
    fragments._c_closure_527(_a_27,_a_16,_a_14,_a_15,_a_12,_a_3,_a_8,_a_6,_a_10,_a_9,_a_38,_a_36,_a_37,_a_35,_a_41,_a_39,_a_40,_a_32,_a_31,_a_33,_a_11,self.__w,_a_21,_a_19,_a_20) 
   _a_2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()._a_S("ExprWSum([")
   _a_0._a_S(self.__es[0]._toString_())
   for _a_1 in range(1,int((self.__es).shape[0])):
    _a_0._a_S(",")._a_S(self.__es[_a_1]._toString_())
   _a_0._a_S("])")
   return (_a_0._toString_())
 return ExprWSum
mosek_fusion_ExprWSum=__mk_mosek_fusion_ExprWSum()
del __mk_mosek_fusion_ExprWSum
#BEFORE CLASS
def __mk_mosek_fusion_ExprSumReduce():
 class ExprSumReduce(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSumReduce__dim','_ExprSumReduce__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ILmosek_4fusion_4Expression_2(*args):
      self._ctor_init_ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSumReduce.ctor(int32,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSumReduce.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSumReduce.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSumReduce'
  @staticmethod
  def _ctor_ILmosek_4fusion_4Expression_2(dim,expr):
    o = ExprSumReduce.__new__(ExprSumReduce)
    o._ctor_init_ILmosek_4fusion_4Expression_2(dim,expr)
    return o
  @staticmethod
  def __match_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_match_I__(dim) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_alt_match_I__(dim) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
    self._ctor_init_ILmosek_4fusion_4Expression_2(numpy.int32(dim),expr)
  def _ctor_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),mosek.fusion.ExprSumReduce.__computeShape_I_3I(dim,expr._getShape_()))
   (self.__expr) = expr
   (self.__dim) = dim
   _a_0=expr._getShape_()
   if (int((_a_0).shape[0]) <= dim):
    raise mosek_fusion_DimensionError._ctor_S("Invalid summing dimension")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.shape_base)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.nnz)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.hassp)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.sp_base)
   _a_11=(_a_1.nidxs_base)
   _a_12=(_a_1.cof_base)
   _a_13=(_a_1.code_base)
   _a_14=(_a_1.codeptr_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=99999
   _a_20=99999
   _a_21=99999
   if _a_8:
    _a_22=0
    _a_22 = fragments._c_closure_528(_a_22,_a_3,_a_4,_a_16)
    _a_22 = numpy.int32(_a_22) # postprocess
    _a_19 = _a_2._alloci32_I((_a_22 + 1))
    _a_20 = _a_2._alloci32_I(_a_5)
    _a_21 = _a_2._alloci32_I(_a_5)
   _a_23=(_a_2.i32)
   if _a_8:
    _a_24=_a_20
    _a_25=_a_21
    fragments._c_closure_529(_a_24,_a_5,_a_23) 
    _a_24,_a_25 = fragments._c_closure_530(_a_24,self.__dim,_a_3,_a_5,_a_19,_a_4,_a_10,_a_25,_a_16,_a_17,_a_23)
    _a_24 = numpy.int32(_a_24) # postprocess
    _a_25 = numpy.int32(_a_25) # postprocess
    _a_26=1
    _a_26 = fragments._c_closure_531(_a_26,self.__dim,_a_4,_a_16)
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_27=_a_16[(_a_4 + self.__dim)]
    _a_28=1
    _a_28 = fragments._c_closure_532(_a_28,self.__dim,_a_3,_a_4,_a_16)
    _a_28 = numpy.int32(_a_28) # postprocess
    _a_29=(_a_28 * _a_27)
    _a_30=_a_28
    _a_31=1
    _a_32=0
    _a_33=(- 1)
    _a_34=(- 1)
    _a_34,_a_33,_a_32 = fragments._c_closure_533(_a_24,_a_26,_a_28,_a_5,_a_34,_a_33,_a_32,_a_29,_a_10,_a_17,_a_23)
    _a_34 = numpy.int64(_a_34) # postprocess
    _a_33 = numpy.int64(_a_33) # postprocess
    _a_32 = numpy.int32(_a_32) # postprocess
    _a_35=(_a_3 - 1)
    _a_36=(_a_32 < (_a_26 * _a_28))
    _a_37=_a_6
    _a_38=_a_7
    _a_0._alloc_1expr_IIIZI(_a_35,_a_32,_a_37,_a_36,_a_38)
    _a_39=(_a_0.ptr_base)
    _a_40=(_a_0.nidxs_base)
    _a_41=((_a_0.sp_base) if (_a_36 ) else _a_0._alloci64_I(_a_32))
    _a_42=(_a_0.cof_base)
    _a_43=(_a_0.shape_base)
    _a_44=(_a_0.code_base)
    _a_45=(_a_0.codeptr_base)
    _a_46=(_a_0.cconst_base)
    _a_47=(_a_0.i32)
    _a_48=(_a_0.i64)
    _a_49=(_a_0.f64)
    fragments._c_closure_534(self.__dim,_a_47,_a_43,_a_4,_a_16) 
    fragments._c_closure_535(self.__dim,_a_3,_a_47,_a_43,_a_4,_a_16) 
    _a_47[_a_39] = 0
    if (_a_38 > 0):
     _a_47[_a_45] = 0
    _a_50=0
    _a_51=0
    _a_52=0
    _a_53=0
    _a_50,_a_53,_a_51,_a_52 = fragments._c_closure_536(_a_15,_a_13,_a_50,_a_14,_a_12,_a_24,_a_26,_a_28,_a_53,_a_51,_a_52,_a_5,_a_11,_a_9,_a_46,_a_44,_a_45,_a_42,_a_49,_a_47,_a_48,_a_38,_a_40,_a_39,_a_41,_a_29,_a_10,_a_18,_a_16,_a_17,_a_23)
    _a_50 = numpy.int32(_a_50) # postprocess
    _a_53 = numpy.int32(_a_53) # postprocess
    _a_51 = numpy.int32(_a_51) # postprocess
    _a_52 = numpy.int32(_a_52) # postprocess
    if (not _a_36):
     _a_0._popi64_I(_a_32)
   else:
    _a_54=1
    _a_54 = fragments._c_closure_537(_a_54,self.__dim,_a_4,_a_16)
    _a_54 = numpy.int32(_a_54) # postprocess
    _a_55=_a_16[(_a_4 + self.__dim)]
    _a_56=1
    _a_56 = fragments._c_closure_538(_a_56,self.__dim,_a_3,_a_4,_a_16)
    _a_56 = numpy.int32(_a_56) # postprocess
    _a_57=(_a_56 * _a_55)
    _a_58=_a_56
    _a_59=1
    _a_60=(_a_54 * _a_56)
    _a_61=_a_6
    _a_62=_a_7
    _a_0._alloc_1expr_IIIZI((_a_3 - 1),_a_60,_a_61,False,_a_62)
    _a_63=(_a_0.ptr_base)
    _a_64=(_a_0.nidxs_base)
    _a_65=(_a_0.cof_base)
    _a_66=(_a_0.shape_base)
    _a_67=(_a_0.code_base)
    _a_68=(_a_0.codeptr_base)
    _a_69=(_a_0.cconst_base)
    _a_70=(_a_0.i32)
    _a_71=(_a_0.i64)
    _a_72=(_a_0.f64)
    fragments._c_closure_539(self.__dim,_a_70,_a_66,_a_4,_a_16) 
    fragments._c_closure_540(self.__dim,_a_3,_a_70,_a_66,_a_4,_a_16) 
    _a_73=0
    _a_74=0
    _a_70[_a_63] = 0
    if (_a_62 > 0):
     _a_70[_a_68] = 0
    _a_75=0
    _a_75,_a_73,_a_74 = fragments._c_closure_541(_a_15,_a_13,_a_75,_a_14,_a_12,_a_54,_a_55,_a_56,_a_73,_a_74,_a_11,_a_9,_a_69,_a_67,_a_68,_a_65,_a_72,_a_70,_a_71,_a_62,_a_64,_a_63,_a_57,_a_58,_a_18,_a_16,_a_17)
    _a_75 = numpy.int32(_a_75) # postprocess
    _a_73 = numpy.int32(_a_73) # postprocess
    _a_74 = numpy.int32(_a_74) # postprocess
   _a_2._clear_()
  @staticmethod
  def __computeShape_alt_I_3I(_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_ExprSumReduce.__computeShape_I_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __computeShape_I_3I(_a_0,_a_1):
   _a_2=numpy.zeros(((int((_a_1).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_542(_a_0,_a_2,_a_1) 
   fragments._c_closure_543(_a_0,_a_2,_a_1) 
   return (_a_2)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSumReduce(")._a_I(self.__dim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSumReduce
mosek_fusion_ExprSumReduce=__mk_mosek_fusion_ExprSumReduce()
del __mk_mosek_fusion_ExprSumReduce
#BEFORE CLASS
def __mk_mosek_fusion_ExprScaleVecPSD():
 class ExprScaleVecPSD(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprScaleVecPSD__dim1','_ExprScaleVecPSD__dim0','_ExprScaleVecPSD__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args):
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprScaleVecPSD.ctor(int32,int32,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprScaleVecPSD.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprScaleVecPSD._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprScaleVecPSD._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScaleVecPSD.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprScaleVecPSD'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0,dim1,expr):
    o = ExprScaleVecPSD.__new__(ExprScaleVecPSD)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0,dim1,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0,dim1,expr, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0,dim1,expr, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0,dim1,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0),numpy.int32(dim1),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0,dim1,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
   (self.__dim0) = dim0
   (self.__dim1) = dim1
   if ((dim0 < 0) or ((dim1 < 0) or (dim0==dim1))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nnz)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.code_base)
   _a_11=(_a_1.codeptr_base)
   _a_12=(_a_1.cconst_base)
   _a_13=(_a_1.nidxs_base)
   _a_14=(_a_1.sp_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   if ((self.__dim0 >= _a_3) or (self.__dim1 >= _a_3)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
   elif (_a_16[(_a_8 + self.__dim0)]!=_a_16[(_a_8 + self.__dim1)]):
    raise mosek_fusion_DimensionError._ctor_S("Not symmetric in given dimensions")
   _a_19=1
   _a_20=1
   _a_21=1
   _a_22=1
   _a_23=1
   _a_24=(self.__dim0 if ((self.__dim0 < self.__dim1) ) else self.__dim1)
   _a_25=(self.__dim1 if ((self.__dim0 < self.__dim1) ) else self.__dim0)
   _a_23 = fragments._c_closure_544(_a_23,_a_8,_a_16,_a_24)
   _a_23 = numpy.int64(_a_23) # postprocess
   _a_21 = fragments._c_closure_545(_a_21,_a_8,_a_16,_a_24,_a_25)
   _a_21 = numpy.int64(_a_21) # postprocess
   _a_19 = fragments._c_closure_546(_a_19,_a_3,_a_8,_a_16,_a_25)
   _a_19 = numpy.int64(_a_19) # postprocess
   _a_22 = _a_16[(_a_8 + self.__dim0)]
   _a_20 = _a_22
   _a_26=(0 if ((_a_6==0) ) else (_a_6 + (_a_4 * 2)))
   _a_0._alloc_1expr_IIIZI(_a_3,_a_5,_a_4,_a_7,_a_26)
   _a_27=(_a_0.ptr_base)
   _a_28=(_a_0.shape_base)
   _a_29=(_a_0.nidxs_base)
   _a_30=(_a_0.sp_base)
   _a_31=(_a_0.cof_base)
   _a_32=(_a_0.code_base)
   _a_33=(_a_0.codeptr_base)
   _a_34=(_a_0.cconst_base)
   _a_35=(_a_0.i32)
   _a_36=(_a_0.i64)
   _a_37=(_a_0.f64)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_16,_a_9,_a_35,_a_27,(_a_5 + 1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_a_16,_a_8,_a_35,_a_28,_a_3)
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_17,_a_13,_a_36,_a_29,_a_4)
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_a_18,_a_15,_a_37,_a_31,_a_4)
   if _a_7:
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_a_17,_a_14,_a_36,_a_30,_a_5)
   _a_38=mosek.fusion.Utils.Tools._sqrt_D(2)
   fragments._c_closure_547(_a_23,_a_22,_a_21,_a_20,_a_19,_a_7,_a_5,_a_31,_a_37,_a_35,_a_27,_a_38,_a_14,_a_17) 
   fragments._c_closure_548(_a_12,_a_10,_a_11,_a_23,_a_22,_a_21,_a_20,_a_19,_a_7,_a_6,_a_5,_a_9,_a_34,_a_32,_a_33,_a_37,_a_35,_a_38,_a_14,_a_18,_a_16,_a_17) 
 return ExprScaleVecPSD
mosek_fusion_ExprScaleVecPSD=__mk_mosek_fusion_ExprScaleVecPSD()
del __mk_mosek_fusion_ExprScaleVecPSD
#BEFORE CLASS
def __mk_mosek_fusion_ExprDenseTril():
 class ExprDenseTril(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDenseTril__dim1','_ExprDenseTril__dim0','_ExprDenseTril__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args):
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDenseTril.ctor(int32,int32,mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDenseTril.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDenseTril.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDenseTril'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
   (self.__dim0) = dim0
   (self.__dim1) = dim1
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprDenseTril._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _a_0=expr._getShape_()
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= int((_a_0).shape[0])) or ((self.__dim1 < 0) or ((self.__dim1 >= int((_a_0).shape[0])) or (_a_0[self.__dim0]!=_a_0[self.__dim1])))))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nnz)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.code_base)
   _a_11=(_a_1.codeptr_base)
   _a_12=(_a_1.cconst_base)
   _a_13=(_a_1.nidxs_base)
   _a_14=(_a_1.sp_base)
   _a_15=(_a_1.cof_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=(self.__dim0 if ((self.__dim0 < self.__dim1) ) else self.__dim1)
   _a_20=(self.__dim0 if ((self.__dim0 > self.__dim1) ) else self.__dim1)
   _a_21=(self.__dim0 < self.__dim1)
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= _a_3) or ((self.__dim1 < 0) or (self.__dim1 >= _a_3))))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
   elif (_a_16[(_a_8 + self.__dim0)]!=_a_16[(_a_8 + self.__dim1)]):
    raise mosek_fusion_DimensionError._ctor_S("Not symmetric in given dimensions")
   _a_22=numpy.array([1 for _a_23 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_549(_a_22,_a_8,_a_16,_a_19) 
   _a_22[1] = _a_16[(_a_8 + self.__dim0)]
   fragments._c_closure_550(_a_22,_a_8,_a_16,_a_19,_a_20) 
   _a_22[3] = _a_16[(_a_8 + self.__dim1)]
   fragments._c_closure_551(_a_22,_a_3,_a_8,_a_16,_a_20) 
   _a_24=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _a_24[4] = 1
   fragments._c_closure_552(_a_22,_a_24) 
   _a_25=0
   _a_26=(((_a_22[0] * _a_22[2]) * _a_22[4]) * ((_a_22[1] * (_a_22[1] + 1)) // 2))
   _a_27=0
   _a_27,_a_25 = fragments._c_closure_553(_a_11,_a_22,_a_7,_a_6,_a_5,_a_9,_a_27,_a_25,_a_14,_a_24,_a_21,_a_16,_a_17)
   _a_27 = numpy.int32(_a_27) # postprocess
   _a_25 = numpy.int32(_a_25) # postprocess
   _a_28=(((((_a_22[0] * _a_22[2]) * _a_22[4]) * _a_22[1]) * (_a_22[1] + 1)) // 2)
   _a_0._alloc_1expr_IIIZI(_a_3,_a_26,_a_25,True,_a_27)
   _a_29=(_a_0.ptr_base)
   _a_30=(_a_0.shape_base)
   _a_31=(_a_0.nidxs_base)
   _a_32=(_a_0.sp_base)
   _a_33=(_a_0.cof_base)
   _a_34=(_a_0.code_base)
   _a_35=(_a_0.codeptr_base)
   _a_36=(_a_0.cconst_base)
   _a_37=(_a_0.i32)
   _a_38=(_a_0.i64)
   _a_39=(_a_0.f64)
   _a_37[_a_29] = 0
   if (_a_27 > 0):
    _a_37[_a_35] = 0
   fragments._c_closure_554(_a_3,_a_37,_a_30,_a_8,_a_16) 
   if _a_21:
    _a_40=0
    _a_40 = fragments._c_closure_555(_a_22,_a_40,_a_38,_a_32,_a_24)
    _a_40 = numpy.int32(_a_40) # postprocess
    if (_a_40!=_a_26):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   else:
    _a_41=0
    _a_41 = fragments._c_closure_556(_a_22,_a_41,_a_38,_a_32,_a_24)
    _a_41 = numpy.int32(_a_41) # postprocess
    if (_a_41!=_a_26):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   _a_42=0
   _a_43=0
   _a_43,_a_42 = fragments._c_closure_557(_a_12,_a_10,_a_43,_a_11,_a_15,_a_28,_a_7,_a_5,_a_13,_a_42,_a_9,_a_36,_a_34,_a_35,_a_33,_a_39,_a_37,_a_38,_a_27,_a_31,_a_29,_a_32,_a_14,_a_18,_a_16,_a_17)
   _a_43 = numpy.int32(_a_43) # postprocess
   _a_42 = numpy.int32(_a_42) # postprocess
   if (_a_42!=_a_25):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDenseTril(symdim=(")._a_I(self.__dim0)._a_S(",")._a_I(self.__dim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprDenseTril
mosek_fusion_ExprDenseTril=__mk_mosek_fusion_ExprDenseTril()
del __mk_mosek_fusion_ExprDenseTril
#BEFORE CLASS
def __mk_mosek_fusion_ExprDense():
 class ExprDense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprDense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprDense.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprDense._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprDense._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprDense.__new__(ExprDense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=(_a_1.nd)
   _a_4=(_a_1.nnz)
   _a_5=(_a_1.nelem)
   _a_6=(_a_1.ncodeatom)
   _a_7=(_a_1.hassp)
   _a_8=(_a_1.shape_base)
   _a_9=(_a_1.ptr_base)
   _a_10=(_a_1.nidxs_base)
   _a_11=(_a_1.cof_base)
   _a_12=(_a_1.sp_base)
   _a_13=(_a_1.codeptr_base)
   _a_14=(_a_1.code_base)
   _a_15=(_a_1.cconst_base)
   _a_16=(_a_1.i32)
   _a_17=(_a_1.i64)
   _a_18=(_a_1.f64)
   _a_19=1
   if _a_7:
    _a_20=True
    _a_20,_a_19 = fragments._c_closure_558(_a_3,_a_20,_a_19,_a_8,_a_16)
    _a_19 = numpy.int32(_a_19) # postprocess
    if (not _a_20):
     raise mosek_fusion_LengthError._ctor_S("The domain is too large")
   else:
    _a_19 = _a_5
   _a_0._alloc_1expr_IIIZI(_a_3,_a_19,_a_4,False,_a_6)
   _a_21=(_a_0.shape_base)
   _a_22=(_a_0.ptr_base)
   _a_23=(_a_0.nidxs_base)
   _a_24=(_a_0.cof_base)
   _a_25=(_a_0.codeptr_base)
   _a_26=(_a_0.code_base)
   _a_27=(_a_0.cconst_base)
   _a_28=(_a_0.i32)
   _a_29=(_a_0.i64)
   _a_30=(_a_0.f64)
   fragments._c_closure_559(_a_15,_a_14,_a_13,_a_11,_a_7,_a_6,_a_3,_a_5,_a_10,_a_4,_a_9,_a_27,_a_26,_a_25,_a_24,_a_30,_a_28,_a_29,_a_19,_a_23,_a_22,_a_21,_a_8,_a_12,_a_18,_a_16,_a_17) 
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDense(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprDense
mosek_fusion_ExprDense=__mk_mosek_fusion_ExprDense()
del __mk_mosek_fusion_ExprDense
#BEFORE CLASS
def __mk_mosek_fusion_ExprSymmetrize():
 class ExprSymmetrize(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSymmetrize__dim1','_ExprSymmetrize__dim0','_ExprSymmetrize__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args):
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2I(*args):
      self._ctor_init_IILmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression)\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression,int32)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSymmetrize.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprSymmetrize.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSymmetrize'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
   if (dim0 < dim1):
    (self.__dim0) = dim0
    (self.__dim1) = dim1
   else:
    (self.__dim0) = dim1
    (self.__dim1) = dim0
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprSymmetrize._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _a_0=expr._getShape_()
   if ((self.__dim0 < 0) or ((self.__dim0==self.__dim1) or ((self.__dim1 >= int((_a_0).shape[0])) or (_a_0[self.__dim0]!=_a_0[self.__dim1])))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_1,_a_0,_a_2)
   _a_1._pop_1expr_()
   _a_3=0
   _a_4=(_a_1.nd)
   _a_5=(_a_1.nnz)
   _a_6=(_a_1.nelem)
   _a_7=(_a_1.ncodeatom)
   _a_8=(_a_1.hassp)
   _a_9=(_a_1.shape_base)
   _a_10=(_a_1.ptr_base)
   _a_11=(_a_1.code_base)
   _a_12=(_a_1.codeptr_base)
   _a_13=(_a_1.cconst_base)
   _a_14=(_a_1.nidxs_base)
   _a_15=(_a_1.sp_base)
   _a_16=(_a_1.cof_base)
   _a_17=(_a_1.i32)
   _a_18=(_a_1.i64)
   _a_19=(_a_1.f64)
   _a_3 = fragments._c_closure_560(_a_3,_a_4,_a_9,_a_17)
   _a_3 = numpy.int32(_a_3) # postprocess
   _a_20=_a_2._alloci32_I(_a_6)
   _a_21=_a_2._alloci32_I(_a_6)
   _a_22=_a_2._alloci32_I((_a_3 + 1))
   _a_23=_a_2._alloci64_I(_a_6)
   _a_24=(_a_2.i32)
   _a_25=(_a_2.i64)
   _a_26=0
   _a_27=0
   _a_28=0
   if (_a_17[(_a_9 + self.__dim0)]!=_a_17[(_a_9 + self.__dim1)]):
    raise mosek_fusion_DimensionError._ctor_S("Symmetry dimensions are no the same")
   _a_29=_a_17[(_a_9 + self.__dim0)]
   _a_30=numpy.array([1 for _a_31 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   _a_32=numpy.zeros((5,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_561(_a_30,self.__dim0,_a_9,_a_17) 
   _a_30[1] = _a_17[(_a_9 + self.__dim0)]
   fragments._c_closure_562(_a_30,self.__dim0,self.__dim1,_a_9,_a_17) 
   _a_30[3] = _a_17[(_a_9 + self.__dim1)]
   fragments._c_closure_563(_a_30,self.__dim1,_a_4,_a_9,_a_17) 
   _a_32[4] = 1
   fragments._c_closure_564(_a_30,_a_32) 
   if _a_8:
    _a_33=_a_20
    fragments._c_closure_565(_a_33,_a_6,_a_24) 
    _a_34=_a_21
    _a_35=numpy.array([1,2,3,0], dtype=numpy.dtype(numpy.int32))
    _a_33,_a_34 = fragments._c_closure_566(_a_33,_a_30,_a_6,_a_35,_a_15,_a_32,_a_34,_a_18,_a_24,_a_22)
    _a_33 = numpy.int32(_a_33) # postprocess
    _a_34 = numpy.int32(_a_34) # postprocess
    _a_28,_a_27 = fragments._c_closure_567(_a_12,_a_7,_a_6,_a_10,_a_28,_a_27,_a_15,_a_32,_a_17,_a_18)
    _a_28 = numpy.int32(_a_28) # postprocess
    _a_27 = numpy.int32(_a_27) # postprocess
    fragments._c_closure_568(_a_33,_a_6,_a_15,_a_32,_a_18,_a_24,_a_25,_a_23) 
    _a_26 = fragments._c_closure_569(_a_6,_a_26,_a_15,_a_32,_a_18,_a_25,_a_23)
    _a_26 = numpy.int32(_a_26) # postprocess
    _a_0._alloc_1expr_IIIZI(_a_4,_a_26,_a_27,True,_a_28)
    _a_36=_a_4
    _a_37=(_a_0.ptr_base)
    _a_38=(_a_0.nidxs_base)
    _a_39=(_a_0.shape_base)
    _a_40=(_a_0.sp_base)
    _a_41=(_a_0.cof_base)
    _a_42=(_a_0.code_base)
    _a_43=(_a_0.codeptr_base)
    _a_44=(_a_0.cconst_base)
    _a_45=(_a_0.i32)
    _a_46=(_a_0.i64)
    _a_47=(_a_0.f64)
    fragments._c_closure_570(_a_4,_a_45,_a_39,_a_9,_a_17) 
    _a_45[_a_37] = 0
    if (_a_28 > 0):
     _a_45[_a_43] = 0
    _a_48=0
    _a_49=0
    _a_50=0
    _a_51=0
    _a_52=0
    _a_45[_a_37] = 0
    _a_49,_a_50,_a_52,_a_51,_a_48 = fragments._c_closure_571(_a_13,_a_11,_a_49,_a_12,_a_16,_a_33,_a_50,_a_52,_a_51,_a_6,_a_14,_a_48,_a_10,_a_44,_a_42,_a_43,_a_41,_a_47,_a_45,_a_46,_a_28,_a_38,_a_37,_a_40,_a_15,_a_32,_a_19,_a_17,_a_18,_a_24,_a_25,_a_23)
    _a_49 = numpy.int32(_a_49) # postprocess
    _a_50 = numpy.int32(_a_50) # postprocess
    _a_52 = numpy.int32(_a_52) # postprocess
    _a_51 = numpy.int32(_a_51) # postprocess
    _a_48 = numpy.int32(_a_48) # postprocess
    if (_a_48!=_a_27):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nzi")
   else:
    _a_26 = _a_6
    _a_27 = (_a_5 * 2)
    _a_28 = (((2 * _a_7) + ((2 * 2) * _a_5)) if ((_a_7 > 0) ) else 0)
    _a_28,_a_27 = fragments._c_closure_572(_a_12,_a_30,_a_7,_a_10,_a_28,_a_27,_a_32,_a_17)
    _a_28 = numpy.int32(_a_28) # postprocess
    _a_27 = numpy.int32(_a_27) # postprocess
    _a_0._alloc_1expr_IIIZI(_a_4,_a_26,_a_27,False,_a_28)
    _a_53=(_a_0.ptr_base)
    _a_54=(_a_0.shape_base)
    _a_55=(_a_0.code_base)
    _a_56=(_a_0.codeptr_base)
    _a_57=(_a_0.nidxs_base)
    _a_58=(_a_0.sp_base)
    _a_59=(_a_0.cof_base)
    _a_60=(_a_0.cconst_base)
    _a_61=(_a_0.i32)
    _a_62=(_a_0.i64)
    _a_63=(_a_0.f64)
    _a_64=0
    _a_65=0
    _a_66=0
    fragments._c_closure_573(_a_4,_a_61,_a_54,_a_9,_a_17) 
    _a_61[_a_53] = 0
    if (_a_28 > 0):
     _a_61[_a_56] = 0
    _a_67=0
    _a_66,_a_67,_a_64,_a_65 = fragments._c_closure_574(_a_13,_a_11,_a_66,_a_12,_a_16,_a_29,_a_30,_a_67,_a_14,_a_64,_a_10,_a_60,_a_55,_a_56,_a_59,_a_65,_a_63,_a_61,_a_62,_a_28,_a_57,_a_53,_a_32,_a_19,_a_17,_a_18)
    _a_66 = numpy.int32(_a_66) # postprocess
    _a_67 = numpy.int32(_a_67) # postprocess
    _a_64 = numpy.int32(_a_64) # postprocess
    _a_65 = numpy.int32(_a_65) # postprocess
    if (_a_64!=_a_27):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
    if (_a_65!=_a_26):
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   _a_2._clear_()
   _a_0._peek_1expr_()
   if ((_a_0.nnz)!=(_a_0.i32)[((_a_0.ptr_base) + (_a_0.nelem))]):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
   if ((_a_0.i32)[(_a_0.ptr_base)]!=0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSymmetrize(symdim=(")._a_I(self.__dim0)._a_S(",")._a_I(self.__dim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSymmetrize
mosek_fusion_ExprSymmetrize=__mk_mosek_fusion_ExprSymmetrize()
del __mk_mosek_fusion_ExprSymmetrize
#BEFORE CLASS
def __mk_mosek_fusion_ExprCondense():
 class ExprCondense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCondense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCondense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCondense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprCondense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCondense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprCondense.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprCondense._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprCondense._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCondense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCondense.__new__(ExprCondense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,expr._getModel_(),expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
   _a_0._peek_1expr_()
   if (_a_0.hassp):
    _a_3=_a_0._popi32_()
    _a_0._popi32_I(_a_3)
    _a_4=_a_0._popi32_()
    _a_5=_a_0._popi32_()
    _a_0._popi32_()
    _a_0._popi64_I(_a_4)
    _a_0._pushi32_I(0)
    _a_0._pushi32_I(_a_5)
    _a_0._pushi32_I(_a_4)
    _a_0._pushi32_I(_a_4)
    _a_0._pushi32_I(1)
    _a_0._peek_1expr_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCondense(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCondense
mosek_fusion_ExprCondense=__mk_mosek_fusion_ExprCondense()
del __mk_mosek_fusion_ExprCondense
#BEFORE CLASS
def __mk_mosek_fusion_ExprFromVar():
 class ExprFromVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprFromVar__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2(*args):
      self._ctor_init_Lmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprFromVar.ctor(mosek.fusion.Variable)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprFromVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprFromVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprFromVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprFromVar.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprFromVar._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprFromVar._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprFromVar'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2(x):
    o = ExprFromVar.__new__(ExprFromVar)
    o._ctor_init_Lmosek_4fusion_4Variable_2(x)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2(self,x):
    self._ctor_init_Lmosek_4fusion_4Variable_2(x)
  def _ctor_init_Lmosek_4fusion_4Variable_2(self,x):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,x._getModel_(),x._getShape_())
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=self._getShape_()
   _a_4=mosek.fusion.Set._size__3I(_a_3)
   _a_5=self.__x._numInst_()
   _a_6=_a_5
   _a_7=(_a_4 > _a_5)
   _a_0._alloc_1expr_IIIZ(int((_a_3).shape[0]),_a_5,_a_6,_a_7)
   _a_8=(_a_0.ptr_base)
   _a_9=(_a_0.nidxs_base)
   _a_10=(_a_0.sp_base)
   _a_11=(_a_0.cof_base)
   _a_12=(_a_0.shape_base)
   _a_13=(_a_0.i32)
   _a_14=(_a_0.i64)
   _a_15=(_a_0.f64)
   fragments._c_closure_575(_a_13,_a_3,_a_12) 
   fragments._c_closure_576(_a_11,_a_5,_a_6,_a_8,_a_15,_a_13) 
   if _a_7:
    self.__x._inst_I_3JI_3J(_a_10,_a_14,_a_9,_a_14)
   else:
    self.__x._inst_I_3J(_a_9,_a_14)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("Expr(")._a_S(self.__x._toString_())._a_S(")")._toString_())
 return ExprFromVar
mosek_fusion_ExprFromVar=__mk_mosek_fusion_ExprFromVar()
del __mk_mosek_fusion_ExprFromVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprReshape():
 class ExprReshape(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprReshape__e']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args):
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprReshape.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprReshape.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_ExprReshape._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprReshape._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.ExprReshape.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_ExprReshape._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_ExprReshape._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.toString()')
  def __repr__(self): return 'mosek.fusion.ExprReshape'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(shape,e):
    o = ExprReshape.__new__(ExprReshape)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(shape,e)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_match__3I__(shape) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),e)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,e._getModel_(),mosek.fusion.Utils.Tools._arraycopy__3I(shape))
   _a_0=e._getSize_()
   if (mosek.fusion.Set._size__3I(shape)!=e._getSize_()):
    raise mosek_fusion_LengthError._ctor_S("Cannot reshape to mismatching shape")
   (self.__e) = e
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=self._getShape_()
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
   _a_0._peek_1expr_()
   _a_4=_a_0._popi32_()
   _a_5=1
   for _a_6 in range(0,_a_4):
    _a_5 *= _a_0._popi32_()
   if (_a_5!=self._getSize_()):
    raise mosek_fusion_DimensionError._ctor_S("The two shapes have different sizes")
   for _a_7 in range(0,int((_a_3).shape[0])):
    _a_0._pushi32_I(_a_3[_a_7])
   _a_0._pushi32_I(int((_a_3).shape[0]))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()._a_S("ExprReshape((")
   if (self._getND_() > 0):
    _a_0._a_I(self._getDim_I(0))
    for _a_1 in range(1,self._getND_()):
     _a_0._a_S(",")._a_I(self._getDim_I(_a_1))
   _a_0._a_S("),")._a_S(self.__e._toString_())._a_S(")")
   return (_a_0._toString_())
 return ExprReshape
mosek_fusion_ExprReshape=__mk_mosek_fusion_ExprReshape()
del __mk_mosek_fusion_ExprReshape
#BEFORE CLASS
def __mk_mosek_fusion_Expr():
 class Expr(mosek_fusion_BaseExpression):
  __slots__ = ['_Expr__inst','_Expr__cof_v','_Expr__subj','_Expr__ptrb','_Expr__bfix','_Expr__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3J_3D_3D_3I_3J(*args):
      self._ctor_init__3J_3J_3D_3D_3I_3J(*args)
    elif self.__match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):
      self._ctor_alt_init__3J_3J_3D_3D_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Expr.ctor(array(int64,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int64,ndim=1))')
  @staticmethod
  def add(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))
      mosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))
      mosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)
      mosek.fusion.Expr.add(double,mosek.fusion.Expression)
      mosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)
      mosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))
      mosek.fusion.Expr.add(mosek.fusion.Expression,double)
      mosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))
      mosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)
      mosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)
      mosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)

    Description
    -----------

    Construct an expression as the sum of a list of variables.

    Parameters
    ----------

    a1 : array(double,ndim=1)
        A one-dimensional array of constants.
    a2 : array(double,ndim=2)
        A two-dimensional array of constants.
    c : double
        A constant.
    e1 : mosek.fusion.Expression
        An expression.
    e2 : mosek.fusion.Expression
        An expression.
    exps : array(mosek.fusion.Expression,ndim=1)
        
        A list of expressions. All expressions in the array must have the same shape.
        The list must contain at least one element.
                  
    m : mosek.fusion.Matrix
        A Matrix object.
    n : mosek.fusion.NDSparseArray
        An NDSparseArray object.
    vs : array(mosek.fusion.Variable,ndim=1)
        
        A list of variables. All variables in the array must have the same shape.
        The list must contain at least one element.
                  
    '''
    if False: pass
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def neg(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.neg(mosek.fusion.Expression)

    Description
    -----------

    Change the sign of an expression

    Parameters
    ----------

    e : mosek.fusion.Expression
        An expression object.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.neg(mosek.fusion.Expression)')
  @staticmethod
  def vstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))
      mosek.fusion.Expr.vstack(mosek.fusion.Expression,double)
      mosek.fusion.Expr.vstack(double,mosek.fusion.Expression)
      mosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)
      mosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)
      mosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)
      mosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)
      mosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)
      mosek.fusion.Expr.vstack(double,double,double)
      mosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)

    Description
    -----------

    Stack a three expressions vertically (i.e. in first dimension). 

    Parameters
    ----------

    a1 : double
        A scalar constant.
    a2 : double
        A scalar constant.
    a3 : double
        A scalar constant.
    e1 : mosek.fusion.Expression
        An expression.
    e2 : mosek.fusion.Expression
        An expression.
    e3 : mosek.fusion.Expression
        An expression.
    exprs : array(mosek.fusion.Expression,ndim=1)
        A list of expressions. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_vstack__3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DDD(*args):
      return mosek_fusion_Expr._vstack_DDD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDD(*args):
      return mosek_fusion_Expr._vstack_alt_DDD(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,double,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)')
  @staticmethod
  def hstack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))
      mosek.fusion.Expr.hstack(mosek.fusion.Expression,double)
      mosek.fusion.Expr.hstack(double,mosek.fusion.Expression)
      mosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)
      mosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)
      mosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)
      mosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)
      mosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)
      mosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)

    Description
    -----------

    Stack a three expressions horizontally (i.e. in second dimension). 

    Parameters
    ----------

    a1 : double
        A scalar constant.
    a2 : double
        A scalar constant.
    a3 : double
        A scalar constant.
    e1 : mosek.fusion.Expression
        An expression.
    e2 : mosek.fusion.Expression
        An expression.
    e3 : mosek.fusion.Expression
        An expression.
    exprs : array(mosek.fusion.Expression,ndim=1)
        A list of expressions. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_hstack__3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)')
  @staticmethod
  def reshape(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.reshape(mosek.fusion.Expression,array(int32,ndim=1))
      mosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)
      mosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)

    Description
    -----------

    Reshape the expression into a different shape with the same number of elements.

    Parameters
    ----------

    dimi : int32
    dimj : int32
    e : mosek.fusion.Expression
        The expression to reshape.
    newshape : array(int32,ndim=1)
        Reshape into an expression of this shape.
    size : int32
        Reshape into a one-dimensional expression of this size.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2I(*args):
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2II(*args):
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,array(int32,ndim=1))\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def zeros(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.zeros(int32)
      mosek.fusion.Expr.zeros(array(int32,ndim=1))

    Description
    -----------

    Create an expression consisting of zeros.

    Parameters
    ----------

    shp : array(int32,ndim=1)
        Defines the shape of the expression. 
    size : int32
        Length of the vector to be constructed. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_zeros_I(*args):
      return mosek_fusion_Expr._zeros_I(*args)
    elif mosek_fusion_Expr._match_alt_zeros_I(*args):
      return mosek_fusion_Expr._zeros_alt_I(*args)
    elif mosek_fusion_Expr._match_zeros__3I(*args):
      return mosek_fusion_Expr._zeros__3I(*args)
    elif mosek_fusion_Expr._match_alt_zeros__3I(*args):
      return mosek_fusion_Expr._zeros_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list zeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.zeros(int32)\n\tmosek.fusion.Expr.zeros(array(int32,ndim=1))')
  def eval(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    rs : mosek.fusion.WorkStack
    ws : mosek.fusion.WorkStack
    xs : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_Expr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  @staticmethod
  def sum(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.sum(mosek.fusion.Expression)
      mosek.fusion.Expr.sum(mosek.fusion.Expression,int32)
      mosek.fusion.Expr.sum(mosek.fusion.Expression,array(int32,ndim=1))

    Description
    -----------

    Sum the elements of an expression.

    Parameters
    ----------

    dim : int32
        The dimension along which to sum.
    dims : array(int32,ndim=1)
        The dimensions along which to sum.
    expr : mosek.fusion.Expression
        An expression object.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2I(*args):
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2_3I(*args):
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2_3I(*args):
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2_3I(*args)
    else:
      raise ValueError('Invalid argument list sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,array(int32,ndim=1))')
  @staticmethod
  def mulDiag(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))
      mosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Variable)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))
      mosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Expression)
      mosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)
      mosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Parameter)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Parameter)
      mosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)

    Description
    -----------

    Compute the diagonal of the product of two matrices. 

    Parameters
    ----------

    a : array(double,ndim=2)
        A constant matrix.
    expr : mosek.fusion.Expression
        An expression object.
    mx : mosek.fusion.Matrix
        A matrix object.
    p : mosek.fusion.Parameter
        A parameter object.
    v : mosek.fusion.Variable
        A variable object.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    else:
      raise ValueError('Invalid argument list mulDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)')
  @staticmethod
  def transpose(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.transpose(mosek.fusion.Expression)

    Description
    -----------

    Transpose a two-dimensional expression.

    Parameters
    ----------

    e : mosek.fusion.Expression
    '''
    if False: pass
    elif mosek_fusion_Expr._match_transpose_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_transpose_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._transpose_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.transpose(mosek.fusion.Expression)')
  @staticmethod
  def flatten(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.flatten(mosek.fusion.Expression)

    Description
    -----------

    Reshape the expression into a vector. 

    Parameters
    ----------

    e : mosek.fusion.Expression
    '''
    if False: pass
    elif mosek_fusion_Expr._match_flatten_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._flatten_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.flatten(mosek.fusion.Expression)')
  @staticmethod
  def outer(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Expression)
      mosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.outer(mosek.fusion.Expression,mosek.fusion.Parameter)
      mosek.fusion.Expr.outer(mosek.fusion.Parameter,mosek.fusion.Expression)
      mosek.fusion.Expr.outer(mosek.fusion.Expression,mosek.fusion.Matrix)
      mosek.fusion.Expr.outer(mosek.fusion.Expression,array(double,ndim=1))

    Description
    -----------

    Return the outer-product of two vectors.

    Parameters
    ----------

    a : array(double,ndim=1)
        A vector of constants. 
    e : mosek.fusion.Expression
        A vector expression. 
    m : mosek.fusion.Matrix
        A one-dimensional matrix. 
    p : mosek.fusion.Parameter
        A vector parameter.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list outer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.outer(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,array(double,ndim=1))')
  @staticmethod
  def stack(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))
      mosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))
      mosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)
      mosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)
      mosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)
      mosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)
      mosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)
      mosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)
      mosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)

    Description
    -----------

    Stack expressions in two dimensions. 

    Parameters
    ----------

    a1 : double
        A scalar constant.
    a2 : double
        A scalar constant.
    a3 : double
        A scalar constant.
    dim : int32
        The dimension in which to stack. 
    e1 : mosek.fusion.Expression
        An expression.
    e2 : mosek.fusion.Expression
        An expression.
    e3 : mosek.fusion.Expression
        An expression.
    exprs : array(mosek.fusion.Expression,ndim=1)
        A list of expressions. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DD(*args):
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))\n\tmosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)')
  @staticmethod
  def condense(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.condense(mosek.fusion.Expression)

    Description
    -----------

    Flatten expression and remove all structural zeros. 

    Parameters
    ----------

    e : mosek.fusion.Expression
    '''
    if False: pass
    elif mosek_fusion_Expr._match_condense_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_condense_Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._condense_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list condense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.condense(mosek.fusion.Expression)')
  @staticmethod
  def constTerm(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.constTerm(array(double,ndim=1))
      mosek.fusion.Expr.constTerm(mosek.fusion.Matrix)
      mosek.fusion.Expr.constTerm(double)
      mosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)
      mosek.fusion.Expr.constTerm(array(double,ndim=2))
      mosek.fusion.Expr.constTerm(int32,double)
      mosek.fusion.Expr.constTerm(array(int32,ndim=1),double)
      mosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),double)
      mosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))

    Description
    -----------

    Create a constant vector of values from val as an expression.

    Parameters
    ----------

    m : mosek.fusion.Matrix
        A matrix of values initializing the expression. 
    nda : mosek.fusion.NDSparseArray
        An multi-dimensional sparse array initializing the expression. 
    shp : array(int32,ndim=1)
        Defines the shape of the expression. 
    size : int32
        Length of the vector to be constructed. 
    sparsity : array(int32,ndim=2)
        Sparsity pattern. 
    val : double
        A scalar value to be repeated in all entries of the expression. 
    vals1 : array(double,ndim=1)
        A vector initializing the expression. 
    vals2 : array(double,ndim=2)
        An array initializing the expression. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_constTerm__3D(*args):
      return mosek_fusion_Expr._constTerm__3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3D(*args):
      return mosek_fusion_Expr._constTerm_alt__3D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_constTerm_D(*args):
      return mosek_fusion_Expr._constTerm_D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_D(*args):
      return mosek_fusion_Expr._constTerm_alt_D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_constTerm__3_5D(*args):
      return mosek_fusion_Expr._constTerm__3_5D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3_5D(*args):
      return mosek_fusion_Expr._constTerm_alt__3_5D(*args)
    elif mosek_fusion_Expr._match_constTerm_ID(*args):
      return mosek_fusion_Expr._constTerm_ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_ID(*args):
      return mosek_fusion_Expr._constTerm_alt_ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3ID(*args):
      return mosek_fusion_Expr._constTerm__3ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3ID(*args):
      return mosek_fusion_Expr._constTerm_alt__3ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5ID(*args):
      return mosek_fusion_Expr._constTerm__3I_3_5ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5ID(*args):
      return mosek_fusion_Expr._constTerm_alt__3I_3_5ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5I_3D(*args):
      return mosek_fusion_Expr._constTerm__3I_3_5I_3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5I_3D(*args):
      return mosek_fusion_Expr._constTerm_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list constTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.constTerm(array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Matrix)\n\tmosek.fusion.Expr.constTerm(double)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.constTerm(array(double,ndim=2))\n\tmosek.fusion.Expr.constTerm(int32,double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  @staticmethod
  def sub(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))
      mosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)
      mosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)
      mosek.fusion.Expr.sub(double,mosek.fusion.Expression)
      mosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)
      mosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)
      mosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))
      mosek.fusion.Expr.sub(mosek.fusion.Expression,double)
      mosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)
      mosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)

    Description
    -----------

    Compute the difference of two expressions.

    Parameters
    ----------

    a1 : array(double,ndim=1)
        An array of constants.
    a2 : array(double,ndim=2)
        An array of constants.
    c : double
        A constant.
    e1 : mosek.fusion.Expression
        An expression.
    e2 : mosek.fusion.Expression
        An expression.
    m : mosek.fusion.Matrix
        A Matrix object.
    n : mosek.fusion.NDSparseArray
        An NDSparseArray object.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def mulElm(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))
      mosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)
      mosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)
      mosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Parameter)
      mosek.fusion.Expr.mulElm(mosek.fusion.Parameter,mosek.fusion.Expression)
      mosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)
      mosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))
      mosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)
      mosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)

    Description
    -----------

    Element-wise product of two items. 

    Parameters
    ----------

    a1 : array(double,ndim=1)
        A one-dimensional coefficient array.
    a2 : array(double,ndim=2)
        A two-dimensional coefficient array.
    expr : mosek.fusion.Expression
        An expression object.
    m : mosek.fusion.Matrix
        A matrix object.
    p : mosek.fusion.Parameter
        A parameter object.
    spm : mosek.fusion.NDSparseArray
        A multidimensional sparse array object.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list mulElm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def repeat(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.repeat(mosek.fusion.Variable,int32,int32)
      mosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)

    Description
    -----------

    Repeat an expression a number of times in the given dimension.

    Parameters
    ----------

    d : int32
        The dimension in which to repeat. Must define a valid dimension index. 
    e : mosek.fusion.Expression
        The expression to repeat. 
    n : int32
        Number of times to repeat. Must be strictly positive. 
    x : mosek.fusion.Variable
        The variable to repeat. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Variable_2II(*args):
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Expression_2II(*args):
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.repeat(mosek.fusion.Variable,int32,int32)\n\tmosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def dot(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))
      mosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)
      mosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)
      mosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Parameter)
      mosek.fusion.Expr.dot(mosek.fusion.Parameter,mosek.fusion.Expression)
      mosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)
      mosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))
      mosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)
      mosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)

    Description
    -----------

    Return a scalar expression object representing the dot-product of two items.

    Parameters
    ----------

    c1 : array(double,ndim=1)
        A one-dimensional coefficient vector.
    c2 : array(double,ndim=2)
        A two-dimensional coefficient array.
    e : mosek.fusion.Expression
        An expression object.
    m : mosek.fusion.Matrix
        A matrix object.
    nda : mosek.fusion.NDSparseArray
        A multi-dimensional sparse array.
    p : mosek.fusion.Parameter
        A parameter. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list dot('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.dot(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def ones(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.ones()
      mosek.fusion.Expr.ones(array(int32,ndim=1))
      mosek.fusion.Expr.ones(int32)
      mosek.fusion.Expr.ones(array(int32,ndim=1),array(int32,ndim=2))

    Description
    -----------

    Create an expression consisting of ones.

    Parameters
    ----------

    shp : array(int32,ndim=1)
        Defines the shape of the expression. 
    size : int32
        Length of the vector to be constructed. 
    sparsity : array(int32,ndim=2)
        Defines the sparsity pattern of the expression - everything outside the sparsitry patterm will be zero. 
    '''
    if False: pass
    elif mosek_fusion_Expr._match_ones_(*args):
      return mosek_fusion_Expr._ones_(*args)
    elif mosek_fusion_Expr._match_alt_ones_(*args):
      return mosek_fusion_Expr._ones_alt_(*args)
    elif mosek_fusion_Expr._match_ones__3I(*args):
      return mosek_fusion_Expr._ones__3I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I(*args):
      return mosek_fusion_Expr._ones_alt__3I(*args)
    elif mosek_fusion_Expr._match_ones_I(*args):
      return mosek_fusion_Expr._ones_I(*args)
    elif mosek_fusion_Expr._match_alt_ones_I(*args):
      return mosek_fusion_Expr._ones_alt_I(*args)
    elif mosek_fusion_Expr._match_ones__3I_3_5I(*args):
      return mosek_fusion_Expr._ones__3I_3_5I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I_3_5I(*args):
      return mosek_fusion_Expr._ones_alt__3I_3_5I(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.ones()\n\tmosek.fusion.Expr.ones(array(int32,ndim=1))\n\tmosek.fusion.Expr.ones(int32)\n\tmosek.fusion.Expr.ones(array(int32,ndim=1),array(int32,ndim=2))')
  @staticmethod
  def mul(*args):
    '''
    Syntax
    ------

      mosek.fusion.Expr.mul(mosek.fusion.Variable,array(double,ndim=2))
      mosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)
      mosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)
      mosek.fusion.Expr.mul(double,mosek.fusion.Expression)
      mosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))
      mosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)
      mosek.fusion.Expr.mul(mosek.fusion.Parameter,mosek.fusion.Expression)
      mosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Variable)
      mosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Expression)
      mosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)
      mosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=2))
      mosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Parameter)
      mosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)
      mosek.fusion.Expr.mul(mosek.fusion.Expression,double)

    Description
    -----------

    Multiply two items. 

    Parameters
    ----------

    a : array(double,ndim=2)
        Scalar data.
    c : double
        A scalar value.
    expr : mosek.fusion.Expression
        An expression.
    mx : mosek.fusion.Matrix
        A matrix.
    p : mosek.fusion.Parameter
        A parameter object.
    v : mosek.fusion.Variable
        A variable.
    '''
    if False: pass
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Variable_2(*args):
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args):
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,double)')
  def __repr__(self): return 'mosek.fusion.Expr'
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shape) and __arg_match__3J__(inst))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(inst))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
    self._ctor_init__3J_3J_3D_3D_3I_3J(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
   mosek_fusion_Expr._ctor_init__3J_3J_3D_3D_3I_3JI(self,mosek.fusion.Utils.Tools._arraycopy__3J(ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(subj),mosek.fusion.Utils.Tools._arraycopy__3D(cof),mosek.fusion.Utils.Tools._arraycopy__3D(bfix),(mosek.fusion.Utils.Tools._arraycopy__3I(shape) if ((shape is not None) ) else numpy.array([(int((ptrb).shape[0]) - 1)], dtype=numpy.dtype(numpy.int32))),(mosek.fusion.Utils.Tools._arraycopy__3J(inst) if ((inst is not None) ) else None),1)
   _a_0=(int((ptrb).shape[0]) - 1)
   if (_a_0 < 0):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   _a_1=ptrb[_a_0]
   if ((_a_1 < 0) or ((_a_1!=int((cof).shape[0])) or (_a_1!=int((subj).shape[0])))):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb construction")
   _a_2=True
   _a_3=True
   _a_4=True
   _a_5=(self.__shape)
   _a_6=mosek.fusion.Set._size__3I(_a_5)
   _a_4,_a_2,_a_3 = fragments._c_closure_577(inst,_a_4,_a_0,ptrb,_a_2,_a_3,_a_6,_a_5)
   if (not _a_3):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid shape")
   if (not _a_2):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   if (not _a_4):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid sparsity pattern")
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shp) and __arg_match__3J__(inst) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shp) and __arg_alt_match__3J__(inst) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
    self._ctor_init__3J_3J_3D_3D_3I_3JI(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)),numpy.int32(unchecked_))
  def _ctor_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,None,shp)
   (self.__shape) = shp
   (self.__ptrb) = ptrb
   (self.__subj) = subj
   (self.__cof_v) = cof
   (self.__bfix) = bfix
   (self.__inst) = inst
   if ((self.__shape) is None):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(e):
    o = Expr.__new__(Expr)
    o._ctor_init_Lmosek_4fusion_4Expression_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,e):
    self._ctor_init_Lmosek_4fusion_4Expression_2(e)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,e):
   mosek_fusion_BaseExpression._ctor_init_Lmosek_4fusion_4Model_2_3I(self,e._getModel_(),e._getShape_())
   _a_1=e
   if   isinstance(_a_1,mosek_fusion_Expr):
    ee=_a_1
    self.__shape = (ee.__shape)
    self.__ptrb = (ee.__ptrb)
    self.__subj = (ee.__subj)
    self.__cof_v = (ee.__cof_v)
    self.__bfix = (ee.__bfix)
    self.__inst = (ee.__inst)
   else:
    ee=_a_1
    _a_1=mosek_fusion_WorkStack._ctor_()
    _a_2=mosek_fusion_WorkStack._ctor_()
    _a_3=mosek_fusion_WorkStack._ctor_()
    ee._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_3,_a_2,_a_1)
    _a_4=_a_3._popi32_()
    _a_5=_a_3._popi32_I(_a_4)
    _a_6=_a_3._popi32_()
    _a_7=_a_3._popi32_()
    _a_8=(_a_3._popi32_()!=0)
    _a_9=_a_3._popi32_I((_a_6 + 1))
    _a_10=(_a_3._popi64_I(_a_6) if (_a_8 ) else 0)
    _a_11=_a_3._popi64_I(_a_7)
    _a_12=_a_3._popf64_I(_a_6)
    _a_13=_a_3._popf64_I(_a_7)
    _a_14=(_a_3.i32)
    _a_15=(_a_3.i64)
    _a_16=(_a_3.f64)
    self.__shape = numpy.array([_a_14[(_a_5 + _a_17)] for _a_17 in range(0,_a_4)], dtype=numpy.dtype(numpy.int32))
    self.__ptrb = numpy.array([_a_14[(_a_9 + _a_18)] for _a_18 in range(0,(_a_6 + 1))], dtype=numpy.dtype(numpy.int64))
    self.__subj = numpy.array([_a_15[(_a_11 + _a_19)] for _a_19 in range(0,_a_7)], dtype=numpy.dtype(numpy.int64))
    self.__cof_v = numpy.array([_a_16[(_a_13 + _a_20)] for _a_20 in range(0,_a_7)], dtype=numpy.dtype(numpy.float64))
    self.__bfix = numpy.array([_a_16[(_a_12 + _a_21)] for _a_21 in range(0,_a_7)], dtype=numpy.dtype(numpy.float64))
    self.__inst = (numpy.array([_a_15[(_a_10 + _a_22)] for _a_22 in range(0,_a_7)], dtype=numpy.dtype(numpy.int64)) if (_a_8 ) else None)
   if (self.__shape is None):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  def __prod_alt__3I(self,_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = self.__prod__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def __prod__3I(self,_a_0):
   _a_1=1
   _a_1 = fragments._c_closure_578(_a_1,_a_0)
   _a_1 = numpy.int32(_a_1) # postprocess
   return numpy.int32(_a_1)
  @staticmethod
  def __varstack_alt__3_3Lmosek_4fusion_4Variable_2(_t__a_0):
   _a_0=_monty.makeJaggedArray(_t__a_0,(1,1),numpy.dtype(object))
   _1_res = mosek_fusion_Expr.__varstack__3_3Lmosek_4fusion_4Variable_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __varstack__3_3Lmosek_4fusion_4Variable_2(_a_0):
   return (numpy.array([_a_0[_a_1][_a_2] for _a_1 in range(0,int((_a_0).shape[0])) for _a_2 in range(0,int((_a_0[_a_1]).shape[0]))], dtype=numpy.dtype(object)))
  @staticmethod
  def __varstack_alt__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   if (_a_0 is None):
    return (_a_1)
   elif (_a_1 is None):
    return (_a_0)
   else:
    _a_2=numpy.ndarray(((int((_a_0).shape[0]) + int((_a_1).shape[0])),), dtype=numpy.dtype(object))
    for _a_3 in range(0,int((_a_0).shape[0])):
     _a_2[_a_3] = _a_0[_a_3]
    for _a_4 in range(0,int((_a_1).shape[0])):
     _a_2[(_a_4 + int((_a_0).shape[0]))] = _a_1[_a_4]
    return (_a_2)
  @staticmethod
  def _match_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _condense_alt_Lmosek_4fusion_4Expression_2(_t__a_0):
    return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(_a_0)
  @staticmethod
  def _condense_Lmosek_4fusion_4Expression_2(_a_0):
   return (mosek_fusion_ExprCondense._ctor_Lmosek_4fusion_4Expression_2(_a_0))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Expression_2(_t__a_0):
    return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(_a_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Expression_2(_a_0):
   if (_a_0 is None):
    raise ValueError("Arguments for flatten may not be null")
   _a_1=_a_0._getSize_()
   if (not (_a_1 <= 2147483647)):
    raise mosek_fusion_LengthError._ctor_S("Maximum dimension size exceeded")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2I(_a_0,numpy.int32(_a_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2II(_a_0,_a_1,_a_2):
   if (_a_0 is None):
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_a_0,mosek.fusion.Set._make_II(_a_1,_a_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2I(_a_0,_a_1):
   if (_a_0 is None):
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_a_0,mosek.fusion.Set._make_I(_a_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2_3I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2_3I(_a_0,_a_1):
   return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_zeros__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_zeros__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _zeros_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Expr._zeros__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _zeros__3I(_a_0):
   return (mosek.fusion.Expr._constTerm__3ID(_a_0,0))
  @staticmethod
  def _match_zeros_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_zeros_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _zeros_alt_I(_t__a_0):
    return mosek_fusion_Expr._zeros_I(numpy.int32(__a_0))
  @staticmethod
  def _zeros_I(_a_0):
   return (mosek.fusion.Expr._constTerm_ID(_a_0,0))
  @staticmethod
  def _match_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _ones_alt_():
    return mosek_fusion_Expr._ones_()
  @staticmethod
  def _ones_():
   return (mosek.fusion.Expr._constTerm_D(1))
  @staticmethod
  def _match_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3_5I__(_a_1))
  @staticmethod
  def _match_alt_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3_5I__(_a_1))
  @staticmethod
  def _ones_alt__3I_3_5I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Expr._ones__3I_3_5I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _ones__3I_3_5I(_a_0,_a_1):
   return (mosek.fusion.Expr._constTerm__3I_3_5ID(_a_0,_a_1,1))
  @staticmethod
  def _match_ones__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3I__(_a_0))
  @staticmethod
  def _match_alt_ones__3I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3I__(_a_0))
  @staticmethod
  def _ones_alt__3I(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Expr._ones__3I(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _ones__3I(_a_0):
   return (mosek.fusion.Expr._constTerm__3ID(_a_0,1))
  @staticmethod
  def _match_ones_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_ones_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _ones_alt_I(_t__a_0):
    return mosek_fusion_Expr._ones_I(numpy.int32(__a_0))
  @staticmethod
  def _ones_I(_a_0):
   return (mosek.fusion.Expr._constTerm_ID(_a_0,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(_t__a_0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_a_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4NDSparseArray_2(_a_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D((_a_0._dims),(_a_0._inst),(_a_0._cof)))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Matrix_2(_a_0):
   _a_1=_a_0._numRows_()
   _a_2=_a_0._numColumns_()
   _a_3=mosek.fusion.Set._make_II(_a_1,_a_2)
   if _a_0._isSparse_():
    _a_4=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _a_5=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_6=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _a_0._getDataAsTriplets__3I_3I_3D(_a_6,_a_5,_a_4)
    _a_7=numpy.array([((_a_6[_a_8] * _a_2) + _a_5[_a_8]) for _a_8 in range(0,int((_a_5).shape[0]))], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_a_3,_a_7,_a_4))
   else:
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_a_3,None,_a_0._getDataAsArray_()))
  @staticmethod
  def _match_constTerm_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_constTerm_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  @staticmethod
  def _constTerm_alt_D(_t__a_0):
    return mosek_fusion_Expr._constTerm_D(numpy.float64(__a_0))
  @staticmethod
  def _constTerm_D(_a_0):
   return (mosek_fusion_ExprConst._ctor__3I_3JD(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,_a_0))
  @staticmethod
  def _match_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3_5I__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3_5I__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _constTerm_alt__3I_3_5ID(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.float64(_t__a_2)
   _1_res = mosek_fusion_Expr._constTerm__3I_3_5ID(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _constTerm__3I_3_5ID(_a_0,_a_1,_a_2):
   _a_3=int((_a_1).shape[0])
   _a_4=int((_a_0).shape[0])
   _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int64))
   _a_6[(_a_4 - 1)] = 1
   fragments._c_closure_579(_a_4,_a_6,_a_0) 
   fragments._c_closure_580(_a_3,_a_4,_a_6,_a_5,_a_1) 
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_a_0,_a_5,_a_2))
  @staticmethod
  def _match_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3_5I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3_5I__(_a_1) and __arg_alt_match__3D__(_a_2))
  @staticmethod
  def _constTerm_alt__3I_3_5I_3D(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._constTerm__3I_3_5I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _constTerm__3I_3_5I_3D(_a_0,_a_1,_a_2):
   _a_3=int((_a_1).shape[0])
   _a_4=int((_a_0).shape[0])
   _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
   _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int64))
   _a_6[(_a_4 - 1)] = 1
   fragments._c_closure_581(_a_4,_a_6,_a_0) 
   fragments._c_closure_582(_a_3,_a_4,_a_6,_a_5,_a_1) 
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_a_0,_a_5,_a_2))
  @staticmethod
  def _match_constTerm__3ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3I__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_constTerm__3ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _constTerm_alt__3ID(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.float64(_t__a_1)
   _1_res = mosek_fusion_Expr._constTerm__3ID(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _constTerm__3ID(_a_0,_a_1):
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_a_0,None,_a_1))
  @staticmethod
  def _match_constTerm_ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_constTerm_ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _constTerm_alt_ID(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._constTerm_ID(numpy.int32(__a_0),numpy.float64(__a_1))
  @staticmethod
  def _constTerm_ID(_a_0,_a_1):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([_a_0], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_a_1 for _a_2 in range(0,_a_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  @staticmethod
  def _constTerm_alt__3_5D(_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._constTerm__3_5D(_a_0)
   return _1_res
  @staticmethod
  def _constTerm__3_5D(_a_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_a_0).shape[0]),int((_a_0).shape[1])], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_a_0[_a_1,_a_2] for _a_1 in range(0,int((_a_0).shape[0])) for _a_2 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_constTerm__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _constTerm_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._constTerm__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _constTerm__3D(_a_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_a_0).shape[0])], dtype=numpy.dtype(numpy.int32)),None,_a_0))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3I__(_a_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3I__(_a_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2_3I(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _1_res = mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2_3I(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2_3I(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if ((int((_a_1).shape[0])==0) or (_a_1[0] < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   for _a_3 in range(1,int((_a_1).shape[0])):
    if (_a_1[(_a_3 - 1)] >= _a_1[_a_3]):
     raise mosek_fusion_DimensionError._ctor_S("Unordered dimension indexes")
   if (_a_1[(int((_a_1).shape[0]) - 1)] >= int((_a_2).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Unordered dimension indexes")
   _a_4=int((_a_2).shape[0])
   _a_5=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   _a_6=0
   _a_7=0
   _a_6,_a_7 = fragments._c_closure_583(_a_1,_a_6,_a_7,_a_5)
   _a_6 = numpy.int32(_a_6) # postprocess
   _a_7 = numpy.int32(_a_7) # postprocess
   _a_6,_a_7 = fragments._c_closure_584(_a_6,_a_7,_a_4,_a_5)
   _a_6 = numpy.int32(_a_6) # postprocess
   _a_7 = numpy.int32(_a_7) # postprocess
   _a_7 = fragments._c_closure_585(_a_1,_a_7,_a_5)
   _a_7 = numpy.int32(_a_7) # postprocess
   return (mosek_fusion_ExprSumReduceEnd._ctor_ILmosek_4fusion_4Expression_2(int((_a_1).shape[0]),mosek_fusion_ExprPermuteDims._ctor__3ILmosek_4fusion_4Expression_2(_a_5,_a_0)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2I(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(_a_0,numpy.int32(__a_1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2I(_a_0,_a_1):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2(_t__a_0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(_a_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2(_a_0):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(0,mosek.fusion.Expr._flatten_Lmosek_4fusion_4Expression_2(_a_0)))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Expression_2(_t__a_0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(_a_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Expression_2(_a_0):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2((- 1),_a_0))
  @staticmethod
  def __mulDiag_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
  @staticmethod
  def __mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   _a_3=_a_1._numNonzeros_()
   _a_4=_a_1._numRows_()
   _a_5=_a_1._numColumns_()
   _a_6=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
   _a_7=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_1._getDataAsTriplets__3I_3I_3D(_a_8,_a_7,_a_6)
   if _a_0:
    return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_8,_a_7,_a_6,_a_2))
   else:
    return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_8,_a_7,_a_6,_a_2))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulParamDiagRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0._asExpr_(),_a_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulParamDiagLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulParamDiagRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulParamDiagLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_a_1,_a_0._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_a_0,_a_1._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_a_1,_a_0))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_a_0,_a_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_a_0,_a_1):
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_a_1).shape[0]),int((_a_1).shape[1]),numpy.array([_a_2 for _a_2 in range(0,int((_a_1).shape[0])) for _a_3 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_5 for _a_4 in range(0,int((_a_1).shape[0])) for _a_5 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_1[_a_6,_a_7] for _a_6 in range(0,int((_a_1).shape[0])) for _a_7 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_a_0._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1):
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_a_1).shape[0]),int((_a_1).shape[1]),numpy.array([_a_2 for _a_2 in range(0,int((_a_1).shape[0])) for _a_3 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_5 for _a_4 in range(0,int((_a_1).shape[0])) for _a_5 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_1[_a_6,_a_7] for _a_6 in range(0,int((_a_1).shape[0])) for _a_7 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_a_0))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Variable_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_a_0).shape[0]),int((_a_0).shape[1]),numpy.array([_a_2 for _a_2 in range(0,int((_a_0).shape[0])) for _a_3 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_5 for _a_4 in range(0,int((_a_0).shape[0])) for _a_5 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_0[_a_6,_a_7] for _a_6 in range(0,int((_a_0).shape[0])) for _a_7 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_a_1._asExpr_()))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_a_0).shape[0]),int((_a_0).shape[1]),numpy.array([_a_2 for _a_2 in range(0,int((_a_0).shape[0])) for _a_3 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_5 for _a_4 in range(0,int((_a_0).shape[0])) for _a_5 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_0[_a_6,_a_7] for _a_6 in range(0,int((_a_0).shape[0])) for _a_7 in range(0,int((_a_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_a_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   _a_2=_a_1._getShape_()
   _a_3=_a_1
   if (int((_a_2).shape[0])==1):
    _a_2 = numpy.array([_a_2[0],1], dtype=numpy.dtype(numpy.int32))
    _a_3 = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_a_2,_a_1)
   if ((int((_a_2).shape[0])!=2) or ((_a_0._numRows_()!=_a_2[0]) or (_a_0._numColumns_()!=_a_2[1]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _a_4=_a_0._numColumns_()
   _a_5=_a_0._numNonzeros_()
   _a_6=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.float64))
   _a_0._getDataAsTriplets__3I_3I_3D(_a_6,_a_7,_a_8)
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2I(_a_8,numpy.array([((_a_6[_a_9] * _a_4) + _a_7[_a_9]) for _a_9 in range(0,_a_5)], dtype=numpy.dtype(numpy.int64)),_a_3,1))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   if ((_a_0 is None) or (_a_1 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   if ((_a_1._getND_()==0) and (int((_a_0).shape[0])==1)):
    return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_a_0[0],_a_1))
   elif ((_a_1._getND_()!=1) or (_a_1._getDim_I(0)!=int((_a_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   else:
    return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2(_a_0,numpy.array([_a_2 for _a_2 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   if ((_a_0 is None) or (_a_1 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   _a_2=_a_1._getShape_()
   if (int((_a_2).shape[0])!=int(((_a_0._dims)).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _a_3 in range(0,int(((_a_0._dims)).shape[0])):
    if ((_a_0._dims)[_a_3]!=_a_2[_a_3]):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2((_a_0._cof),(_a_0._inst),_a_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(_a_0,numpy.float64(__a_1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2D(_a_0,_a_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1):
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(False,_a_1,_a_0))
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _mul__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(True,_a_0,_a_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1):
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(False,_a_1,_a_0))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(True,_a_0,_a_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_a_1,_a_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_a_0,_a_1))
  @staticmethod
  def __mul_alt_Z_3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = mosek_fusion_Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __mul_Z_3DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   _a_3=int((_a_1).shape[0])
   _a_4=_a_3
   _a_5=mosek.fusion.Utils.Tools._arraycopy__3D(_a_1)
   _a_6=_a_2._getND_()
   if (_a_6==0):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_3], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_a_3,1,numpy.array([_a_7 for _a_7 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _a_8 in range(0,_a_3)], dtype=numpy.dtype(numpy.int32)),_a_5,_a_2,1)))
   elif (_a_6!=2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   elif (_a_0 and (_a_2._getDim_I(0)==int((_a_1).shape[0]))):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_2._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_3,1,_a_5,_a_2)))
   elif (_a_0 and (_a_2._getDim_I(0)==1)):
    return (mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_3,1,_a_5,_a_2))
   elif ((not _a_0) and (_a_2._getDim_I(1)==_a_3)):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_2._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(1,_a_3,_a_5,_a_2)))
   elif ((not _a_0) and (_a_2._getDim_I(1)==1)):
    return (mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_3,1,_a_5,mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(_a_2)))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_Z_3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _a_2=_t__a_2
   _1_res = mosek_fusion_Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
   return _1_res
  @staticmethod
  def __mul_Z_3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   _a_3=int((_a_1).shape[0])
   _a_4=int((_a_1).shape[1])
   _a_5=(_a_3 * _a_4)
   _a_6=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_586(_a_3,_a_4,_a_6,_a_7,_a_8,_a_1) 
   _a_9=_a_2._getSize_()
   _a_10=_a_2._getShape_()
   if (int((_a_10).shape[0])==0):
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_a_3,_a_4,_a_6,_a_7,_a_8,_a_2,1))
   elif _a_0:
    if (int((_a_10).shape[0])==1):
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_3], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_3,_a_4,_a_8,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_a_10[0]], dtype=numpy.dtype(numpy.int32)),_a_2))))
    elif (int((_a_10).shape[0])==2):
     return (mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_3,_a_4,_a_8,mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(_a_2)))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   else:
    _a_11=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_587(_a_3,_a_4,_a_11,_a_1) 
    if (int((_a_10).shape[0])==1):
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_4], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_4,_a_3,_a_11,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_a_10[0]], dtype=numpy.dtype(numpy.int32)),_a_2))))
    elif (int((_a_10).shape[0])==2):
     return (mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_4,_a_3,_a_11,_a_2)))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
  @staticmethod
  def __mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   _a_3=_a_1._numNonzeros_()
   _a_4=_a_1._numRows_()
   _a_5=_a_1._numColumns_()
   _a_6=_a_2._getND_()
   if (_a_6==0):
    _a_7=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_8=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_9=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
    _a_1._getDataAsTriplets__3I_3I_3D(_a_7,_a_8,_a_9)
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_7,_a_8,_a_9,_a_2))
   if _a_1._isSparse_():
    if (_a_6==1):
     _a_10=_a_2._getShape_()
     if _a_0:
      _a_11=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_12=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_13=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
      _a_1._getDataAsTriplets__3I_3I_3D(_a_11,_a_12,_a_13)
      return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_4], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_11,_a_12,_a_13,mosek.fusion.Expr._transpose_Lmosek_4fusion_4Expression_2(_a_2))))
     else:
      _a_14=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_15=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_16=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
      _a_1._transpose_()._getDataAsTriplets__3I_3I_3D(_a_14,_a_15,_a_16)
      return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_5], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_5,_a_4,_a_14,_a_15,_a_16,_a_2)))
    elif (_a_6==2):
     if _a_0:
      _a_17=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_18=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_19=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
      _a_1._getDataAsTriplets__3I_3I_3D(_a_17,_a_18,_a_19)
      return (mosek_fusion_ExprCrossDot._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_17,_a_18,_a_19,mosek.fusion.Expr._transpose_Lmosek_4fusion_4Expression_2(_a_2)))
     else:
      _a_20=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_21=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
      _a_22=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
      _a_1._transpose_()._getDataAsTriplets__3I_3I_3D(_a_20,_a_21,_a_22)
      return (mosek.fusion.Expr._transpose_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCrossDot._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_a_5,_a_4,_a_20,_a_21,_a_22,_a_2)))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for multiplication")
   else:
    if (_a_6==1):
     _a_23=_a_2._getShape_()
     if _a_0:
      return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_4], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_1._getDataAsArray_(),mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_a_23[0]], dtype=numpy.dtype(numpy.int32)),_a_2))))
     else:
      return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_5], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_5,_a_4,_a_1._transpose_()._getDataAsArray_(),mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_23[0],1], dtype=numpy.dtype(numpy.int32)),_a_2))))
    elif (_a_6==2):
     if _a_0:
      return (mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_4,_a_5,_a_1._getDataAsArray_(),mosek.fusion.Expr._transpose_Lmosek_4fusion_4Expression_2(_a_2)))
     else:
      return (mosek.fusion.Expr._transpose_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCrossDot._ctor_II_3DLmosek_4fusion_4Expression_2(_a_5,_a_4,_a_1._transpose_()._getDataAsArray_(),_a_2)))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2_3_5D(_a_0,_a_1):
   _a_2=int((_a_1).shape[0])
   _a_3=int((_a_1).shape[1])
   _a_4=(_a_2 * _a_3)
   _a_5=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_588(_a_2,_a_3,_a_5,_a_6,_a_7,_a_1) 
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(False,_a_2,_a_3,_a_5,_a_6,_a_7,_a_0))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Variable_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Variable_2(_a_0,_a_1):
   _a_2=int((_a_0).shape[0])
   _a_3=int((_a_0).shape[1])
   _a_4=(_a_2 * _a_3)
   _a_5=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_589(_a_2,_a_3,_a_5,_a_6,_a_7,_a_0) 
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(True,_a_2,_a_3,_a_5,_a_6,_a_7,_a_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   _a_2=_a_1._numRows_()
   _a_3=_a_1._numColumns_()
   _a_4=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _a_5=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.zeros((_a_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _a_1._getDataAsTriplets__3I_3I_3D(_a_6,_a_5,_a_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(False,_a_2,_a_3,_a_6,_a_5,_a_4,_a_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_a_0,_a_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_a_0,_a_1):
   _a_2=_a_0._numRows_()
   _a_3=_a_0._numColumns_()
   _a_4=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _a_5=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _a_0._getDataAsTriplets__3I_3I_3D(_a_6,_a_5,_a_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(True,_a_2,_a_3,_a_6,_a_5,_a_4,_a_1))
  @staticmethod
  def __mul_alt_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6):
   _a_0=_t__a_0
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.int32(_t__a_2)
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int32))
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.float64))
   _a_6=_t__a_6
   _1_res = mosek_fusion_Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6)
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6):
   if (_a_6._getND_()==0):
    return (mosek_fusion_ExprMulScalarVar._ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(_a_1,_a_2,_a_3,_a_4,_a_5,_a_6))
   elif (_a_6._getND_()==1):
    _a_7=_a_6._getShape_()
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([(_a_1 if (_a_0 ) else _a_2)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_a_6,(numpy.array([_a_7[0],1], dtype=numpy.dtype(numpy.int32)) if (_a_0 ) else numpy.array([1,_a_7[0]], dtype=numpy.dtype(numpy.int32)))))))
   else:
    return (mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   if ((_a_1._getND_()==2) and (_a_0._getND_()==2)):
    return (mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1))
   elif ((_a_1._getND_()==1) and (_a_0._getND_()==2)):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1._reshape__3I(numpy.array([_a_1._getDim_I(0),1], dtype=numpy.dtype(numpy.int32))))))
   elif ((_a_1._getND_()==2) and (_a_0._getND_()==1)):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_1._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_a_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),_a_0),_a_1)))
   elif (_a_1._getND_()==0):
    return (mosek_fusion_ExprMulParamScalar._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_1,_a_0))
   elif (_a_0._getND_()==0):
    return (mosek_fusion_ExprMulParamScalarExpr._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_1,_a_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   if ((_a_0._getND_()==2) and (_a_1._getND_()==2)):
    return (mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
   elif ((_a_0._getND_()==1) and (_a_1._getND_()==2)):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_1._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0._reshape__3I(numpy.array([1,_a_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32))),_a_1)))
   elif ((_a_0._getND_()==2) and (_a_1._getND_()==1)):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_a_1._getDim_I(0),1], dtype=numpy.dtype(numpy.int32)),_a_1))))
   elif (_a_0._getND_()==0):
    return (mosek_fusion_ExprMulParamScalar._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
   elif (_a_1._getND_()==0):
    return (mosek_fusion_ExprMulParamScalarExpr._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if ((int((_a_2).shape[0])!=2) or (((_a_1._dimi)!=_a_2[0]) or ((_a_1._dimj)!=_a_2[1]))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   _a_3=_a_1._numNonzeros_()
   if (not _a_1._isSparse_()):
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_a_0,numpy.array([_a_4 for _a_4 in range(0,_a_3)], dtype=numpy.dtype(numpy.int64)),_a_1._getDataAsArray_()))
   else:
    _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_6=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
    _a_7=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
    _a_8=_a_1._numColumns_()
    _a_1._getDataAsTriplets__3I_3I_3D(_a_5,_a_6,_a_7)
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_a_0,numpy.array([((_a_5[_a_9] * _a_8) + _a_6[_a_9]) for _a_9 in range(0,int((_a_5).shape[0]))], dtype=numpy.dtype(numpy.int64)),_a_7))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if (2!=int((_a_2).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   else:
    if ((_a_2[0]!=int((_a_1).shape[0])) or (_a_2[1]!=int((_a_1).shape[1]))):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_a_0,numpy.array([_a_3 for _a_3 in range(0,(int((_a_1).shape[0]) * int((_a_1).shape[1])))], dtype=numpy.dtype(numpy.int64)),numpy.array([_a_1[_a_4,_a_5] for _a_4 in range(0,int((_a_1).shape[0])) for _a_5 in range(0,int((_a_1).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if (int(((_a_1._dims)).shape[0])!=int((_a_2).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   else:
    for _a_3 in range(0,int((_a_2).shape[0])):
     if ((_a_1._dims)[_a_3]!=_a_2[_a_3]):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_a_0,(_a_1._inst),(_a_1._cof)))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if ((_a_0._getSize_()==int((_a_1).shape[0])) and (int((_a_2).shape[0]) > 1)):
    _a_3=0
    _a_3 = fragments._c_closure_590(_a_2,_a_3)
    _a_3 = numpy.int32(_a_3) # postprocess
    if (_a_3 > 1):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
    else:
     _a_4=numpy.array([numpy.int32(_a_0._getSize_())], dtype=numpy.dtype(numpy.int32))
     return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_a_4,_a_0),_a_1))
   else:
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_1,_a_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_1,_a_0))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_a_1,_a_0))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _dot__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3D(_a_1,_a_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek_fusion_ExprDotParam._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek_fusion_ExprDotParam._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   _a_2=_a_1._getShape_()
   if (not ((int((_a_2).shape[0])==1) or ((int((_a_2).shape[0])==2) and (_a_2[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   _a_3=_a_0._getShape_()
   if (not ((_a_0._getND_()==1) or ((_a_0._getND_()==2) and (_a_3[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Parameter argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0._reshape__3I(numpy.array([_a_3[0],1], dtype=numpy.dtype(numpy.int32))),mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_1,1,_a_2[0])))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if (not ((_a_0._getND_()==1) or ((_a_0._getND_()==2) and (_a_2[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   _a_3=_a_1._getShape_()
   if (not ((_a_1._getND_()==1) or ((_a_1._getND_()==2) and (_a_3[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Parameter argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_0,_a_2[0],1),_a_1._reshape__3I(numpy.array([1,_a_3[0]], dtype=numpy.dtype(numpy.int32)))))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   _a_2=_a_1._getShape_()
   if (not ((int((_a_2).shape[0])==1) or ((int((_a_2).shape[0])==2) and (_a_2[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   if ((_a_0._dimj)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_1,1,_a_2[0])))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if (not ((_a_0._getND_()==1) or ((_a_0._getND_()==2) and (_a_2[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   if ((_a_1._dimj)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_0,_a_2[0],1),_a_1._transpose_()))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _outer__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   _a_2=_a_1._getShape_()
   if (not ((_a_1._getND_()==1) or ((_a_1._getND_()==2) and (_a_2[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense_II_3D(int((_a_0).shape[0]),1,_a_0),mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_1,1,_a_2[0])))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2_3D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1):
   _a_2=_a_0._getShape_()
   if (not ((_a_0._getND_()==1) or ((_a_0._getND_()==2) and (_a_2[1]==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_a_0,_a_2[0],1),mosek.fusion.Matrix._dense_II_3D(1,int((_a_1).shape[0]),_a_1)))
  @staticmethod
  def __outer_1_alt_I_3J_3J_3D_3D_3J_3D_3IIZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5,_t__a_6,_t__a_7,_t__a_8,_t__a_9):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int64))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.float64))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int64))
   _a_6=numpy.array(_t__a_6,dtype=numpy.dtype(numpy.float64))
   _a_7=numpy.array(_t__a_7,dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.int32(_t__a_8)
   _a_9=_t__a_9
   _1_res = mosek_fusion_Expr.__outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_6[:] = _a_6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_7[:] = _a_7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5,_a_6,_a_7,_a_8,_a_9):
   _a_10=(mosek.fusion.Set._make_II(_a_0,_a_8) if ((not _a_9) ) else mosek.fusion.Set._make_II(_a_8,_a_0))
   _a_11=(int((_a_6).shape[0]) * int((_a_5).shape[0]))
   _a_12=(int((_a_6).shape[0]) * int((_a_2).shape[0]))
   _a_13=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
   _a_14=(numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.float64)) if ((_a_4 is not None) ) else None)
   _a_15=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.float64))
   _a_16=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int64))
   _a_17=numpy.zeros(((_a_11 + 1),), dtype=numpy.dtype(numpy.int64))
   _a_18=numpy.int32(_a_17[(int((_a_17).shape[0]) - 1)])
   if (not _a_9):
    fragments._c_closure_591(_a_6,_a_14,_a_15,_a_8,_a_4,_a_3,_a_5,_a_1,_a_2,_a_17,_a_7,_a_16) 
   else:
    _a_19=0
    _a_20=0
    for _a_21 in range(0,int((_a_6).shape[0])):
     _a_22=_a_6[_a_21]
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_a_2,0,_a_16,_a_20,_a_18)
     fragments._c_closure_592(_a_6,_a_15,_a_3,_a_18,_a_21,_a_20) 
     _a_19 = fragments._c_closure_593(_a_8,_a_5,_a_1,_a_21,_a_19,_a_17,_a_7)
     _a_19 = numpy.int64(_a_19) # postprocess
     _a_20 += _a_18
    fragments._c_closure_594(_a_6,_a_14,_a_4,_a_5) 
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_a_17,_a_16,_a_15,_a_14,_a_10,_a_13))
  @staticmethod
  def __outer_1_alt_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=_t__a_0
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.int32(_t__a_4)
   _a_5=_t__a_5
   _1_res = mosek_fusion_Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   _a_6=(mosek.fusion.Set._make_II(_a_1,_a_4) if ((not _a_5) ) else mosek.fusion.Set._make_II(_a_4,_a_1))
   _a_7=(None if ((_a_4==int((_a_2).shape[0])) ) else numpy.zeros(((int((_a_2).shape[0]) * _a_1),), dtype=numpy.dtype(numpy.int64)))
   _a_8=numpy.zeros(((int((_a_2).shape[0]) * _a_1),), dtype=numpy.dtype(numpy.float64))
   _a_9=numpy.zeros(((int((_a_2).shape[0]) * _a_1),), dtype=numpy.dtype(numpy.float64))
   _a_10=numpy.zeros(((int((_a_2).shape[0]) * _a_1),), dtype=numpy.dtype(numpy.int64))
   _a_11=numpy.zeros((((int((_a_2).shape[0]) * _a_1) + 1),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_595(_a_2,_a_9,_a_4,_a_7,_a_11,_a_3,_a_10,_a_5,_a_1) 
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_a_11,_a_10,_a_9,_a_8,_a_6,_a_7))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Expression_2(_t__a_0):
   _a_0=_monty.makeJaggedArray(_t__a_0,(1,1),numpy.dtype(object))
   _1_res = mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Expression_2(_a_0):
   if (_a_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _a_1 in range(0,int((_a_0).shape[0])):
    _a_2=_a_0[_a_1]
    if (_a_2 is None):
     raise ValueError("Arguments for stack may not be null")
    for _a_3 in range(0,int((_a_2).shape[0])):
     if (_a_2[_a_3] is None):
      raise ValueError("Arguments for stack may not be null")
   _a_4=numpy.array([mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_a_0[_a_5],1) for _a_5 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(object))
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_a_4,0))
  @staticmethod
  def _match_vstack_DDD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_D__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_vstack_DDD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _vstack_alt_DDD(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_DDD(numpy.float64(__a_0),numpy.float64(__a_1),numpy.float64(__a_2))
  @staticmethod
  def _vstack_DDD(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),mosek.fusion.Expr._constTerm_D(_a_1),mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__a_0),numpy.float64(__a_1),_a_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),mosek.fusion.Expr._constTerm_D(_a_1),_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__a_0),_a_1,numpy.float64(__a_2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),_a_1,mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1,_a_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),_a_1,_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DD(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(_a_0,numpy.float64(__a_1),numpy.float64(__a_2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DD(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,mosek.fusion.Expr._constTerm_D(_a_1),mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_a_0,numpy.float64(__a_1),_a_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,mosek.fusion.Expr._constTerm_D(_a_1),_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_a_0,_a_1,numpy.float64(__a_2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,_a_1,mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),_a_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(_a_0,numpy.float64(__a_1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2D(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,mosek.fusion.Expr._constTerm_D(_a_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Expression_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Expression_2(_a_0):
   if (_a_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _a_1 in range(0,int((_a_0).shape[0])):
    if (_a_0[_a_1] is None):
     raise ValueError("Arguments for vstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_a_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   if ((_a_0 is None) or ((_a_1 is None) or (_a_2 is None))):
    raise ValueError("Arguments e1, e2 and e3 may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,_a_1,_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_a_0,_a_1,numpy.float64(__a_2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,_a_1,mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_a_0,numpy.float64(__a_1),_a_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,mosek.fusion.Expr._constTerm_D(_a_1),_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DD(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(_a_0,numpy.float64(__a_1),numpy.float64(__a_2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DD(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,mosek.fusion.Expr._constTerm_D(_a_1),mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1,_a_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),_a_1,_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__a_0),_a_1,numpy.float64(__a_2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),_a_1,mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_D__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__a_0),numpy.float64(__a_1),_a_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),mosek.fusion.Expr._constTerm_D(_a_1),_a_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_0),_a_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(_a_0,numpy.float64(__a_1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2D(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,mosek.fusion.Expr._constTerm_D(_a_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_0,_a_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Expression_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Expression_2(_a_0):
   if (_a_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _a_1 in range(0,int((_a_0).shape[0])):
    if (_a_0[_a_1] is None):
     raise ValueError("Arguments for hstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_a_0,1))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__a_0),_a_1,_a_2,_a_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_1,_a_2,_a_3], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_match_D__(_a_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_alt_match_D__(_a_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(numpy.int32(__a_0),_a_1,_a_2,numpy.float64(__a_3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_1,_a_2,mosek.fusion.Expr._constTerm_D(_a_3)], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(numpy.int32(__a_0),_a_1,numpy.float64(__a_2),_a_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_1,mosek.fusion.Expr._constTerm_D(_a_2),_a_3], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2) and __arg_match_D__(_a_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2) and __arg_alt_match_D__(_a_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DD(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(numpy.int32(__a_0),_a_1,numpy.float64(__a_2),numpy.float64(__a_3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DD(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_1,mosek.fusion.Expr._constTerm_D(_a_2),mosek.fusion.Expr._constTerm_D(_a_3)], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__a_0),numpy.float64(__a_1),_a_2,_a_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_1),_a_2,_a_3], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_match_D__(_a_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2) and __arg_alt_match_D__(_a_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(numpy.int32(__a_0),numpy.float64(__a_1),_a_2,numpy.float64(__a_3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_1),_a_2,mosek.fusion.Expr._constTerm_D(_a_3)], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1) and __arg_match_D__(_a_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_D__(_a_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(numpy.int32(__a_0),numpy.float64(__a_1),numpy.float64(__a_2),_a_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2,_a_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_1),mosek.fusion.Expr._constTerm_D(_a_2),_a_3], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(numpy.int32(__a_0),numpy.float64(__a_1),_a_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_a_1),_a_2], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(numpy.int32(__a_0),_a_1,numpy.float64(__a_2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_1,mosek.fusion.Expr._constTerm_D(_a_2)], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__a_0),_a_1,_a_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_a_1,_a_2], dtype=numpy.dtype(object)),_a_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match__3Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_a_1,_a_0))
  @staticmethod
  def __stack_1_alt__3Lmosek_4fusion_4Expression_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __stack_1__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1):
   if (int((_a_0).shape[0])==1):
    return (_a_0[0])
   else:
    return (mosek_fusion_ExprStack._ctor__3Lmosek_4fusion_4Expression_2I(mosek.fusion.Expr.__promote__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1),_a_1))
  @staticmethod
  def __promote_alt__3Lmosek_4fusion_4Expression_2I(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Expr.__promote__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __promote__3Lmosek_4fusion_4Expression_2I(_a_0,_a_1):
   _a_2=int((_a_0).shape[0])
   _a_3=numpy.array([_a_0[_a_4]._getND_() for _a_4 in range(0,_a_2)], dtype=numpy.dtype(numpy.int32))
   _a_5=_a_3[0]
   _a_6=_a_3[0]
   _a_5,_a_6 = fragments._c_closure_596(_a_5,_a_6,_a_2,_a_3)
   _a_5 = numpy.int32(_a_5) # postprocess
   _a_6 = numpy.int32(_a_6) # postprocess
   if (_a_5 < _a_1):
    _a_5 = _a_1
   if (_a_6 < _a_5):
    _a_7=numpy.ndarray((_a_2,), dtype=numpy.dtype(object))
    _a_8=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
    for _a_9 in range(0,_a_2):
     if (_a_0[_a_9]._getND_()==_a_5):
      _a_7[_a_9] = _a_0[_a_9]
     else:
      _a_10=_a_0[_a_9]._getShape_()
      fragments._c_closure_597(_a_10,_a_8) 
      fragments._c_closure_598(_a_5,_a_10,_a_8) 
      _a_7[_a_9] = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_a_8,_a_0[_a_9])
    return (_a_7)
   else:
    return (_a_0)
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Variable_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_a_0,_a_1,_a_2):
   return (mosek.fusion.Expr._repeat_Lmosek_4fusion_4Expression_2II(_a_0._asExpr_(),_a_1,_a_2))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Expression_2II(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(_a_0,numpy.int32(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Expression_2II(_a_0,_a_1,_a_2):
   if (_a_1 <= 0):
    raise mosek_fusion_DimensionError._ctor_S("Cannot repeat Expression 0 or less times")
   if ((_a_2 < 0) or (_a_2 > _a_0._getND_())):
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   else:
    if (_a_2==_a_0._getND_()):
     _a_3=numpy.zeros(((_a_2 + 1),), dtype=numpy.dtype(numpy.int32))
     for _a_4 in range(0,_a_2):
      _a_3[_a_4] = _a_0._getDim_I(_a_4)
     _a_3[_a_2] = 1
     return (mosek_fusion_ExprRepeat._ctor_Lmosek_4fusion_4Expression_2II(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_a_0,_a_3),_a_2,_a_1))
    else:
     return (mosek_fusion_ExprRepeat._ctor_Lmosek_4fusion_4Expression_2II(_a_0,_a_2,_a_1))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Expression_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _add__3Lmosek_4fusion_4Expression_2(_a_0):
   return (mosek_fusion_ExprWSum._ctor__3Lmosek_4fusion_4Expression_2_3D(_a_0,numpy.array([1.0 for _a_1 in range(0,int((_a_0).shape[0]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_a_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Variable_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _add__3Lmosek_4fusion_4Variable_2(_a_0):
   if (_a_0 is None):
    raise ValueError("Argument vs may not be null")
   if (int((_a_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if ((int((_a_0).shape[0]) > 0) and (_a_0[0] is None)):
    raise ValueError("Argument vs may contain null")
   _a_1=_a_0[0]._getND_()
   for _a_2 in range(1,int((_a_0).shape[0])):
    if (_a_1 < _a_0[_a_2]._getND_()):
     _a_1 = _a_0[_a_2]._getND_()
   _a_3=numpy.zeros((int((_a_0).shape[0]),_a_1,), dtype=numpy.dtype(numpy.int32))
   for _a_4 in range(0,int((_a_0).shape[0])):
    _a_5=_a_0[_a_4]._getShape_()
    fragments._c_closure_599(_a_4,_a_3,_a_5) 
    fragments._c_closure_600(_a_4,_a_1,_a_3,_a_5) 
   for _a_6 in range(1,int((_a_0).shape[0])):
    for _a_7 in range(0,_a_1):
     if (_a_3[0,_a_7]!=_a_3[_a_6,_a_7]):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _a_8=numpy.array([_a_3[0,_a_9] for _a_9 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32))
   _a_10=1
   _a_10 = fragments._c_closure_601(_a_1,_a_8,_a_10)
   _a_10 = numpy.int32(_a_10) # postprocess
   _a_11=0
   _a_12=0
   for _a_13 in range(0,int((_a_0).shape[0])):
    _a_14=_a_0[_a_13]._numInst_()
    _a_11 += _a_14
    _a_12 = (_a_12 if ((_a_12 > _a_14) ) else _a_14)
   _a_15=numpy.zeros(((_a_10 + 1),), dtype=numpy.dtype(numpy.int64))
   _a_16=numpy.zeros((_a_11,), dtype=numpy.dtype(numpy.int64))
   _a_17=numpy.array([1.0 for _a_18 in range(0,_a_11)], dtype=numpy.dtype(numpy.float64))
   _a_19=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int64))
   _a_20=numpy.zeros((_a_12,), dtype=numpy.dtype(numpy.int64))
   for _a_21 in range(0,int((_a_0).shape[0])):
    _a_22=_a_0[_a_21]._inst_I_3JI_3J(0,_a_19,0,_a_20)
    fragments._c_closure_602(_a_19,_a_22,_a_15) 
   fragments._c_closure_603(_a_15,_a_10) 
   for _a_23 in range(0,int((_a_0).shape[0])):
    _a_24=_a_0[_a_23]._inst_I_3JI_3J(0,_a_19,0,_a_20)
    fragments._c_closure_604(_a_20,_a_19,_a_24,_a_15,_a_16) 
   fragments._c_closure_605(_a_15,_a_10) 
   _a_15[0] = 0
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(_a_15,_a_16,_a_17,numpy.array([0.0 for _a_25 in range(0,_a_10)], dtype=numpy.dtype(numpy.float64)),_a_8,None,1))
  @staticmethod
  def __add_1_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return mosek_fusion_Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,numpy.float64(__a_1),_a_2,numpy.float64(__a_3))
  @staticmethod
  def __add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,_a_1,_a_2,_a_3):
   _a_4=_a_0._getND_()
   _a_5=_a_2._getND_()
   if (_a_4==_a_5):
    return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_a_0,_a_2,_a_1,_a_3))
   else:
    _a_6=(_a_4 if ((_a_4 > _a_5) ) else _a_5)
    _a_7=numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int32))
    if (_a_4 < _a_5):
     _a_8=_a_0._getShape_()
     fragments._c_closure_606(_a_4,_a_8,_a_7) 
     fragments._c_closure_607(_a_6,_a_4,_a_7) 
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_a_7,_a_0),_a_2,_a_1,_a_3))
    else:
     _a_9=_a_2._getShape_()
     fragments._c_closure_608(_a_5,_a_9,_a_7) 
     fragments._c_closure_609(_a_6,_a_5,_a_7) 
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_a_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_a_7,_a_2),_a_1,_a_3))
  @staticmethod
  def _match_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _match_alt_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0))
  @staticmethod
  def _transpose_alt_Lmosek_4fusion_4Expression_2(_t__a_0):
    return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(_a_0)
  @staticmethod
  def _transpose_Lmosek_4fusion_4Expression_2(_a_0):
   if (_a_0._getND_()==0):
    return (_a_0)
   elif (_a_0._getND_()==1):
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_a_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),_a_0))
   elif (_a_0._getND_()==2):
    return (mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(_a_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Incorrect number of dimensions for transpose")
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_a_0),_a_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_a_1),_a_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulParamElem._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_0,_a_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_a_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_a_0,_a_1):
   return (mosek_fusion_ExprMulParamElem._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_a_1,_a_0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_a_0),1.0,_a_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_a_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_a_0),1.0,_a_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_a_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3ID(_a_1._getShape_(),_a_0),1.0,_a_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(_a_0,numpy.float64(__a_1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2D(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm__3ID(_a_0._getShape_(),_a_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_a_0),1.0,_a_1,(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sub__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_a_0),1.0,_a_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_a_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm__3D(_a_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,_a_1,(- 1.0)))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_a_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_a_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_a_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_a_1),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(numpy.float64(__a_0),_a_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_1,1.0,mosek.fusion.Expr._constTerm__3ID(_a_1._getShape_(),_a_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2D(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(_a_0,numpy.float64(__a_1))
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2D(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm__3ID(_a_0._getShape_(),_a_1),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3_5D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3_5D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_1,1.0,mosek.fusion.Expr._constTerm__3_5D(_a_0),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=_t__a_1
   _1_res = mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _add__3DLmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_1,1.0,mosek.fusion.Expr._constTerm__3D(_a_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3_5D__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3_5D__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1)
   return _1_res
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3_5D(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_a_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match__3D__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match__3D__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3D(_t__a_0,_t__a_1):
   _a_0=_t__a_0
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3D(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,mosek.fusion.Expr._constTerm__3D(_a_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_a_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__a_0,_t__a_1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_a_0,_a_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_a_0,1.0,_a_1,1.0))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__a_0,_t__a_1,_t__a_2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_a_0,_a_1,_a_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_a_0,_a_1,_a_2):
   _a_3=(int((self.__ptrb).shape[0]) - 1)
   _a_4=numpy.int32(self.__ptrb[_a_3])
   _a_5=True
   _a_5 = fragments._c_closure_610(self.__bfix,_a_3,_a_5)
   if (not _a_5):
    _a_4 += _a_3
   _a_6=int((self.__shape).shape[0])
   _a_0._alloc_1expr_IIIZ(_a_6,_a_3,_a_4,(self.__inst is not None))
   _a_7=(_a_0.ptr_base)
   _a_8=(_a_0.nidxs_base)
   _a_9=(_a_0.sp_base)
   _a_10=(_a_0.cof_base)
   _a_11=(_a_0.shape_base)
   _a_12=(_a_0.i32)
   _a_13=(_a_0.i64)
   _a_14=(_a_0.f64)
   fragments._c_closure_611(self.__bfix,_a_10,self.__cof_v,_a_14,_a_12,_a_13,_a_6,_a_3,_a_8,_a_7,self.__ptrb,self.__shape,_a_11,self.__subj,_a_5) 
  @staticmethod
  def __validateData_alt__3J_3J_3D_3D_3I_3J(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4,_t__a_5):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int64))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.float64))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.int32))
   _a_5=numpy.array(_t__a_5,dtype=numpy.dtype(numpy.int64))
   _1_res = mosek_fusion_Expr.__validateData__3J_3J_3D_3D_3I_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_5[:] = _a_5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __validateData__3J_3J_3D_3D_3I_3J(_a_0,_a_1,_a_2,_a_3,_a_4,_a_5):
   if (_a_4 is None):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'shape' in expression is null")
   _a_6=(int((_a_0).shape[0]) - 1)
   _a_7=_a_0[(int((_a_0).shape[0]) - 1)]
   _a_8=int((_a_4).shape[0])
   _a_9=1
   _a_9 = fragments._c_closure_612(_a_8,_a_4,_a_9)
   _a_9 = numpy.int64(_a_9) # postprocess
   if (int((_a_0).shape[0]) < 1):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong size")
   if (_a_7!=int((_a_1).shape[0])):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'subj' in expression has wrong size")
   if (_a_7!=int((_a_2).shape[0])):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'cof' in expression has wrong size")
   if ((_a_3 is None) or (_a_6!=int((_a_3).shape[0]))):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'bfix' in expression has wrong length")
   if ((_a_5 is not None) and (int((_a_5).shape[0]) < _a_9)):
    if (int((_a_5).shape[0])!=(int((_a_0).shape[0]) - 1)):
     raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' in expression has wrong length")
    if (int((_a_5).shape[0]) > 0):
     if ((_a_5[0] < 0) or (_a_5[0] >= _a_9)):
      raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' contains an invalid index")
     _a_10=True
     _a_11=_a_9
     _a_10 = fragments._c_closure_613(_a_5,_a_10,_a_11)
     if (not _a_10):
      raise mosek_fusion_ExpressionError._ctor_S("Invalid array 'inst'")
   else:
    if (_a_9!=(int((_a_0).shape[0]) - 1)):
     raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong length")
   _a_12=False
   _a_13=False
   if (_a_0[0]!=0):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _a_14=True
   _a_14 = fragments._c_closure_614(_a_6,_a_0,_a_14)
   if (not _a_14):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
  @staticmethod
  def __extractModel_alt__3Lmosek_4fusion_4Variable_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Expr.__extractModel__3Lmosek_4fusion_4Variable_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def __extractModel__3Lmosek_4fusion_4Variable_2(_a_0):
   return ((None if (((_a_0 is None) or (int((_a_0).shape[0])==0)) ) else _a_0[0]._getModel_()))
 return Expr
mosek_fusion_Expr=__mk_mosek_fusion_Expr()
del __mk_mosek_fusion_Expr
#BEFORE CLASS
def __mk_mosek_fusion_WorkStack():
 class WorkStack(object):
  __slots__ = ['code_base','cconst_base','codeptr_base','cof_base','nidxs_base','sp_base','shape_base','ptr_base','hassp','ncodeatom','nelem','nnz','nd','pf64','pi64','pi32','f64','i64','i32']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.WorkStack.ctor()')
  def ensuref64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.ensuref64(int32)

    Description
    -----------

    Make sure that the double stack has capacity for n new items

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_ensuref64_I(*args):
      return self._ensuref64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensuref64_I(*args):
      return self._ensuref64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensuref64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensuref64(int32)')
  def validate(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.validate()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_validate_(*args):
      return self._validate_(*args)
    elif mosek_fusion_WorkStack._match_alt_validate_(*args):
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.validate()')
  def popf64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.popf64()
      mosek.fusion.WorkStack.popf64(int32)
      mosek.fusion.WorkStack.popf64(int32,array(double,ndim=1),int32)

    Description
    -----------

    Pop one or more double items from stack

    Parameters
    ----------

    n : int32
        Number of items to pop (default is 1)
    ofs : int32
        Copy popped items to this offset in `r`
    r : array(double,ndim=1)
        Copy popped item to this array
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_popf64_(*args):
      return self._popf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_(*args):
      return self._popf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popf64_I(*args):
      return self._popf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I(*args):
      return self._popf64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popf64_I_3DI(*args):
      return self._popf64_I_3DI(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I_3DI(*args):
      return self._popf64_alt_I_3DI(*args)
    else:
      raise ValueError('Invalid argument list popf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popf64()\n\tmosek.fusion.WorkStack.popf64(int32)\n\tmosek.fusion.WorkStack.popf64(int32,array(double,ndim=1),int32)')
  def peekf64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peekf64()
      mosek.fusion.WorkStack.peekf64(int32)

    Description
    -----------

    Peek at one double item from stack

    Parameters
    ----------

    i : int32
        Peek at this index on the stack (default is 0)
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peekf64_(*args):
      return self._peekf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_(*args):
      return self._peekf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peekf64_I(*args):
      return self._peekf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_I(*args):
      return self._peekf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peekf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peekf64()\n\tmosek.fusion.WorkStack.peekf64(int32)')
  def peek_hassp(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peek_hassp()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1hassp_(*args):
      return self._peek_1hassp_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1hassp_(*args):
      return self._peek_1hassp_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_hassp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_hassp()')
  def peek_expr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peek_expr()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1expr_(*args):
      return self._peek_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1expr_(*args):
      return self._peek_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_expr()')
  def peek_nnz(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peek_nnz()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nnz_(*args):
      return self._peek_1nnz_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nnz_(*args):
      return self._peek_1nnz_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nnz('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nnz()')
  def pop_expr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.pop_expr()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_pop_1expr_(*args):
      return self._pop_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_pop_1expr_(*args):
      return self._pop_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list pop_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pop_expr()')
  def popi64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.popi64()
      mosek.fusion.WorkStack.popi64(int32)
      mosek.fusion.WorkStack.popi64(int32,array(int64,ndim=1),int32)

    Description
    -----------

    Pop one or more int64 items from stack

    Parameters
    ----------

    n : int32
        Number of items to pop (default is 1)
    ofs : int32
        Copy popped items to this offset in `r`
    r : array(int64,ndim=1)
        Copy popped item to this array
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_popi64_(*args):
      return self._popi64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_(*args):
      return self._popi64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi64_I(*args):
      return self._popi64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I(*args):
      return self._popi64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi64_I_3JI(*args):
      return self._popi64_I_3JI(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I_3JI(*args):
      return self._popi64_alt_I_3JI(*args)
    else:
      raise ValueError('Invalid argument list popi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi64()\n\tmosek.fusion.WorkStack.popi64(int32)\n\tmosek.fusion.WorkStack.popi64(int32,array(int64,ndim=1),int32)')
  def peek_dim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peek_dim(int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1dim_I(*args):
      return self._peek_1dim_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1dim_I(*args):
      return self._peek_1dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peek_dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_dim(int32)')
  def allocf64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.allocf64(int32)

    Description
    -----------

    Allocate n doubles and return the stack index of the first

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_allocf64_I(*args):
      return self._allocf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_allocf64_I(*args):
      return self._allocf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list allocf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.allocf64(int32)')
  def pushi32(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.pushi32(int32)

    Description
    -----------

    Push an int32 value

    Parameters
    ----------

    v : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi32_I(*args):
      return self._pushi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi32_I(*args):
      return self._pushi32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list pushi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi32(int32)')
  def clear(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.clear()

    Description
    -----------

    Clear all stacks

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_clear_(*args):
      return self._clear_(*args)
    elif mosek_fusion_WorkStack._match_alt_clear_(*args):
      return self._clear_alt_(*args)
    else:
      raise ValueError('Invalid argument list clear('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.clear()')
  def peek_nd(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peek_nd()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nd_(*args):
      return self._peek_1nd_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nd_(*args):
      return self._peek_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nd()')
  def peek_nelem(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peek_nelem()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nelem_(*args):
      return self._peek_1nelem_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nelem_(*args):
      return self._peek_1nelem_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nelem('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nelem()')
  def formatCurrent(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.formatCurrent()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_formatCurrent_(*args):
      return self._formatCurrent_(*args)
    elif mosek_fusion_WorkStack._match_alt_formatCurrent_(*args):
      return self._formatCurrent_alt_(*args)
    else:
      raise ValueError('Invalid argument list formatCurrent('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.formatCurrent()')
  def alloci32(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.alloci32(int32)

    Description
    -----------

    Allocate n int32s and return the stack index of the first

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci32_I(*args):
      return self._alloci32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci32_I(*args):
      return self._alloci32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci32(int32)')
  def peeki32(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peeki32()
      mosek.fusion.WorkStack.peeki32(int32)

    Description
    -----------

    Peek at one int32 item from stack

    Parameters
    ----------

    i : int32
        Peek at this index on the stack (default is 0)
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki32_(*args):
      return self._peeki32_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_(*args):
      return self._peeki32_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki32_I(*args):
      return self._peeki32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_I(*args):
      return self._peeki32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki32()\n\tmosek.fusion.WorkStack.peeki32(int32)')
  def peeki64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.peeki64()
      mosek.fusion.WorkStack.peeki64(int32)

    Description
    -----------

    Peek at one int64 item from stack

    Parameters
    ----------

    i : int32
        Peek at this index on the stack (default is 0)
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki64_(*args):
      return self._peeki64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_(*args):
      return self._peeki64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki64_I(*args):
      return self._peeki64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_I(*args):
      return self._peeki64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki64()\n\tmosek.fusion.WorkStack.peeki64(int32)')
  def alloci64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.alloci64(int32)

    Description
    -----------

    Allocate n int64s and return the stack index of the first

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci64_I(*args):
      return self._alloci64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci64_I(*args):
      return self._alloci64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci64(int32)')
  def ensurei64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.ensurei64(int32)

    Description
    -----------

    Make sure that the int64 stack has capacity for n new items

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei64_I(*args):
      return self._ensurei64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei64_I(*args):
      return self._ensurei64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei64(int32)')
  def alloc_expr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool)
      mosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool,int32)

    Description
    -----------

    

    Parameters
    ----------

    hassp : bool
    ncodeatom : int32
    nd : int32
    nelem : int32
    nnz : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZ(*args):
      return self._alloc_1expr_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZ(*args):
      return self._alloc_1expr_alt_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZI(*args):
      return self._alloc_1expr_IIIZI(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZI(*args):
      return self._alloc_1expr_alt_IIIZI(*args)
    else:
      raise ValueError('Invalid argument list alloc_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool)\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool,int32)')
  def popi32(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.popi32()
      mosek.fusion.WorkStack.popi32(int32)
      mosek.fusion.WorkStack.popi32(int32,array(int32,ndim=1),int32)

    Description
    -----------

    Pop one or more int32 items from stack

    Parameters
    ----------

    n : int32
        Number of items to pop (default is 1)
    ofs : int32
        Copy popped items to this offset in `r`
    r : array(int32,ndim=1)
        Copy popped item to this array
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_popi32_(*args):
      return self._popi32_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_(*args):
      return self._popi32_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi32_I(*args):
      return self._popi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I(*args):
      return self._popi32_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi32_I_3II(*args):
      return self._popi32_I_3II(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I_3II(*args):
      return self._popi32_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list popi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi32()\n\tmosek.fusion.WorkStack.popi32(int32)\n\tmosek.fusion.WorkStack.popi32(int32,array(int32,ndim=1),int32)')
  def ensurei32(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.ensurei32(int32)

    Description
    -----------

    Make sure that the int32 stack has capacity for n new items

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei32_I(*args):
      return self._ensurei32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei32_I(*args):
      return self._ensurei32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei32(int32)')
  def move_expr(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.move_expr(mosek.fusion.WorkStack)

    Description
    -----------

    

    Parameters
    ----------

    to : mosek.fusion.WorkStack
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
      return self._move_1expr_Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_WorkStack._match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
      return self._move_1expr_alt_Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list move_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.move_expr(mosek.fusion.WorkStack)')
  def ensure_sparsity(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.ensure_sparsity()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_ensure_1sparsity_(*args):
      return self._ensure_1sparsity_(*args)
    elif mosek_fusion_WorkStack._match_alt_ensure_1sparsity_(*args):
      return self._ensure_1sparsity_alt_(*args)
    else:
      raise ValueError('Invalid argument list ensure_sparsity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensure_sparsity()')
  def pushf64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.pushf64(double)

    Description
    -----------

    Push an double value

    Parameters
    ----------

    v : double
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_pushf64_D(*args):
      return self._pushf64_D(*args)
    elif mosek_fusion_WorkStack._match_alt_pushf64_D(*args):
      return self._pushf64_alt_D(*args)
    else:
      raise ValueError('Invalid argument list pushf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushf64(double)')
  def validate_all(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.validate_all()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_validate_1all_(*args):
      return self._validate_1all_(*args)
    elif mosek_fusion_WorkStack._match_alt_validate_1all_(*args):
      return self._validate_1all_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate_all('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.validate_all()')
  def pushi64(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.WorkStack.pushi64(int64)

    Description
    -----------

    Push an int64 value

    Parameters
    ----------

    v : int64
    '''
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi64_J(*args):
      return self._pushi64_J(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi64_J(*args):
      return self._pushi64_alt_J(*args)
    else:
      raise ValueError('Invalid argument list pushi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi64(int64)')
  def __repr__(self): return 'mosek.fusion.WorkStack'
  @staticmethod
  def _ctor_():
    o = WorkStack.__new__(WorkStack)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self.i32 = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
   self.i64 = numpy.zeros((128,), dtype=numpy.dtype(numpy.int64))
   self.f64 = numpy.zeros((128,), dtype=numpy.dtype(numpy.float64))
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
   self.nd = 0
   self.nnz = 0
   self.nelem = 0
   self.hassp = False
   self.ncodeatom = 0
   self.ptr_base = 0
   self.shape_base = 0
   self.sp_base = 0
   self.nidxs_base = 0
   self.cof_base = 0
   self.cconst_base = 0
   self.code_base = 0
   self.codeptr_base = 0
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   self.__validate_1from_IIIZ(self.pi32,self.pi64,self.pf64,False)
  @staticmethod
  def _match_validate_1all_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_1all_(*args):
    if len(args) != 0: return False
    return True
  def _validate_1all_alt_(self,):
    return self._validate_1all_()
  def _validate_1all_(self,):
   self.__validate_1from_IIIZ(self.pi32,self.pi64,self.pf64,True)
  def __validate_1from_alt_IIIZ(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return self.__validate_1from_IIIZ(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2),_a_3)
  def __validate_1from_IIIZ(self,_a_0,_a_1,_a_2,_a_3):
   _a_4=self.i32[(_a_0 - 1)]
   _a_5=self.i32[((_a_0 - _a_4) - 2)]
   _a_6=self.i32[((_a_0 - _a_4) - 3)]
   _a_7=(self.i32[((_a_0 - _a_4) - 4)]!=0)
   _a_8=self.i32[((_a_0 - _a_4) - 5)]
   _a_9=(((_a_0 - _a_4) - 6) - _a_5)
   _a_10=((_a_9 - (_a_6 + 1)) if ((_a_8 > 0) ) else _a_9)
   _a_11=(_a_10 - _a_8)
   _a_12=((_a_1 - _a_5) if (_a_7 ) else _a_1)
   _a_13=(_a_12 - _a_6)
   _a_14=(_a_2 - _a_6)
   _a_15=(_a_14 - _a_8)
   _a_16=1
   _a_16 = fragments._c_closure_615(_a_0,self.i32,_a_4,_a_16)
   _a_16 = numpy.int64(_a_16) # postprocess
   if (_a_16 < _a_5):
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid shape/nelem")
   if ((_a_16 > _a_5) and (not _a_7)):
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid hassp/nelem/shape")
   if (_a_6 < self.i32[(_a_9 + _a_5)]):
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid ptr/nnz")
   for _a_17 in range(0,_a_5):
    if (self.i32[(_a_9 + _a_17)] > self.i32[((_a_9 + _a_17) + 1)]):
     raise mosek_fusion_UnexpectedError._ctor_S("Invalid ptr, not ascending")
   if _a_7:
    for _a_18 in range(0,(_a_5 - 1)):
     if (self.i64[(_a_12 + _a_18)] > self.i64[((_a_12 + _a_18) + 1)]):
      raise mosek_fusion_UnexpectedError._ctor_S("Invalid sp - not sorted")
   if (_a_8 > 0):
    for _a_19 in range(0,_a_6):
     if (self.i32[(_a_10 + _a_19)] > self.i32[((_a_10 + _a_19) + 1)]):
      raise mosek_fusion_UnexpectedError._ctor_S("Invalid codeptr - not ascending")
    for _a_20 in range(0,_a_6):
     _a_21=0
     for _a_22 in range(self.i32[(_a_10 + _a_20)],self.i32[((_a_10 + _a_20) + 1)]):
      _a_23=self.i32[(_a_11 + _a_22)]
      if (_a_23==0):
       pass
      elif ((_a_23==1) or ((_a_23==2) or (_a_23==10))):
       _a_21 += 1
      elif ((_a_23==3) or (_a_23==5)):
       if (_a_21 < 2):
        raise mosek_fusion_UnexpectedError._ctor_S("Code stack underflow")
       _a_21 -= 1
      elif ((_a_23==4) or (_a_23==6)):
       if (_a_21 < 1):
        raise mosek_fusion_UnexpectedError._ctor_S("Code stack underflow")
      elif (_a_23==8):
       _a_24=numpy.int32(self.f64[(_a_15 + _a_22)])
       if (_a_24 > _a_21):
        raise mosek_fusion_UnexpectedError._ctor_S("Code stack underflow in SUM")
       _a_21 -= (_a_24 - 1)
      else:
       raise mosek_fusion_UnexpectedError._ctor_S("Invalid code list opcode")
     if (_a_21!=1):
      raise mosek_fusion_UnexpectedError._ctor_S("Invalid code list result")
   if _a_3:
    self.__validate_1from_IIIZ(_a_11,_a_13,_a_15,_a_3)
  @staticmethod
  def _match_formatCurrent_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_formatCurrent_(*args):
    if len(args) != 0: return False
    return True
  def _formatCurrent_alt_(self,):
    return self._formatCurrent_()
  def _formatCurrent_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("  nelem     = ")._a_I(self.nelem)._a_S("\n")._a_S("  nnz       = ")._a_I(self.nnz)._a_S("\n")._a_S("  hassp     = ")._a_Z(self.hassp)._a_S(" / ")._a_Z(self.hassp)._a_S("\n")._a_S("  shape     = ")._a__3I(numpy.array([self.i32[(self.shape_base + _a_1)] for _a_1 in range(0,self.nd)], dtype=numpy.dtype(numpy.int32)))._a_S("\n")._a_S("  ptr       = ")._a__3I(numpy.array([self.i32[(self.ptr_base + _a_2)] for _a_2 in range(0,(self.nelem + 1))], dtype=numpy.dtype(numpy.int32)))._a_S("\n")
   if (self.ncodeatom > 0):
    _a_0._a_S("  codeptr   = ")._a__3I(numpy.array([self.i32[(self.codeptr_base + _a_3)] for _a_3 in range(0,(self.nnz + 1))], dtype=numpy.dtype(numpy.int32)))._a_S("\n")
   if self.hassp:
    _a_0._a_S("  sp        = ")._a__3J(numpy.array([self.i64[(self.sp_base + _a_4)] for _a_4 in range(0,self.nelem)], dtype=numpy.dtype(numpy.int64)))._a_S("\n")
   for _a_5 in range(0,self.nelem):
    _a_0._a_S("  row[")._a_I(_a_5)._a_S("]")._a_S("\n")._a_S("    nidx : ")._a__3J(numpy.array([self.i64[(self.nidxs_base + _a_6)] for _a_6 in range(self.i32[(self.ptr_base + _a_5)],self.i32[((self.ptr_base + _a_5) + 1)])], dtype=numpy.dtype(numpy.int64)))._a_S("\n")._a_S("    cof  : ")._a__3D(numpy.array([self.f64[(self.cof_base + _a_7)] for _a_7 in range(self.i32[(self.ptr_base + _a_5)],self.i32[((self.ptr_base + _a_5) + 1)])], dtype=numpy.dtype(numpy.float64)))._a_S("\n")
    if (self.ncodeatom > 0):
     for _a_8 in range(self.i32[(self.ptr_base + _a_5)],self.i32[((self.ptr_base + _a_5) + 1)]):
      _a_0._a_S("      code[")._a_J(self.i64[(self.nidxs_base + _a_8)])._a_S("] ")._a__3I(numpy.array([self.i32[(self.code_base + _a_9)] for _a_9 in range(self.i32[(self.codeptr_base + _a_8)],self.i32[((self.codeptr_base + _a_8) + 1)])], dtype=numpy.dtype(numpy.int32)))._a__3D(numpy.array([self.f64[(self.cconst_base + _a_10)] for _a_10 in range(self.i32[(self.codeptr_base + _a_8)],self.i32[((self.codeptr_base + _a_8) + 1)])], dtype=numpy.dtype(numpy.float64)))._a_S("\n")
   return (_a_0._toString_())
  @staticmethod
  def _match_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1hassp_alt_(self,):
    return self._peek_1hassp_()
  def _peek_1hassp_(self,):
   return ((self._peeki32_I((3 + self._peek_1nd_()))!=0))
  @staticmethod
  def _match_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nnz_alt_(self,):
    return self._peek_1nnz_()
  def _peek_1nnz_(self,):
   return numpy.int32(self._peeki32_I((2 + self._peek_1nd_())))
  @staticmethod
  def _match_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nelem_alt_(self,):
    return self._peek_1nelem_()
  def _peek_1nelem_(self,):
   return numpy.int32(self._peeki32_I((1 + self._peek_1nd_())))
  @staticmethod
  def _match_peek_1dim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_peek_1dim_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _peek_1dim_alt_I(self,_t__a_0):
    return self._peek_1dim_I(numpy.int32(__a_0))
  def _peek_1dim_I(self,_a_0):
   return numpy.int32(self._peeki32_I((_a_0 + 1)))
  @staticmethod
  def _match_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nd_alt_(self,):
    return self._peek_1nd_()
  def _peek_1nd_(self,):
   return numpy.int32(self._peeki32_())
  @staticmethod
  def _match_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_Z__(_a_3))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_Z__(_a_3))
  def _alloc_1expr_alt_IIIZ(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
    return self._alloc_1expr_IIIZ(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2),_a_3)
  def _alloc_1expr_IIIZ(self,_a_0,_a_1,_a_2,_a_3):
   self._alloc_1expr_IIIZI(_a_0,_a_1,_a_2,_a_3,0)
  @staticmethod
  def _match_alloc_1expr_IIIZI(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_I__(_a_2) and __arg_match_Z__(_a_3) and __arg_match_I__(_a_4))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZI(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_I__(_a_2) and __arg_alt_match_Z__(_a_3) and __arg_alt_match_I__(_a_4))
  def _alloc_1expr_alt_IIIZI(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
    return self._alloc_1expr_IIIZI(numpy.int32(__a_0),numpy.int32(__a_1),numpy.int32(__a_2),_a_3,numpy.int32(__a_4))
  def _alloc_1expr_IIIZI(self,_a_0,_a_1,_a_2,_a_3,_a_4):
   if ((_a_0 < 0) or ((_a_1 < 0) or ((_a_2 < 0) or (_a_4 < 0)))):
    raise mosek_fusion_ExpressionError._ctor_S("Attempted to allocate negative amount on work stack")
   self.cof_base = self._allocf64_I(_a_2)
   self.cconst_base = self._allocf64_I(_a_4)
   self.nidxs_base = self._alloci64_I(_a_2)
   self.sp_base = (self._alloci64_I(_a_1) if (_a_3 ) else (- 9999))
   self.code_base = self._alloci32_I(_a_4)
   self.codeptr_base = (self._alloci32_I((_a_2 + 1)) if ((_a_4 > 0) ) else (- 9999))
   self.ptr_base = self._alloci32_I((_a_1 + 1))
   self._pushi32_I(_a_4)
   self._pushi32_I((1 if (_a_3 ) else 0))
   self._pushi32_I(_a_2)
   self._pushi32_I(_a_1)
   self.shape_base = self._alloci32_I(_a_0)
   self._pushi32_I(_a_0)
   (self.ncodeatom) = _a_4
   (self.nd) = _a_0
   (self.nelem) = _a_1
   (self.nnz) = _a_2
   (self.hassp) = _a_3
  @staticmethod
  def _match_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _pop_1expr_alt_(self,):
    return self._pop_1expr_()
  def _pop_1expr_(self,):
   self.nd = self._popi32_()
   self.shape_base = self._popi32_I(self.nd)
   self.nelem = self._popi32_()
   self.nnz = self._popi32_()
   self.hassp = (self._popi32_()!=0)
   self.ncodeatom = self._popi32_()
   self.ptr_base = self._popi32_I((self.nelem + 1))
   self.codeptr_base = (self._popi32_I((self.nnz + 1)) if ((self.ncodeatom > 0) ) else (- 9999))
   self.code_base = self._popi32_I(self.ncodeatom)
   self.sp_base = (self._popi64_I(self.nelem) if (self.hassp ) else (- 9999))
   self.nidxs_base = self._popi64_I(self.nnz)
   self.cconst_base = self._popf64_I(self.ncodeatom)
   self.cof_base = self._popf64_I(self.nnz)
  @staticmethod
  def _match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_a_0))
  @staticmethod
  def _match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_a_0))
  def _move_1expr_alt_Lmosek_4fusion_4WorkStack_2(self,_t__a_0):
    return self._move_1expr_Lmosek_4fusion_4WorkStack_2(_a_0)
  def _move_1expr_Lmosek_4fusion_4WorkStack_2(self,_a_0):
   _a_1=self.pi32
   _a_2=self.pi64
   _a_3=self.pf64
   self._pop_1expr_()
   _a_4=_a_0._alloci32_I((_a_1 - self.pi32))
   _a_5=_a_0._alloci64_I((_a_2 - self.pi64))
   _a_6=_a_0._allocf64_I((_a_3 - self.pf64))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,(_a_0.i32),_a_4,(_a_1 - self.pi32))
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,(_a_0.i64),_a_5,(_a_2 - self.pi64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,(_a_0.f64),_a_6,(_a_3 - self.pf64))
  @staticmethod
  def _match_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1expr_alt_(self,):
    return self._peek_1expr_()
  def _peek_1expr_(self,):
   _a_0=self.pi32
   _a_1=self.pi64
   _a_2=self.pf64
   self._pop_1expr_()
   self.pi32 = _a_0
   self.pi64 = _a_1
   self.pf64 = _a_2
  @staticmethod
  def _match_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  def _ensure_1sparsity_alt_(self,):
    return self._ensure_1sparsity_()
  def _ensure_1sparsity_(self,):
   _a_0=self.i32[(self.pi32 - 1)]
   _a_1=(self.i32[((self.pi32 - _a_0) - 3)]!=0)
   _a_2=self.i32[((self.pi32 - _a_0) - 1)]
   if (not _a_1):
    self.i32[((self.pi32 - _a_0) - 3)] = 1
    _a_3=self._alloci64_I(_a_2)
    fragments._c_closure_616(self.i64,_a_2,_a_3) 
  @staticmethod
  def _match_clear_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clear_(*args):
    if len(args) != 0: return False
    return True
  def _clear_alt_(self,):
    return self._clear_()
  def _clear_(self,):
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
  @staticmethod
  def _match_allocf64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_allocf64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _allocf64_alt_I(self,_t__a_0):
    return self._allocf64_I(numpy.int32(__a_0))
  def _allocf64_I(self,_a_0):
   self._ensuref64_I(_a_0)
   _a_1=self.pf64
   self.pf64 += _a_0
   return numpy.int32(_a_1)
  @staticmethod
  def _match_alloci64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_alloci64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _alloci64_alt_I(self,_t__a_0):
    return self._alloci64_I(numpy.int32(__a_0))
  def _alloci64_I(self,_a_0):
   self._ensurei64_I(_a_0)
   _a_1=self.pi64
   self.pi64 += _a_0
   return numpy.int32(_a_1)
  @staticmethod
  def _match_alloci32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_alloci32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _alloci32_alt_I(self,_t__a_0):
    return self._alloci32_I(numpy.int32(__a_0))
  def _alloci32_I(self,_a_0):
   if (_a_0 > 0):
    self._ensurei32_I(_a_0)
    _a_1=self.pi32
    self.pi32 += _a_0
    return numpy.int32(_a_1)
   else:
    return numpy.int32(0)
  @staticmethod
  def _match_pushf64_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_pushf64_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  def _pushf64_alt_D(self,_t__a_0):
    return self._pushf64_D(numpy.float64(__a_0))
  def _pushf64_D(self,_a_0):
   self._ensuref64_I(1)
   self.f64[self.pf64] = _a_0
   self.pf64 += 1
  @staticmethod
  def _match_pushi64_J(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_J__(_a_0))
  @staticmethod
  def _match_alt_pushi64_J(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_J__(_a_0))
  def _pushi64_alt_J(self,_t__a_0):
    return self._pushi64_J(numpy.int64(__a_0))
  def _pushi64_J(self,_a_0):
   self._ensurei64_I(1)
   self.i64[self.pi64] = _a_0
   self.pi64 += 1
  @staticmethod
  def _match_pushi32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_pushi32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _pushi32_alt_I(self,_t__a_0):
    return self._pushi32_I(numpy.int32(__a_0))
  def _pushi32_I(self,_a_0):
   self._ensurei32_I(1)
   self.i32[self.pi32] = _a_0
   self.pi32 += 1
  @staticmethod
  def _match_ensuref64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_ensuref64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _ensuref64_alt_I(self,_t__a_0):
    return self._ensuref64_I(numpy.int32(__a_0))
  def _ensuref64_I(self,_a_0):
   if ((self.pf64 + _a_0) > int((self.f64).shape[0])):
    _a_1=((int((self.f64).shape[0]) * 2) if (((_a_0 < int((self.f64).shape[0])) and (int((self.f64).shape[0]) < 1073741823)) ) else (int((self.f64).shape[0]) + _a_0))
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,0,_a_2,0,self.pf64)
    self.f64 = _a_2
  @staticmethod
  def _match_ensurei64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_ensurei64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _ensurei64_alt_I(self,_t__a_0):
    return self._ensurei64_I(numpy.int32(__a_0))
  def _ensurei64_I(self,_a_0):
   if ((self.pi64 + _a_0) > int((self.i64).shape[0])):
    _a_1=(int((self.i64).shape[0]) + (int((self.i64).shape[0]) if (((_a_0 < int((self.i64).shape[0])) and (int((self.i64).shape[0]) < 1073741823)) ) else _a_0))
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,0,_a_2,0,self.pi64)
    self.i64 = _a_2
  @staticmethod
  def _match_ensurei32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_ensurei32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _ensurei32_alt_I(self,_t__a_0):
    return self._ensurei32_I(numpy.int32(__a_0))
  def _ensurei32_I(self,_a_0):
   if ((self.pi32 + _a_0) > int((self.i32).shape[0])):
    _a_1=((int((self.i32).shape[0]) * 2) if (((_a_0 < int((self.i32).shape[0])) and (int((self.i32).shape[0]) < 1073741823)) ) else (int((self.i32).shape[0]) + _a_0))
    _a_2=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,0,_a_2,0,self.pi32)
    self.i32 = _a_2
  @staticmethod
  def _match_popf64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_popf64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _popf64_alt_I(self,_t__a_0):
    return self._popf64_I(numpy.int32(__a_0))
  def _popf64_I(self,_a_0):
   self.pf64 -= _a_0
   if (self.pf64 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pf64)
  @staticmethod
  def _match_popi64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_popi64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _popi64_alt_I(self,_t__a_0):
    return self._popi64_I(numpy.int32(__a_0))
  def _popi64_I(self,_a_0):
   self.pi64 -= _a_0
   if (self.pi64 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pi64)
  @staticmethod
  def _match_popi32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_popi32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _popi32_alt_I(self,_t__a_0):
    return self._popi32_I(numpy.int32(__a_0))
  def _popi32_I(self,_a_0):
   self.pi32 -= _a_0
   if (self.pi32 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pi32)
  @staticmethod
  def _match_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3D__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3D__(_a_1) and __arg_alt_match_I__(_a_2))
  def _popf64_alt_I_3DI(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.float64))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self._popf64_I_3DI(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _popf64_I_3DI(self,_a_0,_a_1,_a_2):
   self.pf64 -= _a_0
   if (self.pf64 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,_a_1,_a_2,_a_0)
  @staticmethod
  def _match_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3J__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match_I__(_a_2))
  def _popi64_alt_I_3JI(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self._popi64_I_3JI(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _popi64_I_3JI(self,_a_0,_a_1,_a_2):
   self.pi64 -= _a_0
   if (self.pi64 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,_a_1,_a_2,_a_0)
  @staticmethod
  def _match_popi32_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_popi32_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _popi32_alt_I_3II(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self._popi32_I_3II(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _popi32_I_3II(self,_a_0,_a_1,_a_2):
   self.pi32 -= _a_0
   if (self.pi32 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,_a_1,_a_2,_a_0)
  @staticmethod
  def _match_popf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popf64_(*args):
    if len(args) != 0: return False
    return True
  def _popf64_alt_(self,):
    return self._popf64_()
  def _popf64_(self,):
   self.pf64 -= 1
   if (self.pf64 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.float64(self.f64[self.pf64])
  @staticmethod
  def _match_popi64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi64_(*args):
    if len(args) != 0: return False
    return True
  def _popi64_alt_(self,):
    return self._popi64_()
  def _popi64_(self,):
   if (self.pi64 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   self.pi64 -= 1
   return numpy.int64(self.i64[self.pi64])
  @staticmethod
  def _match_popi32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi32_(*args):
    if len(args) != 0: return False
    return True
  def _popi32_alt_(self,):
    return self._popi32_()
  def _popi32_(self,):
   self.pi32 -= 1
   if (self.pi32 < 0):
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.i32[self.pi32])
  @staticmethod
  def _match_peekf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peekf64_(*args):
    if len(args) != 0: return False
    return True
  def _peekf64_alt_(self,):
    return self._peekf64_()
  def _peekf64_(self,):
   return numpy.float64(self.f64[(self.pf64 - 1)])
  @staticmethod
  def _match_peeki64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki64_(*args):
    if len(args) != 0: return False
    return True
  def _peeki64_alt_(self,):
    return self._peeki64_()
  def _peeki64_(self,):
   return numpy.int64(self.i64[(self.pi64 - 1)])
  @staticmethod
  def _match_peeki32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki32_(*args):
    if len(args) != 0: return False
    return True
  def _peeki32_alt_(self,):
    return self._peeki32_()
  def _peeki32_(self,):
   return numpy.int32(self.i32[(self.pi32 - 1)])
  @staticmethod
  def _match_peekf64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_peekf64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _peekf64_alt_I(self,_t__a_0):
    return self._peekf64_I(numpy.int32(__a_0))
  def _peekf64_I(self,_a_0):
   return numpy.float64(self.f64[((self.pf64 - _a_0) - 1)])
  @staticmethod
  def _match_peeki64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_peeki64_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _peeki64_alt_I(self,_t__a_0):
    return self._peeki64_I(numpy.int32(__a_0))
  def _peeki64_I(self,_a_0):
   return numpy.int64(self.i64[((self.pi64 - _a_0) - 1)])
  @staticmethod
  def _match_peeki32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_peeki32_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _peeki32_alt_I(self,_t__a_0):
    return self._peeki32_I(numpy.int32(__a_0))
  def _peeki32_I(self,_a_0):
   return numpy.int32(self.i32[((self.pi32 - _a_0) - 1)])
 return WorkStack
mosek_fusion_WorkStack=__mk_mosek_fusion_WorkStack()
del __mk_mosek_fusion_WorkStack
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricMatrix():
 class SymmetricMatrix(object):
  __slots__ = ['_SymmetricMatrix__nnz','_SymmetricMatrix__scale','_SymmetricMatrix__vval','_SymmetricMatrix__vsubj','_SymmetricMatrix__vsubi','_SymmetricMatrix__uval','_SymmetricMatrix__usubj','_SymmetricMatrix__usubi','_SymmetricMatrix__d1','_SymmetricMatrix__d0']
  @staticmethod
  def rankOne(*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))
      mosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    n : int32
    sub : array(int32,ndim=1)
    v : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_rankOne__3D(*args):
      return mosek_fusion_SymmetricMatrix._rankOne__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne__3D(*args):
      return mosek_fusion_SymmetricMatrix._rankOne_alt__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_rankOne_I_3I_3D(*args):
      return mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne_I_3I_3D(*args):
      return mosek_fusion_SymmetricMatrix._rankOne_alt_I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list rankOne('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))\n\tmosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))')
  def sub(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)

    Description
    -----------

    

    Parameters
    ----------

    m : mosek.fusion.SymmetricMatrix
    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
      return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
      return self._sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)')
  def mul(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.mul(double)

    Description
    -----------

    

    Parameters
    ----------

    v : double
    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_mul_D(*args):
      return self._mul_D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_mul_D(*args):
      return self._mul_alt_D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.mul(double)')
  @staticmethod
  def antiDiag(*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    vals : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_antiDiag__3D(*args):
      return mosek_fusion_SymmetricMatrix._antiDiag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_antiDiag__3D(*args):
      return mosek_fusion_SymmetricMatrix._antiDiag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list antiDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))')
  @staticmethod
  def diag(*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    vals : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_diag__3D(*args):
      return mosek_fusion_SymmetricMatrix._diag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_diag__3D(*args):
      return mosek_fusion_SymmetricMatrix._diag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))')
  def getdim(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.getdim()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_getdim_(*args):
      return self._getdim_(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_getdim_(*args):
      return self._getdim_alt_(*args)
    else:
      raise ValueError('Invalid argument list getdim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.getdim()')
  def add(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)

    Description
    -----------

    

    Parameters
    ----------

    m : mosek.fusion.SymmetricMatrix
    '''
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
      return self._add_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
      return self._add_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)')
  def __repr__(self): return 'mosek.fusion.SymmetricMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    o = SymmetricMatrix.__new__(SymmetricMatrix)
    o._ctor_init_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match__3I__(usubi) and __arg_match__3I__(usubj) and __arg_match__3D__(uval) and __arg_match__3I__(vsubi) and __arg_match__3I__(vsubj) and __arg_match__3D__(vval) and __arg_match_D__(scale))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match__3I__(usubi) and __arg_alt_match__3I__(usubj) and __arg_alt_match__3D__(uval) and __arg_alt_match__3I__(vsubi) and __arg_alt_match__3I__(vsubj) and __arg_alt_match__3D__(vval) and __arg_alt_match_D__(scale))
  def _ctor_alt_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    self._ctor_init_II_3I_3I_3D_3I_3I_3DD(numpy.int32(dim0),numpy.int32(dim1),numpy.array(usubi,dtype=numpy.dtype(numpy.int32)),numpy.array(usubj,dtype=numpy.dtype(numpy.int32)),numpy.array(uval,dtype=numpy.dtype(numpy.float64)),numpy.array(vsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(vsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(vval,dtype=numpy.dtype(numpy.float64)),numpy.float64(scale))
  def _ctor_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
   (self.__d0) = dim0
   (self.__d1) = dim1
   (self.__usubi) = usubi
   (self.__usubj) = usubj
   (self.__uval) = uval
   (self.__vsubi) = vsubi
   (self.__vsubj) = vsubj
   (self.__vval) = vval
   (self.__scale) = scale
   self.__nnz = (- 1)
  @staticmethod
  def _match_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2))
  @staticmethod
  def _rankOne_alt_I_3I_3D(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _rankOne_I_3I_3D(_a_0,_a_1,_a_2):
   if (int((_a_1).shape[0])!=int((_a_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   for _a_3 in range(0,int((_a_1).shape[0])):
    if ((_a_1[_a_3] < 0) or (_a_1[_a_3] >= _a_0)):
     raise mosek_fusion_LengthError._ctor_S("Invalid index in argument 'sub'")
   _a_4=numpy.array([_a_1[_a_5] for _a_5 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.array([1 for _a_7 in range(0,int((_a_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.array([_a_2[_a_9] for _a_9 in range(0,int((_a_2).shape[0]))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_a_0,1,_a_4,_a_6,_a_8,_a_4,_a_6,_a_8,1.0))
  @staticmethod
  def _match_rankOne__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_rankOne__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _rankOne_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_SymmetricMatrix._rankOne__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _rankOne__3D(_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=numpy.array([_a_3 for _a_3 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array([1 for _a_5 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.array([_a_0[_a_7] for _a_7 in range(0,_a_1)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_a_1,1,_a_2,_a_4,_a_6,_a_2,_a_4,_a_6,1.0))
  @staticmethod
  def _match_antiDiag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_antiDiag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _antiDiag_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_SymmetricMatrix._antiDiag__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _antiDiag__3D(_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=numpy.array([_a_3 for _a_3 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_a_1,_a_1,_a_2,numpy.array([(_a_1 - _a_4) for _a_4 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32)),numpy.array([_a_0[_a_5] for _a_5 in range(0,_a_1)], dtype=numpy.dtype(numpy.float64)),_a_2,_a_2,numpy.array([1.0 for _a_6 in range(0,_a_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _diag_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_SymmetricMatrix._diag__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _diag__3D(_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=numpy.array([_a_3 for _a_3 in range(0,_a_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_a_1,_a_1,_a_2,_a_2,numpy.array([_a_0[_a_4] for _a_4 in range(0,_a_1)], dtype=numpy.dtype(numpy.float64)),_a_2,_a_2,numpy.array([1.0 for _a_5 in range(0,_a_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_a_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_a_0))
  def _add_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__a_0):
    return self._add_Lmosek_4fusion_4SymmetricMatrix_2(_a_0)
  def _add_Lmosek_4fusion_4SymmetricMatrix_2(self,_a_0):
   _a_1=self._getdim_()
   if (_a_0._getdim_()!=_a_1):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   _a_2=int((self.__usubi).shape[0])
   _a_3=int(((_a_0.__usubi)).shape[0])
   _a_4=(_a_2 + _a_3)
   _a_5=int((self.__vsubi).shape[0])
   _a_6=int(((_a_0.__vsubi)).shape[0])
   _a_7=(_a_5 + _a_6)
   _a_8=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.float64))
   _a_9=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int32))
   _a_10=numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int32))
   _a_11=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
   _a_12=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   _a_13=numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_a_13,0,_a_2)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_a_0.__usubi),0,_a_13,_a_2,_a_3)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubj,0,_a_12,0,_a_2)
   for _a_14 in range(0,_a_3):
    _a_12[(_a_14 + _a_2)] = ((_a_0.__usubj)[_a_14] + self.__d1)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__uval,0,_a_11,0,_a_2)
   else:
    fragments._c_closure_617(_a_11,self.__scale,_a_2,self.__uval) 
   if (((_a_0.__scale) > 1.0) or ((_a_0.__scale) < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_a_0.__uval),0,_a_11,_a_2,_a_3)
   else:
    for _a_15 in range(0,_a_3):
     _a_11[(_a_15 + _a_2)] = ((_a_0.__scale) * (_a_0.__uval)[_a_15])
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_a_13,0,_a_2)
   for _a_16 in range(0,_a_6):
    _a_10[(_a_16 + _a_5)] = ((_a_0.__vsubi)[_a_16] + (_a_0.__d1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__vsubj,0,_a_9,0,_a_5)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_a_0.__vsubj),_a_5,_a_9,_a_5,_a_6)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__vval,0,_a_8,0,_a_5)
   else:
    fragments._c_closure_618(_a_8,self.__scale,_a_5,self.__vval) 
   if (((_a_0.__scale) > 1.0) or ((_a_0.__scale) < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_a_0.__vval),0,_a_8,_a_5,_a_6)
   else:
    for _a_17 in range(0,_a_6):
     _a_8[(_a_17 + _a_5)] = ((_a_0.__scale) * (_a_0.__vval)[_a_17])
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,(self.__d1 + (_a_0.__d1)),_a_13,_a_12,_a_11,_a_10,_a_9,_a_8,1.0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_a_0))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_a_0))
  def _sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__a_0):
    return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(_a_0)
  def _sub_Lmosek_4fusion_4SymmetricMatrix_2(self,_a_0):
   return (self._add_Lmosek_4fusion_4SymmetricMatrix_2(_a_0._mul_D((- 1.0))))
  @staticmethod
  def _match_mul_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_D__(_a_0))
  @staticmethod
  def _match_alt_mul_D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_D__(_a_0))
  def _mul_alt_D(self,_t__a_0):
    return self._mul_D(numpy.float64(__a_0))
  def _mul_D(self,_a_0):
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,self.__d1,self.__usubi,self.__usubj,self.__uval,self.__vsubi,self.__vsubj,self.__vval,(self.__scale * _a_0)))
  @staticmethod
  def _match_getdim_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getdim_(*args):
    if len(args) != 0: return False
    return True
  def _getdim_alt_(self,):
    return self._getdim_()
  def _getdim_(self,):
   return numpy.int32(self.__d0)
 return SymmetricMatrix
mosek_fusion_SymmetricMatrix=__mk_mosek_fusion_SymmetricMatrix()
del __mk_mosek_fusion_SymmetricMatrix
#BEFORE CLASS
def __mk_mosek_fusion_NDSparseArray():
 class NDSparseArray(object):
  __slots__ = ['_cof','_inst','_dims','_size']
  @staticmethod
  def make(*args):
    '''
    Syntax
    ------

      mosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)
      mosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))
      mosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))

    Description
    -----------

    Create a sparse n-dimensional matrix (tensor).

    Parameters
    ----------

    cof : array(double,ndim=1)
        Values of nonzero elements. Array of coefficients corresponding to subscripts.
    dims : array(int32,ndim=1)
        Dimensions. 
    inst : array(int64,ndim=1)
        Positions of nonzeros using linear indexes into the array.
    m : mosek.fusion.Matrix
        An initializing matrix.
    sub : array(int32,ndim=2)
        Positions of nonzeros. Array where each row is an :math:`n`-dimensional index.
    '''
    if False: pass
    elif mosek_fusion_NDSparseArray._match_make_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_NDSparseArray._make_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3J_3D(*args):
      return mosek_fusion_NDSparseArray._make__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3J_3D(*args):
      return mosek_fusion_NDSparseArray._make_alt__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3_5I_3D(*args):
      return mosek_fusion_NDSparseArray._make__3I_3_5I_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3_5I_3D(*args):
      return mosek_fusion_NDSparseArray._make_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSparseArray'
  @staticmethod
  def _ctor__3I_3_5I_3D(dims_,sub,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3_5I_3D(dims_,sub,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3_5I__(sub) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3_5I__(sub) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3_5I_3D(self,dims_,sub,cof_):
    self._ctor_init__3I_3_5I_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(sub,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3_5I_3D(self,dims_,sub,cof_):
   _a_0=numpy.zeros((int((sub).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self._size = 1
   self._size = fragments._c_closure_619(dims_,self._size)
   self._size = numpy.int64(self._size) # postprocess
   _a_1=int((dims_).shape[0])
   if (int((sub).shape[0])!=int((cof_).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   if (int((sub).shape[1])!=_a_1):
    raise mosek_fusion_IndexError._ctor_S("An index key in sub has wrong length")
   _a_2=False
   _a_2 = fragments._c_closure_620(dims_,_a_2,sub)
   if _a_2:
    raise mosek_fusion_IndexError._ctor_S("An index in sub is out of bounds")
   fragments._c_closure_621(dims_,_a_0,sub) 
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _a_3=True
   _a_3 = fragments._c_closure_622(_a_0,_a_3)
   if _a_3:
    _a_4=1
    _a_4 = fragments._c_closure_623(_a_0,_a_4)
    _a_4 = numpy.int32(_a_4) # postprocess
    if (_a_4==int((_a_0).shape[0])):
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(_a_0)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = _a_0[0]
     self._cof = numpy.zeros((_a_4,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _a_5=0
     _a_5 = fragments._c_closure_624(self._cof,cof_,self._inst,_a_0,_a_5)
     _a_5 = numpy.int32(_a_5) # postprocess
   else:
    _a_6=mosek.fusion.Utils.Tools._range_J(int((_a_0).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_6,_a_0,None,0,int((_a_0).shape[0]))
    _a_7=1
    _a_7 = fragments._c_closure_625(_a_0,_a_7,_a_6)
    _a_7 = numpy.int32(_a_7) # postprocess
    self._inst = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = _a_0[_a_6[0]]
    self._cof = numpy.zeros((_a_7,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_a_6[0]]
    _a_8=0
    _a_8 = fragments._c_closure_626(self._cof,cof_,self._inst,_a_0,_a_8,_a_6)
    _a_8 = numpy.int32(_a_8) # postprocess
  @staticmethod
  def _ctor__3I_3J_3D(dims_,inst_,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3J_3D(dims_,inst_,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3J__(inst_) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(inst_) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3J_3D(self,dims_,inst_,cof_):
    self._ctor_init__3I_3J_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,dims_,inst_,cof_):
   self._size = 1
   self._size = fragments._c_closure_627(dims_,self._size)
   self._size = numpy.int64(self._size) # postprocess
   _a_0=int((inst_).shape[0])
   if (_a_0!=int((cof_).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   _a_1=False
   _a_1 = fragments._c_closure_628(_a_1,inst_,_a_0,self._size)
   if _a_1:
    raise mosek_fusion_IndexError._ctor_S("An index in inst is out of bounds")
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _a_2=True
   _a_2 = fragments._c_closure_629(inst_,_a_2)
   if _a_2:
    _a_3=1
    _a_3 = fragments._c_closure_630(inst_,_a_3)
    _a_3 = numpy.int32(_a_3) # postprocess
    if (_a_3==int((inst_).shape[0])):
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = inst_[0]
     self._cof = numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _a_4=0
     _a_4 = fragments._c_closure_631(self._cof,cof_,self._inst,inst_,_a_4)
     _a_4 = numpy.int32(_a_4) # postprocess
   else:
    _a_5=mosek.fusion.Utils.Tools._range_J(int((inst_).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_a_5,inst_,None,0,int((inst_).shape[0]))
    _a_6=1
    _a_6 = fragments._c_closure_632(inst_,_a_6,_a_5)
    _a_6 = numpy.int32(_a_6) # postprocess
    self._inst = numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = inst_[_a_5[0]]
    self._cof = numpy.zeros((_a_6,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_a_5[0]]
    _a_7=0
    _a_7 = fragments._c_closure_633(self._cof,cof_,self._inst,inst_,_a_7,_a_5)
    _a_7 = numpy.int32(_a_7) # postprocess
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m):
   _a_0=m._numNonzeros_()
   _a_1=m._numColumns_()
   _a_2=m._numRows_()
   _a_3=numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.float64))
   _a_4=numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
   _a_5=numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
   m._getDataAsTriplets__3I_3I_3D(_a_5,_a_4,_a_3)
   self._size = (numpy.int64(m._numRows_()) * numpy.int64(m._numColumns_()))
   self._dims = numpy.array([_a_2,_a_1], dtype=numpy.dtype(numpy.int32))
   self._inst = numpy.array([((numpy.int64(_a_5[_a_6]) * _a_1) + numpy.int64(_a_4[_a_6])) for _a_6 in range(0,_a_0)], dtype=numpy.dtype(numpy.int64))
   self._cof = _a_3
  @staticmethod
  def _match_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _make_Lmosek_4fusion_4Matrix_2(_a_0):
   return (mosek_fusion_NDSparseArray._ctor_Lmosek_4fusion_4Matrix_2(_a_0))
  @staticmethod
  def _match_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3J__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3J__(_a_1) and __arg_alt_match__3D__(_a_2))
  @staticmethod
  def _make_alt__3I_3J_3D(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int64))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_NDSparseArray._make__3I_3J_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _make__3I_3J_3D(_a_0,_a_1,_a_2):
   return (mosek_fusion_NDSparseArray._ctor__3I_3J_3D(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3_5I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3_5I__(_a_1) and __arg_alt_match__3D__(_a_2))
  @staticmethod
  def _make_alt__3I_3_5I_3D(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,ndmin=_monty.checkShape(_t__a_1,2),dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_NDSparseArray._make__3I_3_5I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _make__3I_3_5I_3D(_a_0,_a_1,_a_2):
   return (mosek_fusion_NDSparseArray._ctor__3I_3_5I_3D(_a_0,_a_1,_a_2))
 return NDSparseArray
mosek_fusion_NDSparseArray=__mk_mosek_fusion_NDSparseArray()
del __mk_mosek_fusion_NDSparseArray
#BEFORE CLASS
def __mk_mosek_fusion_Matrix():
 class Matrix(object):
  __slots__ = ['_dimj','_dimi']
  @staticmethod
  def eye(*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.eye(int32)

    Description
    -----------

    Create the identity matrix.

    Parameters
    ----------

    n : int32
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_eye_I(*args):
      return mosek_fusion_Matrix._eye_I(*args)
    elif mosek_fusion_Matrix._match_alt_eye_I(*args):
      return mosek_fusion_Matrix._eye_alt_I(*args)
    else:
      raise ValueError('Invalid argument list eye('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.eye(int32)')
  def numNonzeros(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.numNonzeros()

    Description
    -----------

    Returns the number of non-zeros in the matrix.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_numNonzeros_(*args):
      return self._numNonzeros_(*args)
    elif mosek_fusion_Matrix._match_alt_numNonzeros_(*args):
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numNonzeros()')
  @staticmethod
  def ones(*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.ones(int32,int32)

    Description
    -----------

    Create a matrix filled with all ones.

    Parameters
    ----------

    m : int32
    n : int32
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_ones_II(*args):
      return mosek_fusion_Matrix._ones_II(*args)
    elif mosek_fusion_Matrix._match_alt_ones_II(*args):
      return mosek_fusion_Matrix._ones_alt_II(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.ones(int32,int32)')
  @staticmethod
  def sparse(*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.sparse(array(double,ndim=2))
      mosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))
      mosek.fusion.Matrix.sparse(mosek.fusion.Matrix)
      mosek.fusion.Matrix.sparse(int32,int32)
      mosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))
      mosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)
      mosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)
      mosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))

    Description
    -----------

    Construct a sparse matrix from triplet-format data and dimensions. 

    Parameters
    ----------

    blocks : array(array(mosek.fusion.Matrix,ndim=1),ndim=1)
        The matrix data in block format. All elements in a row must have the same height, and all elements in a column must have the same width. Entries that are |null| will be interpreted as a block of zeros whose height and width are deduced from the other elements in the same row and column. Any row that contains only |null| entries will have height 0, and any column that contains only |null| entries will have width 0. 
    data : array(double,ndim=2)
        Dense data array. 
    mx : mosek.fusion.Matrix
        A :msk:func:`matrix` object. 
    ncol : int32
        Number of columns. 
    nrow : int32
        Number of rows. 
    subi : array(int32,ndim=1)
        Row subscripts of non-zero elements.
    subj : array(int32,ndim=1)
        Column subscripts of non-zero elements.
    val : array(double,ndim=1)
        Coefficients of non-zero elements.
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_sparse__3_5D(*args):
      return mosek_fusion_Matrix._sparse__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_5D(*args):
      return mosek_fusion_Matrix._sparse_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._sparse_alt__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._sparse_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_II(*args):
      return mosek_fusion_Matrix._sparse_II(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II(*args):
      return mosek_fusion_Matrix._sparse_alt_II(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3I_3D(*args):
      return mosek_fusion_Matrix._sparse__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3I_3D(*args):
      return mosek_fusion_Matrix._sparse_alt__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3ID(*args):
      return mosek_fusion_Matrix._sparse__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3ID(*args):
      return mosek_fusion_Matrix._sparse_alt__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3ID(*args):
      return mosek_fusion_Matrix._sparse_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3ID(*args):
      return mosek_fusion_Matrix._sparse_alt_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3I_3D(*args):
      return mosek_fusion_Matrix._sparse_II_3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3I_3D(*args):
      return mosek_fusion_Matrix._sparse_alt_II_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.sparse(array(double,ndim=2))\n\tmosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))\n\tmosek.fusion.Matrix.sparse(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.sparse(int32,int32)\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def dense(*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.dense(array(double,ndim=2))
      mosek.fusion.Matrix.dense(mosek.fusion.Matrix)
      mosek.fusion.Matrix.dense(int32,int32,double)
      mosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))

    Description
    -----------

    Create a dense matrix from the given data. 

    Parameters
    ----------

    data : array(double,ndim=1)
        A one- or two-dimensional array of matrix coefficients. 
    dimi : int32
        Number of rows. 
    dimj : int32
        Number of columns. 
    other : mosek.fusion.Matrix
        Create a dense matrix from another matrix. 
    value : double
        Use this value for all elements. 
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_dense__3_5D(*args):
      return mosek_fusion_Matrix._dense__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_dense__3_5D(*args):
      return mosek_fusion_Matrix._dense_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_dense_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._dense_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_dense_IID(*args):
      return mosek_fusion_Matrix._dense_IID(*args)
    elif mosek_fusion_Matrix._match_alt_dense_IID(*args):
      return mosek_fusion_Matrix._dense_alt_IID(*args)
    elif mosek_fusion_Matrix._match_dense_II_3D(*args):
      return mosek_fusion_Matrix._dense_II_3D(*args)
    elif mosek_fusion_Matrix._match_alt_dense_II_3D(*args):
      return mosek_fusion_Matrix._dense_alt_II_3D(*args)
    else:
      raise ValueError('Invalid argument list dense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.dense(array(double,ndim=2))\n\tmosek.fusion.Matrix.dense(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.dense(int32,int32,double)\n\tmosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))')
  def numRows(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.numRows()

    Description
    -----------

    Returns the number of rows in the matrix.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_numRows_(*args):
      return self._numRows_(*args)
    elif mosek_fusion_Matrix._match_alt_numRows_(*args):
      return self._numRows_alt_(*args)
    else:
      raise ValueError('Invalid argument list numRows('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numRows()')
  def numColumns(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.numColumns()

    Description
    -----------

    Returns the number of columns in the matrix.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_numColumns_(*args):
      return self._numColumns_(*args)
    elif mosek_fusion_Matrix._match_alt_numColumns_(*args):
      return self._numColumns_alt_(*args)
    else:
      raise ValueError('Invalid argument list numColumns('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numColumns()')
  def isSparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.isSparse()

    Description
    -----------

    Returns true if the matrix is sparse. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_isSparse_(*args):
      return self._isSparse_(*args)
    elif mosek_fusion_Matrix._match_alt_isSparse_(*args):
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.isSparse()')
  @staticmethod
  def antidiag(*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.antidiag(array(double,ndim=1))
      mosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)
      mosek.fusion.Matrix.antidiag(int32,double)
      mosek.fusion.Matrix.antidiag(int32,double,int32)

    Description
    -----------

    Create a sparse square matrix with a given vector as anti-diagonal. 

    Parameters
    ----------

    d : array(double,ndim=1)
        The anti-diagonal vector. 
    k : int32
        The anti-diagonal index. :math:`k=0` is the default and means the main anti-diagonal. :math:`k&gt;0` means above, and :math:`k&lt;0` means below the main anti-diagonal. 
    n : int32
        The dimension of the matrix. 
    val : double
        Use this value for all anti-diagonal elements. 
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_antidiag__3D(*args):
      return mosek_fusion_Matrix._antidiag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3D(*args):
      return mosek_fusion_Matrix._antidiag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_antidiag__3DI(*args):
      return mosek_fusion_Matrix._antidiag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3DI(*args):
      return mosek_fusion_Matrix._antidiag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_antidiag_ID(*args):
      return mosek_fusion_Matrix._antidiag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_ID(*args):
      return mosek_fusion_Matrix._antidiag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_antidiag_IDI(*args):
      return mosek_fusion_Matrix._antidiag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_IDI(*args):
      return mosek_fusion_Matrix._antidiag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1))\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.antidiag(int32,double)\n\tmosek.fusion.Matrix.antidiag(int32,double,int32)')
  def getDataAsTriplets(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))

    Description
    -----------

    Return the matrix data in sparse triplet format. 

    Parameters
    ----------

    subi : array(int32,ndim=1)
    subj : array(int32,ndim=1)
    val : array(double,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsTriplets__3I_3I_3D(*args):
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsTriplets__3I_3I_3D(*args):
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.toString()

    Description
    -----------

    Get a string representation of the matrix. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_Matrix._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.toString()')
  def getDataAsArray(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.getDataAsArray()

    Description
    -----------

    Return a dense array of values. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsArray_(*args):
      return self._getDataAsArray_(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsArray_(*args):
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsArray()')
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.get(int32,int32)

    Description
    -----------

    Get a single entry.

    Parameters
    ----------

    i : int32
    j : int32
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_get_II(*args):
      return self._get_II(*args)
    elif mosek_fusion_Matrix._match_alt_get_II(*args):
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.get(int32,int32)')
  @staticmethod
  def diag(*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.diag(array(double,ndim=1))
      mosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))
      mosek.fusion.Matrix.diag(array(double,ndim=1),int32)
      mosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)
      mosek.fusion.Matrix.diag(int32,double)
      mosek.fusion.Matrix.diag(int32,double,int32)

    Description
    -----------

    Create a sparse matrix by repeating a matrix 

    Parameters
    ----------

    d : array(double,ndim=1)
        The diagonal vector. 
    k : int32
        The diagonal index. :math:`k=0` is the default and means the main diagonal. :math:`k&gt;0` means above, and :math:`k&lt;0` means below the main diagonal. 
    md : array(mosek.fusion.Matrix,ndim=1)
        A list of square matrices that are used to create a block-diagonal square matrix.
    mv : mosek.fusion.Matrix
        A matrix to be repeated in all blocks of a block-diagonal square matrix.
    n : int32
        The dimension of the matrix. 
    num : int32
    val : double
        Use this value for all diagonal elements. 
    '''
    if False: pass
    elif mosek_fusion_Matrix._match_diag__3D(*args):
      return mosek_fusion_Matrix._diag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3D(*args):
      return mosek_fusion_Matrix._diag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_diag__3Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._diag_alt__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag__3DI(*args):
      return mosek_fusion_Matrix._diag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3DI(*args):
      return mosek_fusion_Matrix._diag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_diag_ILmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
      return mosek_fusion_Matrix._diag_alt_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag_ID(*args):
      return mosek_fusion_Matrix._diag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ID(*args):
      return mosek_fusion_Matrix._diag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_diag_IDI(*args):
      return mosek_fusion_Matrix._diag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_diag_IDI(*args):
      return mosek_fusion_Matrix._diag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.diag(array(double,ndim=1))\n\tmosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))\n\tmosek.fusion.Matrix.diag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.diag(int32,double)\n\tmosek.fusion.Matrix.diag(int32,double,int32)')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.Matrix.transpose()

    Description
    -----------

    Transpose the matrix. 

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_Matrix._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_Matrix._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.transpose()')
  def __repr__(self): return 'mosek.fusion.Matrix'
  @staticmethod
  def _ctor_II(di,dj):
    o = Matrix.__new__(Matrix)
    o._ctor_init_II(di,dj)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_match_I__(di) and __arg_match_I__(dj))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_alt_match_I__(di) and __arg_alt_match_I__(dj))
  def _ctor_alt_init_II(self,di,dj):
    self._ctor_init_II(numpy.int32(di),numpy.int32(dj))
  def _ctor_init_II(self,di,dj):
   if ((di < 0) or (dj < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimensions")
   self._dimi = di
   self._dimj = dj
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("")
  def _switchDims_alt_(self,):
    return self._switchDims_()
  def _switchDims_(self,):
   _a_0=self._dimi
   self._dimi = self._dimj
   self._dimj = _a_0
  @staticmethod
  def _match_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_1))
  @staticmethod
  def _diag_alt_ILmosek_4fusion_4Matrix_2(_t__a_0,_t__a_1):
    return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(numpy.int32(__a_0),_a_1)
  @staticmethod
  def _diag_ILmosek_4fusion_4Matrix_2(_a_0,_a_1):
   return (mosek.fusion.Matrix._diag__3Lmosek_4fusion_4Matrix_2(numpy.array([_a_1 for _a_2 in range(0,_a_0)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _diag_alt__3Lmosek_4fusion_4Matrix_2(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(object))
   _1_res = mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _diag__3Lmosek_4fusion_4Matrix_2(_a_0):
   _a_1=_a_0
   _a_2=0
   _a_3=0
   _a_4=0
   for _a_5 in range(0,int((_a_0).shape[0])):
    _a_4 = (_a_4 + (_a_0[_a_5]._dimi))
    _a_3 = (_a_3 + (_a_0[_a_5]._dimj))
    _a_2 = (_a_2 + _a_0[_a_5]._numNonzeros_())
   _a_6=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
   _a_8=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.float64))
   _a_9=0
   _a_10=0
   _a_11=0
   for _a_12 in range(0,int((_a_0).shape[0])):
    _a_13=_a_0[_a_12]._numNonzeros_()
    _a_14=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.float64))
    _a_15=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
    _a_16=numpy.zeros((_a_13,), dtype=numpy.dtype(numpy.int32))
    _a_0[_a_12]._getDataAsTriplets__3I_3I_3D(_a_16,_a_15,_a_14)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_a_14,0,_a_8,_a_11,_a_13)
    fragments._c_closure_634(_a_13,_a_11,_a_16,_a_10,_a_9,_a_6,_a_7) 
    _a_11 = (_a_11 + _a_13)
    _a_10 = (_a_10 + (_a_0[_a_12]._dimi))
    _a_9 = (_a_9 + (_a_0[_a_12]._dimj))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_4,_a_3,_a_6,_a_7,_a_8))
  @staticmethod
  def _match_antidiag_IDI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_antidiag_IDI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _antidiag_alt_IDI(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Matrix._antidiag_IDI(numpy.int32(__a_0),numpy.float64(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _antidiag_IDI(_a_0,_a_1,_a_2):
   if ((_a_2 < _a_0) and (_a_2 >= 0)):
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_a_1,(_a_0 - _a_2)),_a_2))
   elif ((_a_2 > (- _a_0)) and (_a_2 < 0)):
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_a_1,(_a_0 + _a_2)),_a_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_antidiag_ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_antidiag_ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _antidiag_alt_ID(_t__a_0,_t__a_1):
    return mosek_fusion_Matrix._antidiag_ID(numpy.int32(__a_0),numpy.float64(__a_1))
  @staticmethod
  def _antidiag_ID(_a_0,_a_1):
   return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_a_1,_a_0),0))
  @staticmethod
  def _match_diag_IDI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_diag_IDI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _diag_alt_IDI(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Matrix._diag_IDI(numpy.int32(__a_0),numpy.float64(__a_1),numpy.int32(__a_2))
  @staticmethod
  def _diag_IDI(_a_0,_a_1,_a_2):
   if ((_a_2 < _a_0) and (_a_2 >= 0)):
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_a_1,(_a_0 - _a_2)),_a_2))
   elif ((_a_2 > (- _a_0)) and (_a_2 < 0)):
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_a_1,(_a_0 + _a_2)),_a_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_diag_ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_D__(_a_1))
  @staticmethod
  def _match_alt_diag_ID(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_D__(_a_1))
  @staticmethod
  def _diag_alt_ID(_t__a_0,_t__a_1):
    return mosek_fusion_Matrix._diag_ID(numpy.int32(__a_0),numpy.float64(__a_1))
  @staticmethod
  def _diag_ID(_a_0,_a_1):
   return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_a_1,_a_0),0))
  @staticmethod
  def _match_antidiag__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_antidiag__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _antidiag_alt__3DI(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Matrix._antidiag__3DI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _antidiag__3DI(_a_0,_a_1):
   _a_2=(_a_1 if ((_a_1 > 0) ) else (- _a_1))
   _a_3=(int((_a_0).shape[0]) + _a_2)
   _a_4=int((_a_0).shape[0])
   if (_a_1 >= 0):
    _a_5=mosek.fusion.Utils.Tools._range_II(_a_1,(_a_4 + _a_1))
    _a_6=numpy.array([((_a_4 + _a_1) - _a_7) for _a_7 in range(1,(_a_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_3,_a_3,_a_5,_a_6,_a_0))
   else:
    _a_8=mosek.fusion.Utils.Tools._range_II(0,_a_4)
    _a_9=numpy.array([(_a_4 - _a_10) for _a_10 in range(1,(_a_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_3,_a_3,_a_8,_a_9,_a_0))
  @staticmethod
  def _match_antidiag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_antidiag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _antidiag_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._antidiag__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _antidiag__3D(_a_0):
   return (mosek.fusion.Matrix._antidiag__3DI(_a_0,0))
  @staticmethod
  def _match_diag__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match__3D__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_diag__3DI(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match__3D__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _diag_alt__3DI(_t__a_0,_t__a_1):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _a_1=numpy.int32(_t__a_1)
   _1_res = mosek_fusion_Matrix._diag__3DI(_a_0,_a_1)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _diag__3DI(_a_0,_a_1):
   _a_2=(_a_1 if ((_a_1 > 0) ) else (- _a_1))
   _a_3=(int((_a_0).shape[0]) + _a_2)
   _a_4=int((_a_0).shape[0])
   if (_a_1 >= 0):
    _a_5=mosek.fusion.Utils.Tools._range_II(0,_a_4)
    _a_6=mosek.fusion.Utils.Tools._range_II(_a_2,(_a_4 + _a_2))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_3,_a_3,_a_5,_a_6,_a_0))
   else:
    _a_7=mosek.fusion.Utils.Tools._range_II(_a_2,(_a_4 + _a_2))
    _a_8=mosek.fusion.Utils.Tools._range_II(0,_a_4)
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_3,_a_3,_a_7,_a_8,_a_0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3D__(_a_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3D__(_a_0))
  @staticmethod
  def _diag_alt__3D(_t__a_0):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._diag__3D(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _diag__3D(_a_0):
   return (mosek.fusion.Matrix._diag__3DI(_a_0,0))
  @staticmethod
  def _match_ones_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_ones_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _ones_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Matrix._ones_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _ones_II(_a_0,_a_1):
   return (mosek.fusion.Matrix._dense_IID(_a_0,_a_1,1.0))
  @staticmethod
  def _match_eye_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_eye_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  @staticmethod
  def _eye_alt_I(_t__a_0):
    return mosek_fusion_Matrix._eye_I(numpy.int32(__a_0))
  @staticmethod
  def _eye_I(_a_0):
   return (mosek.fusion.Matrix._diag__3D(numpy.array([1.0 for _a_1 in range(0,_a_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _dense_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _dense_Lmosek_4fusion_4Matrix_2(_a_0):
   return (mosek_fusion_DenseMatrix._ctor_Lmosek_4fusion_4Matrix_2(_a_0))
  @staticmethod
  def _match_dense_IID(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_dense_IID(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _dense_alt_IID(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Matrix._dense_IID(numpy.int32(__a_0),numpy.int32(__a_1),numpy.float64(__a_2))
  @staticmethod
  def _dense_IID(_a_0,_a_1,_a_2):
   return (mosek_fusion_DenseMatrix._ctor_IID(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_dense_II_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_dense_II_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match__3D__(_a_2))
  @staticmethod
  def _dense_alt_II_3D(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._dense_II_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _dense_II_3D(_a_0,_a_1,_a_2):
   return (mosek_fusion_DenseMatrix._ctor_II_3D(_a_0,_a_1,_a_2))
  @staticmethod
  def _match_dense__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_dense__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  @staticmethod
  def _dense_alt__3_5D(_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._dense__3_5D(_a_0)
   return _1_res
  @staticmethod
  def _dense__3_5D(_a_0):
   return (mosek_fusion_DenseMatrix._ctor__3_5D(_a_0))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4Matrix_2(_t__a_0):
    return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(_a_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4Matrix_2(_a_0):
   _a_1=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.zeros((_a_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _a_0._getDataAsTriplets__3I_3I_3D(_a_1,_a_2,_a_3)
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_0._numRows_(),_a_0._numColumns_(),_a_1,_a_2,_a_3))
  @staticmethod
  def _match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(_a_0))
  @staticmethod
  def _sparse_alt__3_3Lmosek_4fusion_4Matrix_2(_t__a_0):
   _a_0=_monty.makeJaggedArray(_t__a_0,(1,1),numpy.dtype(object))
   _1_res = mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(_a_0)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse__3_3Lmosek_4fusion_4Matrix_2(_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=int((_a_0[0]).shape[0])
   _a_3=numpy.zeros((_a_1,), dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
   _a_5=0
   _a_6=0
   _a_7=0
   while (_a_7 < _a_1):
    _a_8=0
    while (_a_8 < _a_2):
     _a_9=_a_0[_a_7][_a_8]
     if (_a_9 is not None):
      if (_a_4[_a_8]==0):
       _a_4[_a_8] = (_a_9._dimj)
      elif (_a_4[_a_8]!=(_a_9._dimj)):
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      if (_a_3[_a_7]==0):
       _a_3[_a_7] = (_a_9._dimi)
      elif (_a_3[_a_7]!=(_a_9._dimi)):
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      _a_5 = (_a_5 + _a_9._numNonzeros_())
     _a_6 += 1
     _a_8 += 1
    _a_7 += 1
   _a_10=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.float64))
   _a_11=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_12=numpy.zeros((_a_5,), dtype=numpy.dtype(numpy.int32))
   _a_13=0
   _a_14=0
   _a_15=0
   while (_a_15 < _a_1):
    _a_16=numpy.zeros((_a_2,), dtype=numpy.dtype(numpy.int32))
    _a_17=0
    while (_a_17 < _a_3[_a_15]):
     _a_18=0
     _a_19=0
     while (_a_19 < _a_2):
      _a_20=_a_0[_a_15][_a_19]
      if (_a_20 is not None):
       _a_22=_a_20
       if   isinstance(_a_22,mosek_fusion_DenseMatrix):
        m=_a_22
        _a_22=_a_16[_a_19]
        _a_23=0
        while (_a_23 < (m._dimj)):
         _a_10[_a_13] = (m._data)[_a_22]
         _a_11[_a_13] = (_a_14 + _a_17)
         _a_12[_a_13] = (_a_18 + _a_23)
         _a_22 += 1
         _a_13 += 1
         _a_23 += 1
        _a_16[_a_19] = _a_22
       elif isinstance(_a_22,mosek_fusion_SparseMatrix):
        _a_24=_a_22
        _a_25 = _a_16[_a_19]
        while ((_a_25 < (_a_24._nnz)) and ((_a_24._subi)[_a_25]==_a_17)):
         _a_10[_a_13] = (_a_24._val)[_a_25]
         _a_12[_a_13] = ((_a_24._subj)[_a_25] + _a_18)
         _a_11[_a_13] = (_a_14 + _a_17)
         _a_13 += 1
         _a_25 += 1
        _a_16[_a_19] = _a_25
       else:
        m=_a_22
        raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
      _a_18 = (_a_18 + _a_4[_a_19])
      _a_19 += 1
     _a_17 += 1
    _a_14 = (_a_14 + _a_3[_a_15])
    _a_15 += 1
   _a_26=0
   _a_27=0
   _a_26 = fragments._c_closure_635(_a_26,_a_3,_a_1)
   _a_26 = numpy.int32(_a_26) # postprocess
   _a_27 = fragments._c_closure_636(_a_27,_a_4,_a_2)
   _a_27 = numpy.int32(_a_27) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_26,_a_27,_a_11,_a_12,_a_10))
  @staticmethod
  def _match_sparse__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match__3_5D__(_a_0))
  @staticmethod
  def _match_alt_sparse__3_5D(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match__3_5D__(_a_0))
  @staticmethod
  def _sparse_alt__3_5D(_t__a_0):
   _a_0=numpy.array(_t__a_0,ndmin=_monty.checkShape(_t__a_0,2),dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._sparse__3_5D(_a_0)
   return _1_res
  @staticmethod
  def _sparse__3_5D(_a_0):
   _a_1=int((_a_0).shape[0])
   _a_2=int((_a_0).shape[1])
   _a_3=numpy.int64((_a_1 * _a_2))
   _a_4=0
   _a_5=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_6=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.int32))
   _a_7=numpy.zeros((_a_3,), dtype=numpy.dtype(numpy.float64))
   _a_4 = fragments._c_closure_637(_a_0,_a_1,_a_2,_a_4,_a_5,_a_6,_a_7)
   _a_4 = numpy.int32(_a_4) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_a_1,_a_2,_a_5,_a_6,_a_7))
  @staticmethod
  def _match_sparse_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_sparse_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  @staticmethod
  def _sparse_alt_II(_t__a_0,_t__a_1):
    return mosek_fusion_Matrix._sparse_II(numpy.int32(__a_0),numpy.int32(__a_1))
  @staticmethod
  def _sparse_II(_a_0,_a_1):
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_a_0,_a_1,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),0))
  @staticmethod
  def _match_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match__3I__(_a_3) and __arg_match_D__(_a_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match__3I__(_a_3) and __arg_alt_match_D__(_a_4))
  @staticmethod
  def _sparse_alt_II_3I_3ID(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.float64(_t__a_4)
   _1_res = mosek_fusion_Matrix._sparse_II_3I_3ID(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse_II_3I_3ID(_a_0,_a_1,_a_2,_a_3,_a_4):
   _a_5=0
   if (_a_2 is not None):
    _a_5 = int((_a_2).shape[0])
   elif (_a_3 is not None):
    _a_5 = int((_a_3).shape[0])
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(_a_0,_a_1,_a_2,_a_3,mosek.fusion.Utils.Tools._makevector_DI(_a_4,_a_5)))
  @staticmethod
  def _match_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _sparse_alt__3I_3ID(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.float64(_t__a_2)
   _1_res = mosek_fusion_Matrix._sparse__3I_3ID(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse__3I_3ID(_a_0,_a_1,_a_2):
   _a_3=0
   _a_4=0
   _a_5=int((_a_0).shape[0])
   if (_a_5 > int((_a_1).shape[0])):
    _a_5 = int((_a_1).shape[0])
   _a_4,_a_3 = fragments._c_closure_638(_a_4,_a_3,_a_5,_a_0,_a_1)
   _a_4 = numpy.int32(_a_4) # postprocess
   _a_3 = numpy.int32(_a_3) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3ID((_a_4 + 1),(_a_3 + 1),_a_0,_a_1,_a_2))
  @staticmethod
  def _match_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2))
  @staticmethod
  def _sparse_alt__3I_3I_3D(_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._sparse__3I_3I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse__3I_3I_3D(_a_0,_a_1,_a_2):
   _a_3=0
   _a_4=0
   _a_5=int((_a_0).shape[0])
   if (_a_5 > int((_a_1).shape[0])):
    _a_5 = int((_a_1).shape[0])
   if (_a_5 > int((_a_2).shape[0])):
    _a_5 = int((_a_2).shape[0])
   _a_4,_a_3 = fragments._c_closure_639(_a_4,_a_3,_a_5,_a_0,_a_1)
   _a_4 = numpy.int32(_a_4) # postprocess
   _a_3 = numpy.int32(_a_3) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D((_a_4 + 1),(_a_3 + 1),_a_0,_a_1,_a_2))
  @staticmethod
  def _match_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match__3I__(_a_3) and __arg_match__3D__(_a_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _a_0,_a_1,_a_2,_a_3,_a_4, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match__3I__(_a_3) and __arg_alt_match__3D__(_a_4))
  @staticmethod
  def _sparse_alt_II_3I_3I_3D(_t__a_0,_t__a_1,_t__a_2,_t__a_3,_t__a_4):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.array(_t__a_3,dtype=numpy.dtype(numpy.int32))
   _a_4=numpy.array(_t__a_4,dtype=numpy.dtype(numpy.float64))
   _1_res = mosek_fusion_Matrix._sparse_II_3I_3I_3D(_a_0,_a_1,_a_2,_a_3,_a_4)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_3[:] = _a_3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_4[:] = _a_4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  @staticmethod
  def _sparse_II_3I_3I_3D(_a_0,_a_1,_a_2,_a_3,_a_4):
   _a_5=(_a_4 if ((_a_4 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   _a_6=(_a_3 if ((_a_3 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _a_7=(_a_2 if ((_a_2 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _a_8=int((_a_7).shape[0])
   if ((int((_a_6).shape[0])!=_a_8) or (int((_a_5).shape[0])!=_a_8)):
    raise mosek_fusion_SparseFormatError._ctor_S("Arrays defining sparse data have different lengths")
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_a_0,_a_1,_a_7,_a_6,_a_5,_a_8))
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _get_alt_II(self,_t__a_0,_t__a_1):
    return self._get_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _get_II(self,_a_0,_a_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   pass
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = self._getDataAsTriplets__3I_3I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getDataAsTriplets__3I_3I_3D(self,_a_0,_a_1,_a_2):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   pass
  @staticmethod
  def _match_numColumns_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numColumns_(*args):
    if len(args) != 0: return False
    return True
  def _numColumns_alt_(self,):
    return self._numColumns_()
  def _numColumns_(self,):
   return numpy.int32(self._dimj)
  @staticmethod
  def _match_numRows_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numRows_(*args):
    if len(args) != 0: return False
    return True
  def _numRows_alt_(self,):
    return self._numRows_()
  def _numRows_(self,):
   return numpy.int32(self._dimi)
 return Matrix
mosek_fusion_Matrix=__mk_mosek_fusion_Matrix()
del __mk_mosek_fusion_Matrix
#BEFORE CLASS
def __mk_mosek_fusion_DenseMatrix():
 class DenseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_data']
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.get(int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    j : int32
    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_get_II(*args):
      return self._get_II(*args)
    elif mosek_fusion_DenseMatrix._match_alt_get_II(*args):
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.get(int32,int32)')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.toString()')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.transpose()

    Description
    -----------

    Tranpose the matrix.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.transpose()')
  def getDataAsArray(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.getDataAsArray()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsArray_(*args):
      return self._getDataAsArray_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsArray_(*args):
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsArray()')
  def numNonzeros(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.numNonzeros()

    Description
    -----------

    Number of non-zero elements in the matrix.

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_numNonzeros_(*args):
      return self._numNonzeros_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_numNonzeros_(*args):
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.numNonzeros()')
  def isSparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.isSparse()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_isSparse_(*args):
      return self._isSparse_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_isSparse_(*args):
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.isSparse()')
  def getDataAsTriplets(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    cof : array(double,ndim=1)
    subi : array(int32,ndim=1)
    subj : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsTriplets__3I_3I_3D(*args):
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args):
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.DenseMatrix'
  @staticmethod
  def _ctor_II_3D(dimi_,dimj_,cof):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_II_3D(dimi_,dimj_,cof)
    return o
  @staticmethod
  def __match_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3D__(cof))
  @staticmethod
  def __match_alt_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3D__(cof))
  def _ctor_alt_init_II_3D(self,dimi_,dimj_,cof):
    self._ctor_init_II_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(cof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3D(self,dimi_,dimj_,cof):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._nnz = numpy.int64((dimi_ * dimj_))
   self._data = numpy.zeros(((dimi_ * dimj_),), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(cof,0,self._data,0,(dimi_ * dimj_))
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m_))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m_):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m_):
   mosek_fusion_Matrix._ctor_init_II(self,(m_._dimi),(m_._dimj))
   _a_1=m_
   if   isinstance(_a_1,mosek_fusion_DenseMatrix):
    m=_a_1
    self._data = mosek.fusion.Utils.Tools._arraycopy__3D((m._data))
   elif isinstance(_a_1,mosek_fusion_SparseMatrix):
    _a_1=_a_1
    self._data = mosek.fusion.Utils.Tools._zeros_I(((_a_1._dimi) * (_a_1._dimj)))
    for _a_2 in range(0,(_a_1._nnz)):
     self._data[(((_a_1._subi)[_a_2] * self._dimj) + (_a_1._subj)[_a_2])] = (_a_1._val)[_a_2]
   else:
    m=_a_1
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor__3_5D(d):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init__3_5D(d)
    return o
  @staticmethod
  def __match_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_match__3_5D__(d))
  @staticmethod
  def __match_alt_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_alt_match__3_5D__(d))
  def _ctor_alt_init__3_5D(self,d):
    self._ctor_init__3_5D(numpy.array(d,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3_5D(self,d):
   mosek_fusion_Matrix._ctor_init_II(self,int((d).shape[0]),int((d).shape[1]))
   self._data = numpy.array([d[_a_0,_a_1] for _a_0 in range(0,self._dimi) for _a_1 in range(0,self._dimj)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor_IID(dimi_,dimj_,value_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_IID(dimi_,dimj_,value_)
    return o
  @staticmethod
  def __match_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match_D__(value_))
  @staticmethod
  def __match_alt_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match_D__(value_))
  def _ctor_alt_init_IID(self,dimi_,dimj_,value_):
    self._ctor_init_IID(numpy.int32(dimi_),numpy.int32(dimj_),numpy.float64(value_))
  def _ctor_init_IID(self,dimi_,dimj_,value_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._data = numpy.array([value_ for _a_0 in range(0,dimi_) for _a_1 in range(0,dimj_)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((dimi_ * dimj_))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("DenseMatrix(")
   _a_0._a_I(self._dimi)
   _a_0._a_S(",")
   _a_0._a_I(self._dimj)
   _a_0._a_S(": ")
   _a_1=0
   _a_2=0
   while (_a_2 < self._dimi):
    if (_a_2 > 0):
     _a_0._a_S(",")
    _a_0._a_S("[ ")
    _a_0._a_D(self._data[_a_1])
    _a_1 += 1
    _a_3=1
    while (_a_3 < self._dimj):
     _a_0._a_S(",")
     _a_0._a_D(self._data[_a_1])
     _a_1 += 1
     _a_3 += 1
    _a_0._a_S(" ]")
    _a_2 += 1
   _a_0._a_S(")")
   return (_a_0._toString_())
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _a_0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   _a_1=0
   _a_2=self._dimi
   _a_1 = fragments._c_closure_640(self._data,self._dimi,self._dimj,_a_0,_a_1,_a_2)
   _a_1 = numpy.int32(_a_1) # postprocess
   return (mosek_fusion_DenseMatrix._ctor_II_3D(self._dimj,self._dimi,_a_0))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (False)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3D(self._data))
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = self._getDataAsTriplets__3I_3I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getDataAsTriplets__3I_3I_3D(self,_a_0,_a_1,_a_2):
   if ((int((_a_0).shape[0]) < self._nnz) or ((int((_a_1).shape[0]) < self._nnz) or (int((_a_2).shape[0]) < self._nnz))):
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self._data,0,_a_2,0,int((self._data).shape[0]))
   _a_3=0
   _a_3 = fragments._c_closure_641(self._dimi,self._dimj,_a_3,_a_0,_a_1)
   _a_3 = numpy.int32(_a_3) # postprocess
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _get_alt_II(self,_t__a_0,_t__a_1):
    return self._get_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _get_II(self,_a_0,_a_1):
   return numpy.float64(self._data[((_a_0 * self._dimj) + _a_1)])
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(numpy.int64((self._dimi * self._dimj)))
 return DenseMatrix
mosek_fusion_DenseMatrix=__mk_mosek_fusion_DenseMatrix()
del __mk_mosek_fusion_DenseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_SparseMatrix():
 class SparseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_val','_subj','_subi']
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.get(int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    j : int32
    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_get_II(*args):
      return self._get_II(*args)
    elif mosek_fusion_SparseMatrix._match_alt_get_II(*args):
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.get(int32,int32)')
  def transpose(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.transpose()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_transpose_(*args):
      return self._transpose_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_transpose_(*args):
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.transpose()')
  def getDataAsTriplets(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))

    Description
    -----------

    

    Parameters
    ----------

    cof_ : array(double,ndim=1)
    subi_ : array(int32,ndim=1)
    subj_ : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsTriplets__3I_3I_3D(*args):
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args):
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def getDataAsArray(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.getDataAsArray()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsArray_(*args):
      return self._getDataAsArray_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsArray_(*args):
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsArray()')
  def toString(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.toString()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_toString_(*args):
      return self._toString_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_toString_(*args):
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.toString()')
  def isSparse(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.isSparse()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_isSparse_(*args):
      return self._isSparse_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_isSparse_(*args):
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.isSparse()')
  def numNonzeros(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.SparseMatrix.numNonzeros()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_SparseMatrix._match_numNonzeros_(*args):
      return self._numNonzeros_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_numNonzeros_(*args):
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.numNonzeros()')
  def __repr__(self): return 'mosek.fusion.SparseMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_) and __arg_match_J__(nelm))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_) and __arg_alt_match_J__(nelm))
  def _ctor_alt_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    self._ctor_init_II_3I_3I_3DJ(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)),numpy.int64(nelm))
  def _ctor_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   if (nelm > 0):
    if ((int((subi_).shape[0]) < nelm) or ((int((subj_).shape[0]) < nelm) or (int((val_).shape[0]) < nelm))):
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching arrays in sparse data.")
    _a_0=False
    _a_0 = fragments._c_closure_642(self._dimi,self._dimj,nelm,_a_0,subi_,subj_)
    if _a_0:
     raise mosek_fusion_SparseFormatError._ctor_S("Subscript out of bounds.")
    _a_1=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _a_2=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _a_3=numpy.ndarray((1,), dtype=numpy.dtype(object))
    mosek.fusion.CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(subi_,subj_,val_,_a_1,_a_2,_a_3,nelm,self._dimi,self._dimj)
    self._subi = _a_1[0]
    self._subj = _a_2[0]
    self._val = _a_3[0]
    self._nnz = int((self._val).shape[0])
   else:
    self._subi = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = 0
  @staticmethod
  def _ctor_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_))
  def _ctor_alt_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
    self._ctor_init_II_3I_3I_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   _a_0=0
   _a_0 = fragments._c_closure_643(_a_0,val_)
   _a_0 = numpy.int32(_a_0) # postprocess
   if ((_a_0 > 0) and (_a_0 < int((subi_).shape[0]))):
    self._subi = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = _a_0
    _a_1=0
    _a_1 = fragments._c_closure_644(_a_1,self._subi,subi_,self._subj,subj_,self._val,val_)
    _a_1 = numpy.int32(_a_1) # postprocess
   else:
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if (subi_ is None):
     self._nnz = 0
    else:
     self._nnz = int((self._subi).shape[0])
  def _formPtrb_alt_(self,):
    return self._formPtrb_()
  def _formPtrb_(self,):
   _a_0=numpy.zeros(((self._dimi + 1),), dtype=numpy.dtype(numpy.int64))
   _a_1=0
   _a_1 = fragments._c_closure_645(self._dimi,self._nnz,_a_1,_a_0,self._subi)
   _a_1 = numpy.int64(_a_1) # postprocess
   _a_0[self._dimi] = _a_1
   return (_a_0)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _a_0=mosek.fusion.Utils.StringBuffer()
   _a_0._a_S("SparseMatrix(")._a_I(self._dimi)._a_S(",")._a_I(self._dimj)._a_S(", [")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)):
    _a_0._a_S("(")._a_I(self._subi[0])._a_S(",")._a_I(self._subj[0])._a_S(",")._a_D(self._val[0])._a_S(")")
    for _a_1 in range(1,int((self._subi).shape[0])):
     _a_0._a_S(",(")._a_I(self._subi[_a_1])._a_S(",")._a_I(self._subj[_a_1])._a_S(",")._a_D(self._val[_a_1])._a_S(")")
   _a_0._a_S(" ])")
   return (_a_0._toString_())
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(self._nnz)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(self._dimj,self._dimi,self._subj,self._subi,self._val))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (True)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   _a_0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_646(self._dimj,_a_0,self._subi,self._subj,self._val) 
   return (_a_0)
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match__3I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match__3D__(_a_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match__3I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match__3D__(_a_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.array(_t__a_0,dtype=numpy.dtype(numpy.int32))
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.float64))
   _1_res = self._getDataAsTriplets__3I_3I_3D(_a_0,_a_1,_a_2)
   try:
     _t__a_0[:] = _a_0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _getDataAsTriplets__3I_3I_3D(self,_a_0,_a_1,_a_2):
   if ((int((_a_0).shape[0]) < self._nnz) or ((int((_a_1).shape[0]) < self._nnz) or (int((_a_2).shape[0]) < self._nnz))):
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)):
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subi,0,_a_0,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subj,0,_a_1,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self._val,0,_a_2,0,self._nnz)
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _get_alt_II(self,_t__a_0,_t__a_1):
    return self._get_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _get_II(self,_a_0,_a_1):
   if ((_a_0 < 0) or ((_a_0 >= self._dimi) or ((_a_1 < 0) or (_a_1 >= self._dimj)))):
    raise mosek_fusion_IndexError._ctor_S("Index out if bounds")
   _a_2=int((self._subi).shape[0])
   _a_3=0
   while ((_a_2 - _a_3) > 1):
    _a_4=((_a_3 + _a_2) // 2)
    if ((self._subi[_a_4] < _a_0) or ((self._subi[_a_4]==_a_0) and (self._subj[_a_4] < _a_1))):
     _a_3 = _a_4
    elif ((self._subi[_a_4] > _a_0) or ((self._subi[_a_4]==_a_0) and (self._subj[_a_4] > _a_1))):
     _a_2 = _a_4
    else:
     return numpy.float64(self._val[_a_4])
   if ((self._subi[_a_3]==_a_0) and (self._subj[_a_3]==_a_1)):
    return numpy.float64(self._val[_a_3])
   else:
    return numpy.float64(0.0)
 return SparseMatrix
mosek_fusion_SparseMatrix=__mk_mosek_fusion_SparseMatrix()
del __mk_mosek_fusion_SparseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_LinkedBlocks():
 class LinkedBlocks(object):
  __slots__ = ['_LinkedBlocks__bfirst','_LinkedBlocks__bsize','_LinkedBlocks__blocks','_LinkedBlocks__ints']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args):
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
      self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedBlocks.ctor()\n\tmosek.fusion.LinkedBlocks.ctor(int32)\n\tmosek.fusion.LinkedBlocks.ctor(mosek.fusion.LinkedBlocks)')
  def block_capacity(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.block_capacity()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_block_1capacity_(*args):
      return self._block_1capacity_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_block_1capacity_(*args):
      return self._block_1capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list block_capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.block_capacity()')
  def free(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.free(int32)

    Description
    -----------

    

    Parameters
    ----------

    bkey : int32
    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_free_I(*args):
      return self._free_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_free_I(*args):
      return self._free_alt_I(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.free(int32)')
  def numallocated(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.numallocated()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_numallocated_(*args):
      return self._numallocated_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_numallocated_(*args):
      return self._numallocated_alt_(*args)
    else:
      raise ValueError('Invalid argument list numallocated('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.numallocated()')
  def alloc(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.alloc(int32)

    Description
    -----------

    

    Parameters
    ----------

    size : int32
    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_alloc_I(*args):
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_alloc_I(*args):
      return self._alloc_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.alloc(int32)')
  def blocksize(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.blocksize(int32)

    Description
    -----------

    

    Parameters
    ----------

    bkey : int32
    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_blocksize_I(*args):
      return self._blocksize_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_blocksize_I(*args):
      return self._blocksize_alt_I(*args)
    else:
      raise ValueError('Invalid argument list blocksize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.blocksize(int32)')
  def validate(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.validate()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_validate_(*args):
      return self._validate_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_validate_(*args):
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.validate()')
  def maxidx(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.maxidx(int32)

    Description
    -----------

    

    Parameters
    ----------

    bkey : int32
    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_maxidx_I(*args):
      return self._maxidx_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_maxidx_I(*args):
      return self._maxidx_alt_I(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.maxidx(int32)')
  def capacity(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.capacity()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_capacity_(*args):
      return self._capacity_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_capacity_(*args):
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.capacity()')
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.get(int32,array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    bkey : int32
    offset : int32
    target : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_get_I_3II(*args):
      return self._get_I_3II(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_get_I_3II(*args):
      return self._get_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.get(int32,array(int32,ndim=1),int32)')
  def numblocks(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedBlocks.numblocks()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_numblocks_(*args):
      return self._numblocks_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_numblocks_(*args):
      return self._numblocks_alt_(*args)
    else:
      raise ValueError('Invalid argument list numblocks('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.numblocks()')
  def __repr__(self): return 'mosek.fusion.LinkedBlocks'
  @staticmethod
  def _ctor_():
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedBlocks._ctor_init_I(self,0)
  @staticmethod
  def _ctor_I(n):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_I(n)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_alt_match_I__(n))
  def _ctor_alt_init_I(self,n):
    self._ctor_init_I(numpy.int32(n))
  def _ctor_init_I(self,n):
   _a_0=128
   self.__ints = mosek_fusion_LinkedInts._ctor_I(n)
   self.__blocks = mosek_fusion_LinkedInts._ctor_I(_a_0)
   self.__bsize = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
   self.__bfirst = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedBlocks_2(other):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
   self.__ints = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__ints))
   self.__blocks = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__blocks))
   self.__bsize = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bsize))
   self.__bfirst = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bfirst))
  @staticmethod
  def _match_free_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_free_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _free_alt_I(self,_t__a_0):
    return self._free_I(numpy.int32(__a_0))
  def _free_I(self,_a_0):
   _a_1=self.__bfirst[_a_0]
   self.__ints._free_II(_a_1,self.__bsize[_a_0])
   self.__bsize[_a_0] = (- 1)
   self.__bfirst[_a_0] = (- 1)
   self.__blocks._free_II(_a_0,1)
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _alloc_alt_I(self,_t__a_0):
    return self._alloc_I(numpy.int32(__a_0))
  def _alloc_I(self,_a_0):
   _a_1=(self.__ints._alloc_I(_a_0) if ((_a_0 > 0) ) else (- 1))
   _a_2=self.__blocks._alloc_()
   if (self.__blocks._capacity_() > int((self.__bsize).shape[0])):
    _a_3=numpy.zeros((self.__blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    _a_4=numpy.zeros((self.__blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bsize,0,_a_3,0,int((self.__bsize).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bfirst,0,_a_4,0,int((self.__bfirst).shape[0]))
    self.__bsize = _a_3
    self.__bfirst = _a_4
   self.__bfirst[_a_2] = _a_1
   self.__bsize[_a_2] = _a_0
   return numpy.int32(_a_2)
  @staticmethod
  def _match_maxidx_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_maxidx_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _maxidx_alt_I(self,_t__a_0):
    return self._maxidx_I(numpy.int32(__a_0))
  def _maxidx_I(self,_a_0):
   return numpy.int32(self.__ints._maxidx_II(self.__bfirst[_a_0],self.__bsize[_a_0]))
  @staticmethod
  def _match_numallocated_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numallocated_(*args):
    if len(args) != 0: return False
    return True
  def _numallocated_alt_(self,):
    return self._numallocated_()
  def _numallocated_(self,):
   return numpy.int32(self.__ints._numallocated_())
  @staticmethod
  def _match_get_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_get_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _get_alt_I_3II(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self._get_I_3II(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _get_I_3II(self,_a_0,_a_1,_a_2):
   self.__ints._get_II_3II(self.__bfirst[_a_0],self.__bsize[_a_0],_a_1,_a_2)
  @staticmethod
  def _match_numblocks_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numblocks_(*args):
    if len(args) != 0: return False
    return True
  def _numblocks_alt_(self,):
    return self._numblocks_()
  def _numblocks_(self,):
   return numpy.int32(int((self.__bsize).shape[0]))
  @staticmethod
  def _match_blocksize_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_blocksize_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _blocksize_alt_I(self,_t__a_0):
    return self._blocksize_I(numpy.int32(__a_0))
  def _blocksize_I(self,_a_0):
   return numpy.int32(self.__bsize[_a_0])
  @staticmethod
  def _match_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  def _block_1capacity_alt_(self,):
    return self._block_1capacity_()
  def _block_1capacity_(self,):
   return numpy.int32(self.__blocks._capacity_())
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(self.__ints._capacity_())
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   return ((self.__ints._validate_() and self.__blocks._validate_()))
 return LinkedBlocks
mosek_fusion_LinkedBlocks=__mk_mosek_fusion_LinkedBlocks()
del __mk_mosek_fusion_LinkedBlocks
#BEFORE CLASS
def __mk_mosek_fusion_LinkedInts():
 class LinkedInts(object):
  __slots__ = ['_LinkedInts__nfree','_LinkedInts__last_free','_LinkedInts__first_free','_LinkedInts__first_used','_LinkedInts__prev','_LinkedInts__next']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args):
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args):
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
      self._ctor_init_Lmosek_4fusion_4LinkedInts_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
      self._ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedInts.ctor()\n\tmosek.fusion.LinkedInts.ctor(int32)\n\tmosek.fusion.LinkedInts.ctor(mosek.fusion.LinkedInts)')
  def alloc(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.alloc()
      mosek.fusion.LinkedInts.alloc(int32)
      mosek.fusion.LinkedInts.alloc(int32,array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    n : int32
    num : int32
    offset : int32
    target : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_alloc_(*args):
      return self._alloc_(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_(*args):
      return self._alloc_alt_(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I(*args):
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I(*args):
      return self._alloc_alt_I(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I_3II(*args):
      return self._alloc_I_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I_3II(*args):
      return self._alloc_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.alloc()\n\tmosek.fusion.LinkedInts.alloc(int32)\n\tmosek.fusion.LinkedInts.alloc(int32,array(int32,ndim=1),int32)')
  def get(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.get(int32,int32,array(int32,ndim=1),int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    num : int32
    offset : int32
    target : array(int32,ndim=1)
    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_get_II_3II(*args):
      return self._get_II_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_get_II_3II(*args):
      return self._get_alt_II_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.get(int32,int32,array(int32,ndim=1),int32)')
  def free(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.free(int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    num : int32
    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_free_II(*args):
      return self._free_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_free_II(*args):
      return self._free_alt_II(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.free(int32,int32)')
  def capacity(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.capacity()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_capacity_(*args):
      return self._capacity_(*args)
    elif mosek_fusion_LinkedInts._match_alt_capacity_(*args):
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.capacity()')
  def numallocated(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.numallocated()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_numallocated_(*args):
      return self._numallocated_(*args)
    elif mosek_fusion_LinkedInts._match_alt_numallocated_(*args):
      return self._numallocated_alt_(*args)
    else:
      raise ValueError('Invalid argument list numallocated('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.numallocated()')
  def maxidx(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.maxidx(int32,int32)

    Description
    -----------

    

    Parameters
    ----------

    i : int32
    num : int32
    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_maxidx_II(*args):
      return self._maxidx_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_maxidx_II(*args):
      return self._maxidx_alt_II(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.maxidx(int32,int32)')
  def validate(self,*args):
    '''
    Syntax
    ------

      mosek.fusion.LinkedInts.validate()

    Description
    -----------

    

    Parameters
    ----------

    '''
    if False: pass
    elif mosek_fusion_LinkedInts._match_validate_(*args):
      return self._validate_(*args)
    elif mosek_fusion_LinkedInts._match_alt_validate_(*args):
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.validate()')
  def __repr__(self): return 'mosek.fusion.LinkedInts'
  @staticmethod
  def _ctor_I(cap_):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_I(cap_)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_match_I__(cap_))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_alt_match_I__(cap_))
  def _ctor_alt_init_I(self,cap_):
    self._ctor_init_I(numpy.int32(cap_))
  def _ctor_init_I(self,cap_):
   _a_0=(cap_ if ((cap_ > 0) ) else 128)
   self.__next = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
   self.__prev = numpy.zeros((_a_0,), dtype=numpy.dtype(numpy.int32))
   self.__first_used = (- 1)
   self.__first_free = 0
   self.__last_free = (_a_0 - 1)
   fragments._c_closure_647(_a_0,self.__next,self.__prev) 
   self.__prev[0] = (- 1)
   self.__next[(_a_0 - 1)] = (- 1)
   self.__nfree = _a_0
  @staticmethod
  def _ctor_():
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedInts._ctor_init_I(self,128)
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedInts_2(other):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedInts_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedInts_2(self,other):
   self.__next = mosek.fusion.Utils.Tools._arraycopy__3I((other.__next))
   self.__prev = mosek.fusion.Utils.Tools._arraycopy__3I((other.__prev))
   self.__first_used = (other.__first_used)
   self.__first_free = (other.__first_free)
   self.__last_free = (other.__last_free)
   self.__nfree = (other.__nfree)
  @staticmethod
  def _match_free_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_free_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _free_alt_II(self,_t__a_0,_t__a_1):
    return self._free_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _free_II(self,_a_0,_a_1):
   self.__first_free,self.__first_used,self.__last_free,self.__nfree = fragments._c_closure_648(self.__first_free,self.__first_used,_a_0,self.__last_free,self.__next,self.__nfree,_a_1,self.__prev)
   self.__first_free = numpy.int32(self.__first_free) # postprocess
   self.__first_used = numpy.int32(self.__first_used) # postprocess
   self.__last_free = numpy.int32(self.__last_free) # postprocess
   self.__nfree = numpy.int32(self.__nfree) # postprocess
  @staticmethod
  def _match_alloc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_alloc_(*args):
    if len(args) != 0: return False
    return True
  def _alloc_alt_(self,):
    return self._alloc_()
  def _alloc_(self,):
   return numpy.int32(self.__allocblock_I(1))
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_match_I__(_a_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _a_0, = args
    return (__arg_alt_match_I__(_a_0))
  def _alloc_alt_I(self,_t__a_0):
    return self._alloc_I(numpy.int32(__a_0))
  def _alloc_I(self,_a_0):
   return numpy.int32(self.__allocblock_I(_a_0))
  @staticmethod
  def _match_alloc_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_I__(_a_0) and __arg_match__3I__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_alloc_I_3II(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match__3I__(_a_1) and __arg_alt_match_I__(_a_2))
  def _alloc_alt_I_3II(self,_t__a_0,_t__a_1,_t__a_2):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.array(_t__a_1,dtype=numpy.dtype(numpy.int32))
   _a_2=numpy.int32(_t__a_2)
   _1_res = self._alloc_I_3II(_a_0,_a_1,_a_2)
   try:
     _t__a_1[:] = _a_1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _alloc_I_3II(self,_a_0,_a_1,_a_2):
   _a_3=self.__allocblock_I(_a_0)
   _a_3 = fragments._c_closure_649(_a_3,self.__next,_a_0,_a_2,_a_1)
   _a_3 = numpy.int32(_a_3) # postprocess
  @staticmethod
  def _match_get_II_3II(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1) and __arg_match__3I__(_a_2) and __arg_match_I__(_a_3))
  @staticmethod
  def _match_alt_get_II_3II(*args):
    if len(args) != 4: return False
    _a_0,_a_1,_a_2,_a_3, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1) and __arg_alt_match__3I__(_a_2) and __arg_alt_match_I__(_a_3))
  def _get_alt_II_3II(self,_t__a_0,_t__a_1,_t__a_2,_t__a_3):
   _a_0=numpy.int32(_t__a_0)
   _a_1=numpy.int32(_t__a_1)
   _a_2=numpy.array(_t__a_2,dtype=numpy.dtype(numpy.int32))
   _a_3=numpy.int32(_t__a_3)
   _1_res = self._get_II_3II(_a_0,_a_1,_a_2,_a_3)
   try:
     _t__a_2[:] = _a_2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1_res
  def _get_II_3II(self,_a_0,_a_1,_a_2,_a_3):
   fragments._c_closure_650(_a_0,self.__next,_a_1,_a_3,_a_2) 
  @staticmethod
  def _match_numallocated_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numallocated_(*args):
    if len(args) != 0: return False
    return True
  def _numallocated_alt_(self,):
    return self._numallocated_()
  def _numallocated_(self,):
   return numpy.int32((int((self.__next).shape[0]) - self.__nfree))
  @staticmethod
  def _match_maxidx_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_match_I__(_a_0) and __arg_match_I__(_a_1))
  @staticmethod
  def _match_alt_maxidx_II(*args):
    if len(args) != 2: return False
    _a_0,_a_1, = args
    return (__arg_alt_match_I__(_a_0) and __arg_alt_match_I__(_a_1))
  def _maxidx_alt_II(self,_t__a_0,_t__a_1):
    return self._maxidx_II(numpy.int32(__a_0),numpy.int32(__a_1))
  def _maxidx_II(self,_a_0,_a_1):
   _a_2=_a_0
   _a_3=_a_0
   _a_3,_a_2 = fragments._c_closure_651(_a_3,_a_2,self.__next,_a_1)
   _a_3 = numpy.int32(_a_3) # postprocess
   _a_2 = numpy.int32(_a_2) # postprocess
   return numpy.int32(_a_2)
  def __allocblock_alt_I(self,_t__a_0):
    return self.__allocblock_I(numpy.int32(__a_0))
  def __allocblock_I(self,_a_0):
   _a_1=int((self.__next).shape[0])
   if (self.__nfree < _a_0):
    _a_2=(_a_0 - self.__nfree)
    if (_a_2 < _a_1):
     _a_2 = _a_1
    self.__recap_I((_a_2 + _a_1))
   _a_3=self.__first_free
   _a_4=_a_3
   _a_4 = fragments._c_closure_652(_a_4,self.__next,_a_0)
   _a_4 = numpy.int32(_a_4) # postprocess
   self.__first_free = self.__next[_a_4]
   if (self.__first_free < 0):
    self.__last_free = (- 1)
   else:
    self.__prev[self.__first_free] = (- 1)
   self.__next[_a_4] = self.__first_used
   if (self.__first_used >= 0):
    self.__prev[self.__first_used] = _a_4
   self.__first_used = _a_3
   self.__nfree -= _a_0
   return numpy.int32(_a_3)
  def __recap_alt_I(self,_t__a_0):
    return self.__recap_I(numpy.int32(__a_0))
  def __recap_I(self,_a_0):
   _a_1=int((self.__next).shape[0])
   if (_a_0 > _a_1):
    self.__next = mosek.fusion.CommonTools._resize__3II(self.__next,_a_0)
    self.__prev = mosek.fusion.CommonTools._resize__3II(self.__prev,_a_0)
    fragments._c_closure_653(_a_1,_a_0,self.__next,self.__prev) 
    self.__next[(_a_0 - 1)] = (- 1)
    self.__prev[_a_1] = self.__last_free
    if (self.__last_free < 0):
     self.__first_free = _a_1
    else:
     self.__next[self.__last_free] = _a_1
    self.__last_free = (_a_0 - 1)
    self.__nfree += (_a_0 - _a_1)
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(int((self.__next).shape[0]))
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   _a_0=numpy.zeros((int((self.__next).shape[0]),), dtype=numpy.dtype(bool))
   _a_1=self.__first_used
   while (_a_1 >= 0):
    _a_0[_a_1] = True
    _a_1 = self.__next[_a_1]
    if ((_a_1 >= 0) and _a_0[_a_1]):
     raise mosek_fusion_UnexpectedError._ctor_S("used list/next is inconsistent")
   _a_1 = self.__first_free
   _a_2=0
   while (_a_1 >= 0):
    _a_2 += 1
    _a_0[_a_1] = True
    _a_1 = self.__next[_a_1]
    if ((_a_1 >= 0) and _a_0[_a_1]):
     raise mosek_fusion_UnexpectedError._ctor_S("free list/next is inconsistent")
   if (_a_2!=self.__nfree):
    raise mosek_fusion_UnexpectedError._ctor_S("free next list did not contain nfree elements")
   for _a_3 in range(0,int((_a_0).shape[0])):
    if (not _a_0[_a_1]):
     raise mosek_fusion_UnexpectedError._ctor_S("elements missing from used+free list")
   for _a_4 in range(0,int((_a_0).shape[0])):
    _a_0[_a_4] = False
   _a_1 = self.__last_free
   _a_5=0
   while (_a_1 >= 0):
    _a_5 += 1
    _a_0[_a_1] = True
    _a_1 = self.__prev[_a_1]
    if ((_a_1 >= 0) and _a_0[_a_1]):
     raise mosek_fusion_UnexpectedError._ctor_S("prev list is inconsistent")
   if (_a_5!=self.__nfree):
    raise mosek_fusion_UnexpectedError._ctor_S("free prev list did not contain nfree elements")
   return (True)
 return LinkedInts
mosek_fusion_LinkedInts=__mk_mosek_fusion_LinkedInts()
del __mk_mosek_fusion_LinkedInts
#BEFORE CLASS
def __mk_mosek_fusion_Parameters():
 class Parameters(object):
  @staticmethod
  def setParameter(*args):
    '''
    Syntax
    ------

      mosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)
      mosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)
      mosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)

    Description
    -----------

    

    Parameters
    ----------

    M : mosek.fusion.Model
    name : string
    value : double
    '''
    if False: pass
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SD(*args)
    else:
      raise ValueError('Invalid argument list setParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)')
  def __repr__(self): return 'mosek.fusion.Parameters'
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_a_0) and __arg_match_S__(_a_1) and __arg_match_D__(_a_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_a_0) and __arg_alt_match_S__(_a_1) and __arg_alt_match_D__(_a_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SD(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(_a_0,_a_1,numpy.float64(__a_2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SD(_a_0,_a_1,_a_2):
   if False:
    pass
   elif (_a_1=="autoUpdateSolInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_a_1=="removeUnusedSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_a_1=="numThreads"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_3=_a_2
     if (0 <= _a_3):
      _a_0._task_1put_1param_SD("MSK_IPAR_NUM_THREADS",_a_3)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_a_1=="mtSpincount"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_4=_a_2
     if ((0 <= _a_4) and (_a_4 <= 1000000000)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MT_SPINCOUNT",_a_4)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_a_1=="optimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   elif (_a_1=="simPrecision"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecision)")
   if (_a_1=="biMaxIterations"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_5=_a_2
     if (0 <= _a_5):
      _a_0._task_1put_1param_SD("MSK_IPAR_BI_MAX_ITERATIONS",_a_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_a_1=="licenseTrhExpiryWrn"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_6=_a_2
     if (0 <= _a_6):
      _a_0._task_1put_1param_SD("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_a_6)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_a_1=="logCutSecondOpt"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_7=_a_2
     if (0 <= _a_7):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_CUT_SECOND_OPT",_a_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   elif (_a_1=="logLocalInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_a_1=="logBi"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_8=_a_2
     if (0 <= _a_8):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_BI",_a_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_a_1=="logBiFreq"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_9=_a_2
     if (0 <= _a_9):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_BI_FREQ",_a_9)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_a_1=="biCleanOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_a_1=="intpntStartingPoint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_a_1=="intpntDiffStep"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_a_1=="intpntScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_a_1=="intpntSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_a_1=="logIntpnt"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_10=_a_2
     if (0 <= _a_10):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_INTPNT",_a_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_a_1=="intpntMaxIterations"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_11=_a_2
     if (0 <= _a_11):
      _a_0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_ITERATIONS",_a_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_a_1=="intpntOffColTrh"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_12=_a_2
     if (0 <= _a_12):
      _a_0._task_1put_1param_SD("MSK_IPAR_INTPNT_OFF_COL_TRH",_a_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_a_1=="intpntOrderMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_a_1=="intpntOrderGpNumSeeds"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_13=_a_2
     if (0 <= _a_13):
      _a_0._task_1put_1param_SD("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_a_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_a_1=="intpntBasis"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_a_1=="biIgnoreMaxIter"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_a_1=="biIgnoreNumError"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_a_1=="intpntMaxNumCor"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_14=_a_2
     if ((- 1) <= _a_14):
      _a_0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_NUM_COR",_a_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_a_1=="presolveUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_a_1=="logPresolve"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_15=_a_2
     if (0 <= _a_15):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_PRESOLVE",_a_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_a_1=="presolveLindepUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   elif (_a_1=="presolveLindepNew"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepNew)")
   if (_a_1=="presolveMaxNumPass"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_16=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_a_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_a_1=="presolveEliminatorMaxNumTries"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_17=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_a_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_a_1=="presolveEliminatorMaxFill"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_18=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_a_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   elif (_a_1=="foldingUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingUse)")
   if (_a_1=="simPrimalCrash"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_19=_a_2
     if (0 <= _a_19):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_CRASH",_a_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_a_1=="logSim"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_20=_a_2
     if (0 <= _a_20):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_SIM",_a_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_a_1=="logSimFreq"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_21=_a_2
     if (0 <= _a_21):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ",_a_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_a_1=="logSimFreqGigaTicks"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_22=_a_2
     if ((- 1) <= _a_22):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ_GIGA_TICKS",_a_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreqGigaTicks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreqGigaTicks)")
   if (_a_1=="heartbeatSimFreqTicks"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_23=_a_2
     if ((- 1) <= _a_23):
      _a_0._task_1put_1param_SD("MSK_IPAR_HEARTBEAT_SIM_FREQ_TICKS",_a_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (heartbeatSimFreqTicks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (heartbeatSimFreqTicks)")
   if (_a_1=="simPrimalRestrictSelection"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_24=_a_2
     if ((0 <= _a_24) and (_a_24 <= 100)):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_a_24)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_a_1=="simPrimalSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_a_1=="simDualRestrictSelection"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_25=_a_2
     if ((0 <= _a_25) and (_a_25 <= 100)):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_a_25)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_a_1=="simDualSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_a_1=="simMaxIterations"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_26=_a_2
     if (0 <= _a_26):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_ITERATIONS",_a_26)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_a_1=="simHotstartLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_a_1=="simRefactorFreq"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_27=_a_2
     if (0 <= _a_27):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_REFACTOR_FREQ",_a_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_a_1=="simSeed"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_28=_a_2
     if ((0 <= _a_28) and (_a_28 <= 32749)):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_SEED",_a_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_a_1=="mioMode"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_a_1=="logMio"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_29=_a_2
     if (0 <= _a_29):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_MIO",_a_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_a_1=="logMioFreq"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_30=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_MIO_FREQ",_a_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_a_1=="mioMaxNumRelaxs"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_31=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RELAXS",_a_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_a_1=="mioMaxNumBranches"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_32=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_a_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_a_1=="mioMaxNumRestarts"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_33=_a_2
     if (0 <= _a_33):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RESTARTS",_a_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRestarts)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRestarts)")
   if (_a_1=="mioMaxNumRootCutRounds"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_34=_a_2
     if (0 <= _a_34):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_a_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_a_1=="mioMaxNumSolutions"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_35=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_a_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_a_1=="mioNodeSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   elif (_a_1=="mioVarSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVarSelection)")
   if (_a_1=="mioMinRel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_36=_a_2
     if (0 <= _a_36):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MIN_REL",_a_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMinRel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMinRel)")
   if (_a_1=="mioHeuristicLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_37=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_HEURISTIC_LEVEL",_a_37)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_a_1=="mioProbingLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_38=_a_2
     if (((- 1) <= _a_38) and (_a_38 <= 3)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_PROBING_LEVEL",_a_38)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_a_1=="mioSymmetryLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_39=_a_2
     if (((- 1) <= _a_39) and (_a_39 <= 4)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_SYMMETRY_LEVEL",_a_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
   if (_a_1=="mioDualRayAnalysisLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_40=_a_2
     if (((- 1) <= _a_40) and (_a_40 <= 2)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL",_a_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDualRayAnalysisLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDualRayAnalysisLevel)")
   if (_a_1=="mioConflictAnalysisLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_41=_a_2
     if (((- 1) <= _a_41) and (_a_41 <= 2)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_CONFLICT_ANALYSIS_LEVEL",_a_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConflictAnalysisLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConflictAnalysisLevel)")
   elif (_a_1=="mioPresolveAggregatorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPresolveAggregatorUse)")
   if (_a_1=="mioNumericalEmphasisLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_42=_a_2
     if ((0 <= _a_42) and (_a_42 <= 2)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL",_a_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
   if (_a_1=="mioMemoryEmphasisLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_43=_a_2
     if ((0 <= _a_43) and (_a_43 <= 1)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL",_a_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
   if (_a_1=="mioCutSelectionLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_44=_a_2
     if (((- 1) <= _a_44) and (_a_44 <= 1)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_a_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_a_1=="mioVbDetectionLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_45=_a_2
     if (((- 1) <= _a_45) and (_a_45 <= 2)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_a_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_a_1=="mioBranchDir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_a_1=="mioRootOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_a_1=="mioNodeOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_a_1=="mioPerspectiveReformulate"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_a_1=="mioPropagateObjectiveConstraint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_a_1=="mioSeed"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_46=_a_2
     if (0 <= _a_46):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_SEED",_a_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_a_1=="mioConicOuterApproximation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_a_1=="mioQcqoReformulationMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioQcqoReformulationMethod)")
   elif (_a_1=="mioDataPermutationMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDataPermutationMethod)")
   elif (_a_1=="writeMpsFormat"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeMpsFormat)")
   if (_a_1=="writeLpLineWidth"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_47=_a_2
     if (40 <= _a_47):
      _a_0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_LINE_WIDTH",_a_47)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   elif (_a_1=="writeLpFullObj"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   elif (_a_1=="writeJsonIndentation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeJsonIndentation)")
   elif (_a_1=="infeasReportAuto"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasReportAuto)")
   elif (_a_1=="licenseWait"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_a_1=="licenseSuppressExpireWrns"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_a_1=="licensePauseTime"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_48=_a_2
     if ((0 <= _a_48) and (_a_48 <= 1000000)):
      _a_0._task_1put_1param_SD("MSK_IPAR_LICENSE_PAUSE_TIME",_a_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_a_1=="licenseDebug"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_a_1=="log"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_49=_a_2
     if (0 <= _a_49):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG",_a_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_a_1=="logExpand"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_50=_a_2
     if (0 <= _a_50):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_EXPAND",_a_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_a_1=="logFile"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_51=_a_2
     if (0 <= _a_51):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_FILE",_a_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_a_1=="logOrder"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_52=_a_2
     if (0 <= _a_52):
      _a_0._task_1put_1param_SD("MSK_IPAR_LOG_ORDER",_a_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_a_1=="simScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_a_1=="simScalingMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_a_1=="simPrimalPhaseoneMethod"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_53=_a_2
     if ((0 <= _a_53) and (_a_53 <= 10)):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_a_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_a_1=="simDualPhaseoneMethod"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_54=_a_2
     if ((0 <= _a_54) and (_a_54 <= 10)):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_a_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_a_1=="simMaxNumSetbacks"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_55=_a_2
     if (0 <= _a_55):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_a_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_a_1=="simHotstart"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_a_1=="simBasisFactorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_a_1=="simPrecisionBoost"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionBoost)")
   elif (_a_1=="simDegen"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_a_1=="simReformulation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_a_1=="simExploitDupvec"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_a_1=="simSaveLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_a_1=="simNonSingular"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_a_1=="simDualCrash"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_56=_a_2
     if (0 <= _a_56):
      _a_0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_CRASH",_a_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_a_1=="ptfWriteTransform"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteTransform)")
   elif (_a_1=="ptfWriteSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteSolutions)")
   elif (_a_1=="ptfWriteParameters"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteParameters)")
   elif (_a_1=="ptfWriteSinglePsdTerms"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteSinglePsdTerms)")
   elif (_a_1=="mioCutCmir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_a_1=="mioCutClique"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_a_1=="mioCutImpliedBound"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_a_1=="mioCutKnapsackCover"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_a_1=="mioCutGmi"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_a_1=="mioCutLipro"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutLipro)")
   elif (_a_1=="mioConstructSol"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_a_1=="presolveLindepRelWorkTrh"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_57=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_a_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_a_1=="presolveLindepAbsWorkTrh"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_58=_a_2
     if True:
      _a_0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_a_58)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_a_1=="cacheLicense"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_a_1=="intpntRegularizationUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_a_1=="simSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_a_1=="simSwitchOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   elif (_a_1=="autoSortABeforeOpt"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoSortABeforeOpt)")
   if (_a_1=="mioRinsMaxNodes"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_59=_a_2
     if ((- 1) <= _a_59):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_RINS_MAX_NODES",_a_59)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_a_1=="mioRensMaxNodes"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_60=_a_2
     if ((- 1) <= _a_60):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_RENS_MAX_NODES",_a_60)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRensMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRensMaxNodes)")
   if (_a_1=="mioCrossoverMaxNodes"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_61=_a_2
     if ((- 1) <= _a_61):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_CROSSOVER_MAX_NODES",_a_61)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCrossoverMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCrossoverMaxNodes)")
   if (_a_1=="mioOptFaceMaxNodes"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_62=_a_2
     if ((- 1) <= _a_62):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_OPT_FACE_MAX_NODES",_a_62)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioOptFaceMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioOptFaceMaxNodes)")
   if (_a_1=="mioFeaspumpLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_63=_a_2
     if (((- 1) <= _a_63) and (_a_63 <= 2)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_FEASPUMP_LEVEL",_a_63)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_a_1=="mioIndependentBlockLevel"):
    if ((_a_2 - numpy.int32(_a_2))==0.0):
     _a_64=_a_2
     if (((- 1) <= _a_64) and (_a_64 <= 3)):
      _a_0._task_1put_1param_SD("MSK_IPAR_MIO_INDEPENDENT_BLOCK_LEVEL",_a_64)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioIndependentBlockLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioIndependentBlockLevel)")
   elif (_a_1=="remoteUseCompression"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteUseCompression)")
   if (_a_1=="semidefiniteTolApprox"):
    _a_65=_a_2
    if (1.000000e-15 <= _a_65):
     _a_0._task_1put_1param_SD("MSK_DPAR_SEMIDEFINITE_TOL_APPROX",_a_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (semidefiniteTolApprox)")
   if (_a_1=="optimizerMaxTime"):
    _a_66=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_a_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_a_1=="optimizerMaxTicks"):
    _a_67=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TICKS",_a_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTicks)")
   if (_a_1=="lowerObjCut"):
    _a_68=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_a_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_a_1=="upperObjCut"):
    _a_69=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_a_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_a_1=="upperObjCutFiniteTrh"):
    _a_70=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_a_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_a_1=="lowerObjCutFiniteTrh"):
    _a_71=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_a_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_a_1=="intpntTolRelGap"):
    _a_72=_a_2
    if (1.000000e-14 <= _a_72):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_a_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_a_1=="intpntTolStepSize"):
    _a_73=_a_2
    if ((0.000000e+00 <= _a_73) and (_a_73 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_a_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_a_1=="simLuTolRelPiv"):
    _a_74=_a_2
    if ((1.000000e-06 <= _a_74) and (_a_74 <= 9.999990e-01)):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_a_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_a_1=="intpntTolRelStep"):
    _a_75=_a_2
    if ((1.000000e-04 <= _a_75) and (_a_75 <= 9.999990e-01)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_a_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_a_1=="intpntTolPath"):
    _a_76=_a_2
    if ((0.000000e+00 <= _a_76) and (_a_76 <= 9.999000e-01)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_a_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_a_1=="intpntTolPfeas"):
    _a_77=_a_2
    if ((0.000000e+00 <= _a_77) and (_a_77 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_a_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_a_1=="intpntTolDfeas"):
    _a_78=_a_2
    if ((0.000000e+00 <= _a_78) and (_a_78 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_a_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_a_1=="intpntTolMuRed"):
    _a_79=_a_2
    if ((0.000000e+00 <= _a_79) and (_a_79 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_a_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_a_1=="intpntTolInfeas"):
    _a_80=_a_2
    if ((0.000000e+00 <= _a_80) and (_a_80 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_a_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_a_1=="intpntCoTolRelGap"):
    _a_81=_a_2
    if ((0.000000e+00 <= _a_81) and (_a_81 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_a_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_a_1=="intpntCoTolPfeas"):
    _a_82=_a_2
    if ((0.000000e+00 <= _a_82) and (_a_82 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_a_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_a_1=="intpntCoTolDfeas"):
    _a_83=_a_2
    if ((0.000000e+00 <= _a_83) and (_a_83 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_a_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_a_1=="intpntCoTolMuRed"):
    _a_84=_a_2
    if ((0.000000e+00 <= _a_84) and (_a_84 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_a_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_a_1=="intpntCoTolNearRel"):
    _a_85=_a_2
    if (1.000000e+00 <= _a_85):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_a_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_a_1=="intpntCoTolInfeas"):
    _a_86=_a_2
    if ((0.000000e+00 <= _a_86) and (_a_86 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_a_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_a_1=="intpntTolPsafe"):
    _a_87=_a_2
    if (1.000000e-04 <= _a_87):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_a_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_a_1=="intpntTolDsafe"):
    _a_88=_a_2
    if (1.000000e-04 <= _a_88):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_a_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_a_1=="mioMaxTime"):
    _a_89=_a_2
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_a_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_a_1=="mioRelGapConst"):
    _a_90=_a_2
    if (1.000000e-15 <= _a_90):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_a_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_a_1=="mioTolRelGap"):
    _a_91=_a_2
    if (0.000000e+00 <= _a_91):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_a_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_a_1=="mioTolAbsGap"):
    _a_92=_a_2
    if (0.000000e+00 <= _a_92):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_a_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_a_1=="mioTolAbsRelaxInt"):
    _a_93=_a_2
    if (1.000000e-09 <= _a_93):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_a_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_a_1=="mioDjcMaxBigm"):
    _a_94=_a_2
    if (0.000000e+00 <= _a_94):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_DJC_MAX_BIGM",_a_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
   if (_a_1=="mioCliqueTableSizeFactor"):
    _a_95=_a_2
    if ((- 1.000000e+00) <= _a_95):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_CLIQUE_TABLE_SIZE_FACTOR",_a_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCliqueTableSizeFactor)")
   if (_a_1=="simPrecisionScalingNormal"):
    _a_96=_a_2
    if (1.000000e+00 <= _a_96):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIM_PRECISION_SCALING_NORMAL",_a_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingNormal)")
   if (_a_1=="simPrecisionScalingExtended"):
    _a_97=_a_2
    if (1.000000e+00 <= _a_97):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIM_PRECISION_SCALING_EXTENDED",_a_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingExtended)")
   if (_a_1=="basisTolX"):
    _a_98=_a_2
    if (1.000000e-09 <= _a_98):
     _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_a_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_a_1=="basisTolS"):
    _a_99=_a_2
    if (1.000000e-09 <= _a_99):
     _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_a_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_a_1=="basisRelTolS"):
    _a_100=_a_2
    if (0.000000e+00 <= _a_100):
     _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_a_100)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_a_1=="presolveTolX"):
    _a_101=_a_2
    if (0.000000e+00 <= _a_101):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_a_101)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_a_1=="presolveTolPrimalInfeasPerturbation"):
    _a_102=_a_2
    if (0.000000e+00 <= _a_102):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION",_a_102)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
   if (_a_1=="presolveTolS"):
    _a_103=_a_2
    if (0.000000e+00 <= _a_103):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_a_103)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_a_1=="presolveTolAbsLindep"):
    _a_104=_a_2
    if (0.000000e+00 <= _a_104):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_a_104)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_a_1=="presolveTolRelLindep"):
    _a_105=_a_2
    if (0.000000e+00 <= _a_105):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_a_105)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_a_1=="foldingTolEq"):
    _a_106=_a_2
    if (0.000000e+00 <= _a_106):
     _a_0._task_1put_1param_SD("MSK_DPAR_FOLDING_TOL_EQ",_a_106)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingTolEq)")
   if (_a_1=="simplexAbsTolPiv"):
    _a_107=_a_2
    if (1.000000e-12 <= _a_107):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_a_107)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_a_1=="mioTolFeas"):
    _a_108=_a_2
    if ((1.000000e-09 <= _a_108) and (_a_108 <= 1.000000e-03)):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_a_108)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_a_1=="mioTolRelDualBoundImprovement"):
    _a_109=_a_2
    if ((0.000000e+00 <= _a_109) and (_a_109 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_a_109)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_a_1=="dataFileName"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_a_1=="remoteOptserverHost"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteOptserverHost)")
   elif (_a_1=="remoteTlsCertPath"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCertPath)")
   elif (_a_1=="remoteTlsCert"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCert)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_a_0) and __arg_match_S__(_a_1) and __arg_match_I__(_a_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_a_0) and __arg_alt_match_S__(_a_1) and __arg_alt_match_I__(_a_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SI(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(_a_0,_a_1,numpy.int32(__a_2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SI(_a_0,_a_1,_a_2):
   if False:
    pass
   elif (_a_1=="autoUpdateSolInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_a_1=="removeUnusedSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_a_1=="numThreads"):
    _a_3=_a_2
    if (0 <= _a_3):
     _a_0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_a_3)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_a_1=="mtSpincount"):
    _a_4=_a_2
    if ((0 <= _a_4) and (_a_4 <= 1000000000)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_a_4)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_a_1=="optimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   elif (_a_1=="simPrecision"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecision)")
   if (_a_1=="biMaxIterations"):
    _a_5=_a_2
    if (0 <= _a_5):
     _a_0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_a_5)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_a_1=="licenseTrhExpiryWrn"):
    _a_6=_a_2
    if (0 <= _a_6):
     _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_a_6)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_a_1=="logCutSecondOpt"):
    _a_7=_a_2
    if (0 <= _a_7):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_a_7)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   elif (_a_1=="logLocalInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_a_1=="logBi"):
    _a_8=_a_2
    if (0 <= _a_8):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_a_8)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_a_1=="logBiFreq"):
    _a_9=_a_2
    if (0 <= _a_9):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_a_9)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_a_1=="biCleanOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_a_1=="intpntStartingPoint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_a_1=="intpntDiffStep"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_a_1=="intpntScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_a_1=="intpntSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_a_1=="logIntpnt"):
    _a_10=_a_2
    if (0 <= _a_10):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_a_10)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_a_1=="intpntMaxIterations"):
    _a_11=_a_2
    if (0 <= _a_11):
     _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_a_11)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_a_1=="intpntOffColTrh"):
    _a_12=_a_2
    if (0 <= _a_12):
     _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_a_12)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_a_1=="intpntOrderMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_a_1=="intpntOrderGpNumSeeds"):
    _a_13=_a_2
    if (0 <= _a_13):
     _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_a_13)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_a_1=="intpntBasis"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_a_1=="biIgnoreMaxIter"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_a_1=="biIgnoreNumError"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_a_1=="intpntMaxNumCor"):
    _a_14=_a_2
    if ((- 1) <= _a_14):
     _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_a_14)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_a_1=="presolveUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_a_1=="logPresolve"):
    _a_15=_a_2
    if (0 <= _a_15):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_a_15)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_a_1=="presolveLindepUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   elif (_a_1=="presolveLindepNew"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepNew)")
   if (_a_1=="presolveMaxNumPass"):
    _a_16=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_a_16)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_a_1=="presolveEliminatorMaxNumTries"):
    _a_17=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_a_17)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_a_1=="presolveEliminatorMaxFill"):
    _a_18=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_a_18)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   elif (_a_1=="foldingUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingUse)")
   if (_a_1=="simPrimalCrash"):
    _a_19=_a_2
    if (0 <= _a_19):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_a_19)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_a_1=="logSim"):
    _a_20=_a_2
    if (0 <= _a_20):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_a_20)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_a_1=="logSimFreq"):
    _a_21=_a_2
    if (0 <= _a_21):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_a_21)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_a_1=="logSimFreqGigaTicks"):
    _a_22=_a_2
    if ((- 1) <= _a_22):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ_GIGA_TICKS",_a_22)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreqGigaTicks)")
   if (_a_1=="heartbeatSimFreqTicks"):
    _a_23=_a_2
    if ((- 1) <= _a_23):
     _a_0._task_1put_1param_SI("MSK_IPAR_HEARTBEAT_SIM_FREQ_TICKS",_a_23)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (heartbeatSimFreqTicks)")
   if (_a_1=="simPrimalRestrictSelection"):
    _a_24=_a_2
    if ((0 <= _a_24) and (_a_24 <= 100)):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_a_24)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_a_1=="simPrimalSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_a_1=="simDualRestrictSelection"):
    _a_25=_a_2
    if ((0 <= _a_25) and (_a_25 <= 100)):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_a_25)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_a_1=="simDualSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_a_1=="simMaxIterations"):
    _a_26=_a_2
    if (0 <= _a_26):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_a_26)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_a_1=="simHotstartLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_a_1=="simRefactorFreq"):
    _a_27=_a_2
    if (0 <= _a_27):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_a_27)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_a_1=="simSeed"):
    _a_28=_a_2
    if ((0 <= _a_28) and (_a_28 <= 32749)):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_a_28)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_a_1=="mioMode"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_a_1=="logMio"):
    _a_29=_a_2
    if (0 <= _a_29):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_a_29)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_a_1=="logMioFreq"):
    _a_30=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_a_30)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_a_1=="mioMaxNumRelaxs"):
    _a_31=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_a_31)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_a_1=="mioMaxNumBranches"):
    _a_32=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_a_32)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_a_1=="mioMaxNumRestarts"):
    _a_33=_a_2
    if (0 <= _a_33):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RESTARTS",_a_33)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRestarts)")
   if (_a_1=="mioMaxNumRootCutRounds"):
    _a_34=_a_2
    if (0 <= _a_34):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_a_34)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_a_1=="mioMaxNumSolutions"):
    _a_35=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_a_35)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_a_1=="mioNodeSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   elif (_a_1=="mioVarSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVarSelection)")
   if (_a_1=="mioMinRel"):
    _a_36=_a_2
    if (0 <= _a_36):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MIN_REL",_a_36)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMinRel)")
   if (_a_1=="mioHeuristicLevel"):
    _a_37=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_a_37)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_a_1=="mioProbingLevel"):
    _a_38=_a_2
    if (((- 1) <= _a_38) and (_a_38 <= 3)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_a_38)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_a_1=="mioSymmetryLevel"):
    _a_39=_a_2
    if (((- 1) <= _a_39) and (_a_39 <= 4)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_SYMMETRY_LEVEL",_a_39)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
   if (_a_1=="mioDualRayAnalysisLevel"):
    _a_40=_a_2
    if (((- 1) <= _a_40) and (_a_40 <= 2)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL",_a_40)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDualRayAnalysisLevel)")
   if (_a_1=="mioConflictAnalysisLevel"):
    _a_41=_a_2
    if (((- 1) <= _a_41) and (_a_41 <= 2)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CONFLICT_ANALYSIS_LEVEL",_a_41)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConflictAnalysisLevel)")
   elif (_a_1=="mioPresolveAggregatorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPresolveAggregatorUse)")
   if (_a_1=="mioNumericalEmphasisLevel"):
    _a_42=_a_2
    if ((0 <= _a_42) and (_a_42 <= 2)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL",_a_42)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
   if (_a_1=="mioMemoryEmphasisLevel"):
    _a_43=_a_2
    if ((0 <= _a_43) and (_a_43 <= 1)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL",_a_43)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
   if (_a_1=="mioCutSelectionLevel"):
    _a_44=_a_2
    if (((- 1) <= _a_44) and (_a_44 <= 1)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_a_44)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_a_1=="mioVbDetectionLevel"):
    _a_45=_a_2
    if (((- 1) <= _a_45) and (_a_45 <= 2)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_a_45)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_a_1=="mioBranchDir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_a_1=="mioRootOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_a_1=="mioNodeOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_a_1=="mioPerspectiveReformulate"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_a_1=="mioPropagateObjectiveConstraint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_a_1=="mioSeed"):
    _a_46=_a_2
    if (0 <= _a_46):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_a_46)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_a_1=="mioConicOuterApproximation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_a_1=="mioQcqoReformulationMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioQcqoReformulationMethod)")
   elif (_a_1=="mioDataPermutationMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDataPermutationMethod)")
   elif (_a_1=="writeMpsFormat"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeMpsFormat)")
   if (_a_1=="writeLpLineWidth"):
    _a_47=_a_2
    if (40 <= _a_47):
     _a_0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_a_47)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   elif (_a_1=="writeLpFullObj"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   elif (_a_1=="writeJsonIndentation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeJsonIndentation)")
   elif (_a_1=="infeasReportAuto"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasReportAuto)")
   elif (_a_1=="licenseWait"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_a_1=="licenseSuppressExpireWrns"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_a_1=="licensePauseTime"):
    _a_48=_a_2
    if ((0 <= _a_48) and (_a_48 <= 1000000)):
     _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_a_48)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_a_1=="licenseDebug"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_a_1=="log"):
    _a_49=_a_2
    if (0 <= _a_49):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG",_a_49)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_a_1=="logExpand"):
    _a_50=_a_2
    if (0 <= _a_50):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_a_50)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_a_1=="logFile"):
    _a_51=_a_2
    if (0 <= _a_51):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_a_51)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_a_1=="logOrder"):
    _a_52=_a_2
    if (0 <= _a_52):
     _a_0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_a_52)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_a_1=="simScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_a_1=="simScalingMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_a_1=="simPrimalPhaseoneMethod"):
    _a_53=_a_2
    if ((0 <= _a_53) and (_a_53 <= 10)):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_a_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_a_1=="simDualPhaseoneMethod"):
    _a_54=_a_2
    if ((0 <= _a_54) and (_a_54 <= 10)):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_a_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_a_1=="simMaxNumSetbacks"):
    _a_55=_a_2
    if (0 <= _a_55):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_a_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_a_1=="simHotstart"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_a_1=="simBasisFactorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_a_1=="simPrecisionBoost"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionBoost)")
   elif (_a_1=="simDegen"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_a_1=="simReformulation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_a_1=="simExploitDupvec"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_a_1=="simSaveLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_a_1=="simNonSingular"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_a_1=="simDualCrash"):
    _a_56=_a_2
    if (0 <= _a_56):
     _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_a_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_a_1=="ptfWriteTransform"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteTransform)")
   elif (_a_1=="ptfWriteSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteSolutions)")
   elif (_a_1=="ptfWriteParameters"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteParameters)")
   elif (_a_1=="ptfWriteSinglePsdTerms"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteSinglePsdTerms)")
   elif (_a_1=="mioCutCmir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_a_1=="mioCutClique"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_a_1=="mioCutImpliedBound"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_a_1=="mioCutKnapsackCover"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_a_1=="mioCutGmi"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_a_1=="mioCutLipro"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutLipro)")
   elif (_a_1=="mioConstructSol"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_a_1=="presolveLindepRelWorkTrh"):
    _a_57=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_a_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_a_1=="presolveLindepAbsWorkTrh"):
    _a_58=_a_2
    if True:
     _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_a_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_a_1=="cacheLicense"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_a_1=="intpntRegularizationUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_a_1=="simSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_a_1=="simSwitchOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   elif (_a_1=="autoSortABeforeOpt"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoSortABeforeOpt)")
   if (_a_1=="mioRinsMaxNodes"):
    _a_59=_a_2
    if ((- 1) <= _a_59):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_a_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_a_1=="mioRensMaxNodes"):
    _a_60=_a_2
    if ((- 1) <= _a_60):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_RENS_MAX_NODES",_a_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRensMaxNodes)")
   if (_a_1=="mioCrossoverMaxNodes"):
    _a_61=_a_2
    if ((- 1) <= _a_61):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CROSSOVER_MAX_NODES",_a_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCrossoverMaxNodes)")
   if (_a_1=="mioOptFaceMaxNodes"):
    _a_62=_a_2
    if ((- 1) <= _a_62):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_OPT_FACE_MAX_NODES",_a_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioOptFaceMaxNodes)")
   if (_a_1=="mioFeaspumpLevel"):
    _a_63=_a_2
    if (((- 1) <= _a_63) and (_a_63 <= 2)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_a_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_a_1=="mioIndependentBlockLevel"):
    _a_64=_a_2
    if (((- 1) <= _a_64) and (_a_64 <= 3)):
     _a_0._task_1put_1param_SI("MSK_IPAR_MIO_INDEPENDENT_BLOCK_LEVEL",_a_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioIndependentBlockLevel)")
   elif (_a_1=="remoteUseCompression"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteUseCompression)")
   if (_a_1=="semidefiniteTolApprox"):
    _a_65=numpy.float64(_a_2)
    if (1.000000e-15 <= _a_65):
     _a_0._task_1put_1param_SD("MSK_DPAR_SEMIDEFINITE_TOL_APPROX",_a_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (semidefiniteTolApprox)")
   if (_a_1=="optimizerMaxTime"):
    _a_66=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_a_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_a_1=="optimizerMaxTicks"):
    _a_67=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TICKS",_a_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTicks)")
   if (_a_1=="lowerObjCut"):
    _a_68=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_a_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_a_1=="upperObjCut"):
    _a_69=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_a_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_a_1=="upperObjCutFiniteTrh"):
    _a_70=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_a_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_a_1=="lowerObjCutFiniteTrh"):
    _a_71=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_a_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_a_1=="intpntTolRelGap"):
    _a_72=numpy.float64(_a_2)
    if (1.000000e-14 <= _a_72):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_a_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_a_1=="intpntTolStepSize"):
    _a_73=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_73) and (_a_73 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_a_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_a_1=="simLuTolRelPiv"):
    _a_74=numpy.float64(_a_2)
    if ((1.000000e-06 <= _a_74) and (_a_74 <= 9.999990e-01)):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_a_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_a_1=="intpntTolRelStep"):
    _a_75=numpy.float64(_a_2)
    if ((1.000000e-04 <= _a_75) and (_a_75 <= 9.999990e-01)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_a_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_a_1=="intpntTolPath"):
    _a_76=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_76) and (_a_76 <= 9.999000e-01)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_a_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_a_1=="intpntTolPfeas"):
    _a_77=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_77) and (_a_77 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_a_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_a_1=="intpntTolDfeas"):
    _a_78=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_78) and (_a_78 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_a_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_a_1=="intpntTolMuRed"):
    _a_79=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_79) and (_a_79 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_a_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_a_1=="intpntTolInfeas"):
    _a_80=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_80) and (_a_80 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_a_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_a_1=="intpntCoTolRelGap"):
    _a_81=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_81) and (_a_81 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_a_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_a_1=="intpntCoTolPfeas"):
    _a_82=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_82) and (_a_82 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_a_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_a_1=="intpntCoTolDfeas"):
    _a_83=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_83) and (_a_83 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_a_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_a_1=="intpntCoTolMuRed"):
    _a_84=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_84) and (_a_84 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_a_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_a_1=="intpntCoTolNearRel"):
    _a_85=numpy.float64(_a_2)
    if (1.000000e+00 <= _a_85):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_a_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_a_1=="intpntCoTolInfeas"):
    _a_86=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_86) and (_a_86 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_a_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_a_1=="intpntTolPsafe"):
    _a_87=numpy.float64(_a_2)
    if (1.000000e-04 <= _a_87):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_a_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_a_1=="intpntTolDsafe"):
    _a_88=numpy.float64(_a_2)
    if (1.000000e-04 <= _a_88):
     _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_a_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_a_1=="mioMaxTime"):
    _a_89=numpy.float64(_a_2)
    if True:
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_a_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_a_1=="mioRelGapConst"):
    _a_90=numpy.float64(_a_2)
    if (1.000000e-15 <= _a_90):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_a_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_a_1=="mioTolRelGap"):
    _a_91=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_91):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_a_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_a_1=="mioTolAbsGap"):
    _a_92=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_92):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_a_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_a_1=="mioTolAbsRelaxInt"):
    _a_93=numpy.float64(_a_2)
    if (1.000000e-09 <= _a_93):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_a_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_a_1=="mioDjcMaxBigm"):
    _a_94=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_94):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_DJC_MAX_BIGM",_a_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
   if (_a_1=="mioCliqueTableSizeFactor"):
    _a_95=numpy.float64(_a_2)
    if ((- 1.000000e+00) <= _a_95):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_CLIQUE_TABLE_SIZE_FACTOR",_a_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCliqueTableSizeFactor)")
   if (_a_1=="simPrecisionScalingNormal"):
    _a_96=numpy.float64(_a_2)
    if (1.000000e+00 <= _a_96):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIM_PRECISION_SCALING_NORMAL",_a_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingNormal)")
   if (_a_1=="simPrecisionScalingExtended"):
    _a_97=numpy.float64(_a_2)
    if (1.000000e+00 <= _a_97):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIM_PRECISION_SCALING_EXTENDED",_a_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingExtended)")
   if (_a_1=="basisTolX"):
    _a_98=numpy.float64(_a_2)
    if (1.000000e-09 <= _a_98):
     _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_a_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_a_1=="basisTolS"):
    _a_99=numpy.float64(_a_2)
    if (1.000000e-09 <= _a_99):
     _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_a_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_a_1=="basisRelTolS"):
    _a_100=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_100):
     _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_a_100)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_a_1=="presolveTolX"):
    _a_101=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_101):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_a_101)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_a_1=="presolveTolPrimalInfeasPerturbation"):
    _a_102=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_102):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION",_a_102)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
   if (_a_1=="presolveTolS"):
    _a_103=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_103):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_a_103)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_a_1=="presolveTolAbsLindep"):
    _a_104=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_104):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_a_104)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_a_1=="presolveTolRelLindep"):
    _a_105=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_105):
     _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_a_105)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_a_1=="foldingTolEq"):
    _a_106=numpy.float64(_a_2)
    if (0.000000e+00 <= _a_106):
     _a_0._task_1put_1param_SD("MSK_DPAR_FOLDING_TOL_EQ",_a_106)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingTolEq)")
   if (_a_1=="simplexAbsTolPiv"):
    _a_107=numpy.float64(_a_2)
    if (1.000000e-12 <= _a_107):
     _a_0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_a_107)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_a_1=="mioTolFeas"):
    _a_108=numpy.float64(_a_2)
    if ((1.000000e-09 <= _a_108) and (_a_108 <= 1.000000e-03)):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_a_108)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_a_1=="mioTolRelDualBoundImprovement"):
    _a_109=numpy.float64(_a_2)
    if ((0.000000e+00 <= _a_109) and (_a_109 <= 1.000000e+00)):
     _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_a_109)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_a_1=="dataFileName"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_a_1=="remoteOptserverHost"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteOptserverHost)")
   elif (_a_1=="remoteTlsCertPath"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCertPath)")
   elif (_a_1=="remoteTlsCert"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCert)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_a_0) and __arg_match_S__(_a_1) and __arg_match_S__(_a_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _a_0,_a_1,_a_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_a_0) and __arg_alt_match_S__(_a_1) and __arg_alt_match_S__(_a_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SS(_t__a_0,_t__a_1,_t__a_2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(_a_0,_a_1,_a_2)
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SS(_a_0,_a_1,_a_2):
   if False:
    pass
   if (_a_1=="autoUpdateSolInfo"):
    _a_3=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_3 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
    _a_0._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",_a_3)
    return 
   if (_a_1=="removeUnusedSolutions"):
    _a_4=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_4 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
    _a_0._task_1put_1param_SI("MSK_IPAR_REMOVE_UNUSED_SOLUTIONS",_a_4)
    return 
   if (_a_1=="numThreads"):
    try:
     _a_5=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_5):
      _a_0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_a_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    except mosek_fusion_ValueConversionError as _a_6:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_a_1=="mtSpincount"):
    try:
     _a_7=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_7) and (_a_7 <= 1000000000)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_a_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    except mosek_fusion_ValueConversionError as _a_8:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   if (_a_1=="optimizer"):
    _a_9=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_a_2)
    if (_a_9 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
    _a_0._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",_a_9)
    return 
   if (_a_1=="simPrecision"):
    _a_10=mosek.fusion.Parameters.__string_1to_1simprecision_1value_S(_a_2)
    if (_a_10 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecision)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRECISION",_a_10)
    return 
   if (_a_1=="biMaxIterations"):
    try:
     _a_11=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_11):
      _a_0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_a_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    except mosek_fusion_ValueConversionError as _a_12:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_a_1=="licenseTrhExpiryWrn"):
    try:
     _a_13=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_13):
      _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_a_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    except mosek_fusion_ValueConversionError as _a_14:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_a_1=="logCutSecondOpt"):
    try:
     _a_15=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_15):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_a_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    except mosek_fusion_ValueConversionError as _a_16:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_a_1=="logLocalInfo"):
    _a_17=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_17 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
    _a_0._task_1put_1param_SI("MSK_IPAR_LOG_LOCAL_INFO",_a_17)
    return 
   if (_a_1=="logBi"):
    try:
     _a_18=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_18):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_a_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    except mosek_fusion_ValueConversionError as _a_19:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_a_1=="logBiFreq"):
    try:
     _a_20=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_20):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_a_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    except mosek_fusion_ValueConversionError as _a_21:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   if (_a_1=="biCleanOptimizer"):
    _a_22=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_a_2)
    if (_a_22 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
    _a_0._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",_a_22)
    return 
   if (_a_1=="intpntStartingPoint"):
    _a_23=mosek.fusion.Parameters.__string_1to_1startpointtype_1value_S(_a_2)
    if (_a_23 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",_a_23)
    return 
   if (_a_1=="intpntDiffStep"):
    _a_24=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_24 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",_a_24)
    return 
   if (_a_1=="intpntScaling"):
    _a_25=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_a_2)
    if (_a_25 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",_a_25)
    return 
   if (_a_1=="intpntSolveForm"):
    _a_26=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_a_2)
    if (_a_26 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",_a_26)
    return 
   if (_a_1=="logIntpnt"):
    try:
     _a_27=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_27):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_a_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    except mosek_fusion_ValueConversionError as _a_28:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_a_1=="intpntMaxIterations"):
    try:
     _a_29=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_29):
      _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_a_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    except mosek_fusion_ValueConversionError as _a_30:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_a_1=="intpntOffColTrh"):
    try:
     _a_31=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_31):
      _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_a_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    except mosek_fusion_ValueConversionError as _a_32:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   if (_a_1=="intpntOrderMethod"):
    _a_33=mosek.fusion.Parameters.__string_1to_1orderingtype_1value_S(_a_2)
    if (_a_33 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",_a_33)
    return 
   if (_a_1=="intpntOrderGpNumSeeds"):
    try:
     _a_34=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_34):
      _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_a_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    except mosek_fusion_ValueConversionError as _a_35:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   if (_a_1=="intpntBasis"):
    _a_36=mosek.fusion.Parameters.__string_1to_1basindtype_1value_S(_a_2)
    if (_a_36 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",_a_36)
    return 
   if (_a_1=="biIgnoreMaxIter"):
    _a_37=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_37 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
    _a_0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",_a_37)
    return 
   if (_a_1=="biIgnoreNumError"):
    _a_38=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_38 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
    _a_0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",_a_38)
    return 
   if (_a_1=="intpntMaxNumCor"):
    try:
     _a_39=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_39):
      _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_a_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    except mosek_fusion_ValueConversionError as _a_40:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   if (_a_1=="presolveUse"):
    _a_41=mosek.fusion.Parameters.__string_1to_1presolvemode_1value_S(_a_2)
    if (_a_41 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",_a_41)
    return 
   if (_a_1=="logPresolve"):
    try:
     _a_42=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_42):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_a_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    except mosek_fusion_ValueConversionError as _a_43:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   if (_a_1=="presolveLindepUse"):
    _a_44=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_44 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",_a_44)
    return 
   if (_a_1=="presolveLindepNew"):
    _a_45=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_45 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepNew)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_NEW",_a_45)
    return 
   if (_a_1=="presolveMaxNumPass"):
    try:
     _a_46=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_a_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    except mosek_fusion_ValueConversionError as _a_47:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_a_1=="presolveEliminatorMaxNumTries"):
    try:
     _a_48=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_a_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    except mosek_fusion_ValueConversionError as _a_49:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_a_1=="presolveEliminatorMaxFill"):
    try:
     _a_50=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_a_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    except mosek_fusion_ValueConversionError as _a_51:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_a_1=="foldingUse"):
    _a_52=mosek.fusion.Parameters.__string_1to_1foldingmode_1value_S(_a_2)
    if (_a_52 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingUse)")
    _a_0._task_1put_1param_SI("MSK_IPAR_FOLDING_USE",_a_52)
    return 
   if (_a_1=="simPrimalCrash"):
    try:
     _a_53=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_53):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_a_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    except mosek_fusion_ValueConversionError as _a_54:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_a_1=="logSim"):
    try:
     _a_55=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_55):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_a_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    except mosek_fusion_ValueConversionError as _a_56:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_a_1=="logSimFreq"):
    try:
     _a_57=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_57):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_a_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    except mosek_fusion_ValueConversionError as _a_58:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_a_1=="logSimFreqGigaTicks"):
    try:
     _a_59=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_59):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ_GIGA_TICKS",_a_59)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreqGigaTicks)")
    except mosek_fusion_ValueConversionError as _a_60:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreqGigaTicks)")
   if (_a_1=="heartbeatSimFreqTicks"):
    try:
     _a_61=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_61):
      _a_0._task_1put_1param_SI("MSK_IPAR_HEARTBEAT_SIM_FREQ_TICKS",_a_61)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (heartbeatSimFreqTicks)")
    except mosek_fusion_ValueConversionError as _a_62:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (heartbeatSimFreqTicks)")
   if (_a_1=="simPrimalRestrictSelection"):
    try:
     _a_63=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_63) and (_a_63 <= 100)):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_a_63)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    except mosek_fusion_ValueConversionError as _a_64:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   if (_a_1=="simPrimalSelection"):
    _a_65=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_a_2)
    if (_a_65 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",_a_65)
    return 
   if (_a_1=="simDualRestrictSelection"):
    try:
     _a_66=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_66) and (_a_66 <= 100)):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_a_66)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    except mosek_fusion_ValueConversionError as _a_67:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   if (_a_1=="simDualSelection"):
    _a_68=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_a_2)
    if (_a_68 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",_a_68)
    return 
   if (_a_1=="simMaxIterations"):
    try:
     _a_69=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_69):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_a_69)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    except mosek_fusion_ValueConversionError as _a_70:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   if (_a_1=="simHotstartLu"):
    _a_71=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_71 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",_a_71)
    return 
   if (_a_1=="simRefactorFreq"):
    try:
     _a_72=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_72):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_a_72)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    except mosek_fusion_ValueConversionError as _a_73:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_a_1=="simSeed"):
    try:
     _a_74=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_74) and (_a_74 <= 32749)):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_a_74)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    except mosek_fusion_ValueConversionError as _a_75:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   if (_a_1=="mioMode"):
    _a_76=mosek.fusion.Parameters.__string_1to_1miomode_1value_S(_a_2)
    if (_a_76 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MODE",_a_76)
    return 
   if (_a_1=="logMio"):
    try:
     _a_77=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_77):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_a_77)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    except mosek_fusion_ValueConversionError as _a_78:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_a_1=="logMioFreq"):
    try:
     _a_79=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_a_79)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    except mosek_fusion_ValueConversionError as _a_80:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_a_1=="mioMaxNumRelaxs"):
    try:
     _a_81=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_a_81)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    except mosek_fusion_ValueConversionError as _a_82:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_a_1=="mioMaxNumBranches"):
    try:
     _a_83=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_a_83)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    except mosek_fusion_ValueConversionError as _a_84:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_a_1=="mioMaxNumRestarts"):
    try:
     _a_85=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_85):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RESTARTS",_a_85)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRestarts)")
    except mosek_fusion_ValueConversionError as _a_86:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRestarts)")
   if (_a_1=="mioMaxNumRootCutRounds"):
    try:
     _a_87=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_87):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_a_87)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    except mosek_fusion_ValueConversionError as _a_88:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_a_1=="mioMaxNumSolutions"):
    try:
     _a_89=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_a_89)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    except mosek_fusion_ValueConversionError as _a_90:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   if (_a_1=="mioNodeSelection"):
    _a_91=mosek.fusion.Parameters.__string_1to_1mionodeseltype_1value_S(_a_2)
    if (_a_91 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",_a_91)
    return 
   if (_a_1=="mioVarSelection"):
    _a_92=mosek.fusion.Parameters.__string_1to_1miovarseltype_1value_S(_a_2)
    if (_a_92 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVarSelection)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_VAR_SELECTION",_a_92)
    return 
   if (_a_1=="mioMinRel"):
    try:
     _a_93=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_93):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MIN_REL",_a_93)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMinRel)")
    except mosek_fusion_ValueConversionError as _a_94:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMinRel)")
   if (_a_1=="mioHeuristicLevel"):
    try:
     _a_95=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_a_95)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    except mosek_fusion_ValueConversionError as _a_96:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_a_1=="mioProbingLevel"):
    try:
     _a_97=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_97) and (_a_97 <= 3)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_a_97)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    except mosek_fusion_ValueConversionError as _a_98:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_a_1=="mioSymmetryLevel"):
    try:
     _a_99=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_99) and (_a_99 <= 4)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_SYMMETRY_LEVEL",_a_99)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
    except mosek_fusion_ValueConversionError as _a_100:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
   if (_a_1=="mioDualRayAnalysisLevel"):
    try:
     _a_101=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_101) and (_a_101 <= 2)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL",_a_101)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDualRayAnalysisLevel)")
    except mosek_fusion_ValueConversionError as _a_102:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDualRayAnalysisLevel)")
   if (_a_1=="mioConflictAnalysisLevel"):
    try:
     _a_103=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_103) and (_a_103 <= 2)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CONFLICT_ANALYSIS_LEVEL",_a_103)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConflictAnalysisLevel)")
    except mosek_fusion_ValueConversionError as _a_104:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConflictAnalysisLevel)")
   if (_a_1=="mioPresolveAggregatorUse"):
    _a_105=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_105 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPresolveAggregatorUse)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE",_a_105)
    return 
   if (_a_1=="mioNumericalEmphasisLevel"):
    try:
     _a_106=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_106) and (_a_106 <= 2)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL",_a_106)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
    except mosek_fusion_ValueConversionError as _a_107:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
   if (_a_1=="mioMemoryEmphasisLevel"):
    try:
     _a_108=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_108) and (_a_108 <= 1)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL",_a_108)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
    except mosek_fusion_ValueConversionError as _a_109:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
   if (_a_1=="mioCutSelectionLevel"):
    try:
     _a_110=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_110) and (_a_110 <= 1)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_a_110)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    except mosek_fusion_ValueConversionError as _a_111:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_a_1=="mioVbDetectionLevel"):
    try:
     _a_112=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_112) and (_a_112 <= 2)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_a_112)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    except mosek_fusion_ValueConversionError as _a_113:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   if (_a_1=="mioBranchDir"):
    _a_114=mosek.fusion.Parameters.__string_1to_1branchdir_1value_S(_a_2)
    if (_a_114 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",_a_114)
    return 
   if (_a_1=="mioRootOptimizer"):
    _a_115=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_a_2)
    if (_a_115 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",_a_115)
    return 
   if (_a_1=="mioNodeOptimizer"):
    _a_116=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_a_2)
    if (_a_116 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",_a_116)
    return 
   if (_a_1=="mioPerspectiveReformulate"):
    _a_117=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_117 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE",_a_117)
    return 
   if (_a_1=="mioPropagateObjectiveConstraint"):
    _a_118=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_118 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT",_a_118)
    return 
   if (_a_1=="mioSeed"):
    try:
     _a_119=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_119):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_a_119)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    except mosek_fusion_ValueConversionError as _a_120:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   if (_a_1=="mioConicOuterApproximation"):
    _a_121=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_121 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION",_a_121)
    return 
   if (_a_1=="mioQcqoReformulationMethod"):
    _a_122=mosek.fusion.Parameters.__string_1to_1miqcqoreformmethod_1value_S(_a_2)
    if (_a_122 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioQcqoReformulationMethod)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD",_a_122)
    return 
   if (_a_1=="mioDataPermutationMethod"):
    _a_123=mosek.fusion.Parameters.__string_1to_1miodatapermmethod_1value_S(_a_2)
    if (_a_123 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDataPermutationMethod)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_DATA_PERMUTATION_METHOD",_a_123)
    return 
   if (_a_1=="writeMpsFormat"):
    _a_124=mosek.fusion.Parameters.__string_1to_1mpsformat_1value_S(_a_2)
    if (_a_124 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeMpsFormat)")
    _a_0._task_1put_1param_SI("MSK_IPAR_WRITE_MPS_FORMAT",_a_124)
    return 
   if (_a_1=="writeLpLineWidth"):
    try:
     _a_125=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (40 <= _a_125):
      _a_0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_a_125)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    except mosek_fusion_ValueConversionError as _a_126:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_a_1=="writeLpFullObj"):
    _a_127=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_127 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
    _a_0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_FULL_OBJ",_a_127)
    return 
   if (_a_1=="writeJsonIndentation"):
    _a_128=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_128 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeJsonIndentation)")
    _a_0._task_1put_1param_SI("MSK_IPAR_WRITE_JSON_INDENTATION",_a_128)
    return 
   if (_a_1=="infeasReportAuto"):
    _a_129=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_129 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasReportAuto)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INFEAS_REPORT_AUTO",_a_129)
    return 
   if (_a_1=="licenseWait"):
    _a_130=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_130 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
    _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",_a_130)
    return 
   if (_a_1=="licenseSuppressExpireWrns"):
    _a_131=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_131 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
    _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",_a_131)
    return 
   if (_a_1=="licensePauseTime"):
    try:
     _a_132=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_132) and (_a_132 <= 1000000)):
      _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_a_132)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    except mosek_fusion_ValueConversionError as _a_133:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   if (_a_1=="licenseDebug"):
    _a_134=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_134 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
    _a_0._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",_a_134)
    return 
   if (_a_1=="log"):
    try:
     _a_135=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_135):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG",_a_135)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    except mosek_fusion_ValueConversionError as _a_136:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_a_1=="logExpand"):
    try:
     _a_137=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_137):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_a_137)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    except mosek_fusion_ValueConversionError as _a_138:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_a_1=="logFile"):
    try:
     _a_139=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_139):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_a_139)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    except mosek_fusion_ValueConversionError as _a_140:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_a_1=="logOrder"):
    try:
     _a_141=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_141):
      _a_0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_a_141)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    except mosek_fusion_ValueConversionError as _a_142:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   if (_a_1=="simScaling"):
    _a_143=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_a_2)
    if (_a_143 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",_a_143)
    return 
   if (_a_1=="simScalingMethod"):
    _a_144=mosek.fusion.Parameters.__string_1to_1scalingmethod_1value_S(_a_2)
    if (_a_144 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",_a_144)
    return 
   if (_a_1=="simPrimalPhaseoneMethod"):
    try:
     _a_145=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_145) and (_a_145 <= 10)):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_a_145)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _a_146:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_a_1=="simDualPhaseoneMethod"):
    try:
     _a_147=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((0 <= _a_147) and (_a_147 <= 10)):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_a_147)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _a_148:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_a_1=="simMaxNumSetbacks"):
    try:
     _a_149=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_149):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_a_149)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    except mosek_fusion_ValueConversionError as _a_150:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   if (_a_1=="simHotstart"):
    _a_151=mosek.fusion.Parameters.__string_1to_1simhotstart_1value_S(_a_2)
    if (_a_151 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",_a_151)
    return 
   if (_a_1=="simBasisFactorUse"):
    _a_152=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_152 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",_a_152)
    return 
   if (_a_1=="simPrecisionBoost"):
    _a_153=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_153 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionBoost)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_PRECISION_BOOST",_a_153)
    return 
   if (_a_1=="simDegen"):
    _a_154=mosek.fusion.Parameters.__string_1to_1simdegen_1value_S(_a_2)
    if (_a_154 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",_a_154)
    return 
   if (_a_1=="simReformulation"):
    _a_155=mosek.fusion.Parameters.__string_1to_1simreform_1value_S(_a_2)
    if (_a_155 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",_a_155)
    return 
   if (_a_1=="simExploitDupvec"):
    _a_156=mosek.fusion.Parameters.__string_1to_1simdupvec_1value_S(_a_2)
    if (_a_156 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",_a_156)
    return 
   if (_a_1=="simSaveLu"):
    _a_157=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_157 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",_a_157)
    return 
   if (_a_1=="simNonSingular"):
    _a_158=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_158 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",_a_158)
    return 
   if (_a_1=="simDualCrash"):
    try:
     _a_159=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (0 <= _a_159):
      _a_0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_a_159)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    except mosek_fusion_ValueConversionError as _a_160:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   if (_a_1=="ptfWriteTransform"):
    _a_161=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_161 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteTransform)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PTF_WRITE_TRANSFORM",_a_161)
    return 
   if (_a_1=="ptfWriteSolutions"):
    _a_162=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_162 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteSolutions)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PTF_WRITE_SOLUTIONS",_a_162)
    return 
   if (_a_1=="ptfWriteParameters"):
    _a_163=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_163 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteParameters)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PTF_WRITE_PARAMETERS",_a_163)
    return 
   if (_a_1=="ptfWriteSinglePsdTerms"):
    _a_164=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_164 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (ptfWriteSinglePsdTerms)")
    _a_0._task_1put_1param_SI("MSK_IPAR_PTF_WRITE_SINGLE_PSD_TERMS",_a_164)
    return 
   if (_a_1=="mioCutCmir"):
    _a_165=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_165 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",_a_165)
    return 
   if (_a_1=="mioCutClique"):
    _a_166=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_166 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CLIQUE",_a_166)
    return 
   if (_a_1=="mioCutImpliedBound"):
    _a_167=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_167 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_IMPLIED_BOUND",_a_167)
    return 
   if (_a_1=="mioCutKnapsackCover"):
    _a_168=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_168 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_KNAPSACK_COVER",_a_168)
    return 
   if (_a_1=="mioCutGmi"):
    _a_169=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_169 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_GMI",_a_169)
    return 
   if (_a_1=="mioCutLipro"):
    _a_170=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_170 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutLipro)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LIPRO",_a_170)
    return 
   if (_a_1=="mioConstructSol"):
    _a_171=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_171 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
    _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CONSTRUCT_SOL",_a_171)
    return 
   if (_a_1=="presolveLindepRelWorkTrh"):
    try:
     _a_172=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_a_172)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    except mosek_fusion_ValueConversionError as _a_173:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_a_1=="presolveLindepAbsWorkTrh"):
    try:
     _a_174=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if True:
      _a_0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_a_174)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    except mosek_fusion_ValueConversionError as _a_175:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   if (_a_1=="cacheLicense"):
    _a_176=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_176 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
    _a_0._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",_a_176)
    return 
   if (_a_1=="intpntRegularizationUse"):
    _a_177=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_177 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
    _a_0._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",_a_177)
    return 
   if (_a_1=="simSolveForm"):
    _a_178=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_a_2)
    if (_a_178 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",_a_178)
    return 
   if (_a_1=="simSwitchOptimizer"):
    _a_179=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_179 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
    _a_0._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",_a_179)
    return 
   if (_a_1=="autoSortABeforeOpt"):
    _a_180=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_a_2)
    if (_a_180 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoSortABeforeOpt)")
    _a_0._task_1put_1param_SI("MSK_IPAR_AUTO_SORT_A_BEFORE_OPT",_a_180)
    return 
   if (_a_1=="mioRinsMaxNodes"):
    try:
     _a_181=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_181):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_a_181)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    except mosek_fusion_ValueConversionError as _a_182:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_a_1=="mioRensMaxNodes"):
    try:
     _a_183=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_183):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_RENS_MAX_NODES",_a_183)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRensMaxNodes)")
    except mosek_fusion_ValueConversionError as _a_184:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRensMaxNodes)")
   if (_a_1=="mioCrossoverMaxNodes"):
    try:
     _a_185=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_185):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_CROSSOVER_MAX_NODES",_a_185)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCrossoverMaxNodes)")
    except mosek_fusion_ValueConversionError as _a_186:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCrossoverMaxNodes)")
   if (_a_1=="mioOptFaceMaxNodes"):
    try:
     _a_187=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if ((- 1) <= _a_187):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_OPT_FACE_MAX_NODES",_a_187)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioOptFaceMaxNodes)")
    except mosek_fusion_ValueConversionError as _a_188:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioOptFaceMaxNodes)")
   if (_a_1=="mioFeaspumpLevel"):
    try:
     _a_189=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_189) and (_a_189 <= 2)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_a_189)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    except mosek_fusion_ValueConversionError as _a_190:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_a_1=="mioIndependentBlockLevel"):
    try:
     _a_191=mosek.fusion.Utils.Tools._toInt_S(_a_2)
     if (((- 1) <= _a_191) and (_a_191 <= 3)):
      _a_0._task_1put_1param_SI("MSK_IPAR_MIO_INDEPENDENT_BLOCK_LEVEL",_a_191)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioIndependentBlockLevel)")
    except mosek_fusion_ValueConversionError as _a_192:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioIndependentBlockLevel)")
   if (_a_1=="remoteUseCompression"):
    _a_193=mosek.fusion.Parameters.__string_1to_1compresstype_1value_S(_a_2)
    if (_a_193 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteUseCompression)")
    _a_0._task_1put_1param_SI("MSK_IPAR_REMOTE_USE_COMPRESSION",_a_193)
    return 
   if (_a_1=="semidefiniteTolApprox"):
    try:
     _a_194=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-15 <= _a_194):
      _a_0._task_1put_1param_SD("MSK_DPAR_SEMIDEFINITE_TOL_APPROX",_a_194)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (semidefiniteTolApprox)")
    except mosek_fusion_ValueConversionError as _a_195:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (semidefiniteTolApprox)")
   if (_a_1=="optimizerMaxTime"):
    try:
     _a_196=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_a_196)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
    except mosek_fusion_ValueConversionError as _a_197:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_a_1=="optimizerMaxTicks"):
    try:
     _a_198=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TICKS",_a_198)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTicks)")
    except mosek_fusion_ValueConversionError as _a_199:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTicks)")
   if (_a_1=="lowerObjCut"):
    try:
     _a_200=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_a_200)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
    except mosek_fusion_ValueConversionError as _a_201:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_a_1=="upperObjCut"):
    try:
     _a_202=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_a_202)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
    except mosek_fusion_ValueConversionError as _a_203:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_a_1=="upperObjCutFiniteTrh"):
    try:
     _a_204=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_a_204)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _a_205:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_a_1=="lowerObjCutFiniteTrh"):
    try:
     _a_206=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_a_206)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _a_207:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_a_1=="intpntTolRelGap"):
    try:
     _a_208=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-14 <= _a_208):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_a_208)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
    except mosek_fusion_ValueConversionError as _a_209:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_a_1=="intpntTolStepSize"):
    try:
     _a_210=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_210) and (_a_210 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_a_210)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
    except mosek_fusion_ValueConversionError as _a_211:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_a_1=="simLuTolRelPiv"):
    try:
     _a_212=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((1.000000e-06 <= _a_212) and (_a_212 <= 9.999990e-01)):
      _a_0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_a_212)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
    except mosek_fusion_ValueConversionError as _a_213:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_a_1=="intpntTolRelStep"):
    try:
     _a_214=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((1.000000e-04 <= _a_214) and (_a_214 <= 9.999990e-01)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_a_214)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
    except mosek_fusion_ValueConversionError as _a_215:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_a_1=="intpntTolPath"):
    try:
     _a_216=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_216) and (_a_216 <= 9.999000e-01)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_a_216)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
    except mosek_fusion_ValueConversionError as _a_217:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_a_1=="intpntTolPfeas"):
    try:
     _a_218=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_218) and (_a_218 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_a_218)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
    except mosek_fusion_ValueConversionError as _a_219:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_a_1=="intpntTolDfeas"):
    try:
     _a_220=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_220) and (_a_220 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_a_220)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
    except mosek_fusion_ValueConversionError as _a_221:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_a_1=="intpntTolMuRed"):
    try:
     _a_222=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_222) and (_a_222 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_a_222)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
    except mosek_fusion_ValueConversionError as _a_223:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_a_1=="intpntTolInfeas"):
    try:
     _a_224=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_224) and (_a_224 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_a_224)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
    except mosek_fusion_ValueConversionError as _a_225:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_a_1=="intpntCoTolRelGap"):
    try:
     _a_226=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_226) and (_a_226 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_a_226)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
    except mosek_fusion_ValueConversionError as _a_227:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_a_1=="intpntCoTolPfeas"):
    try:
     _a_228=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_228) and (_a_228 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_a_228)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
    except mosek_fusion_ValueConversionError as _a_229:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_a_1=="intpntCoTolDfeas"):
    try:
     _a_230=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_230) and (_a_230 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_a_230)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
    except mosek_fusion_ValueConversionError as _a_231:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_a_1=="intpntCoTolMuRed"):
    try:
     _a_232=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_232) and (_a_232 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_a_232)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
    except mosek_fusion_ValueConversionError as _a_233:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_a_1=="intpntCoTolNearRel"):
    try:
     _a_234=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e+00 <= _a_234):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_a_234)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
    except mosek_fusion_ValueConversionError as _a_235:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_a_1=="intpntCoTolInfeas"):
    try:
     _a_236=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_236) and (_a_236 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_a_236)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
    except mosek_fusion_ValueConversionError as _a_237:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_a_1=="intpntTolPsafe"):
    try:
     _a_238=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-04 <= _a_238):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_a_238)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
    except mosek_fusion_ValueConversionError as _a_239:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_a_1=="intpntTolDsafe"):
    try:
     _a_240=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-04 <= _a_240):
      _a_0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_a_240)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
    except mosek_fusion_ValueConversionError as _a_241:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_a_1=="mioMaxTime"):
    try:
     _a_242=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if True:
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_a_242)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
    except mosek_fusion_ValueConversionError as _a_243:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_a_1=="mioRelGapConst"):
    try:
     _a_244=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-15 <= _a_244):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_a_244)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
    except mosek_fusion_ValueConversionError as _a_245:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_a_1=="mioTolRelGap"):
    try:
     _a_246=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_246):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_a_246)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
    except mosek_fusion_ValueConversionError as _a_247:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_a_1=="mioTolAbsGap"):
    try:
     _a_248=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_248):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_a_248)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
    except mosek_fusion_ValueConversionError as _a_249:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_a_1=="mioTolAbsRelaxInt"):
    try:
     _a_250=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-09 <= _a_250):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_a_250)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
    except mosek_fusion_ValueConversionError as _a_251:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_a_1=="mioDjcMaxBigm"):
    try:
     _a_252=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_252):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_DJC_MAX_BIGM",_a_252)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
    except mosek_fusion_ValueConversionError as _a_253:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
   if (_a_1=="mioCliqueTableSizeFactor"):
    try:
     _a_254=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((- 1.000000e+00) <= _a_254):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_CLIQUE_TABLE_SIZE_FACTOR",_a_254)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCliqueTableSizeFactor)")
    except mosek_fusion_ValueConversionError as _a_255:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCliqueTableSizeFactor)")
   if (_a_1=="simPrecisionScalingNormal"):
    try:
     _a_256=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e+00 <= _a_256):
      _a_0._task_1put_1param_SD("MSK_DPAR_SIM_PRECISION_SCALING_NORMAL",_a_256)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingNormal)")
    except mosek_fusion_ValueConversionError as _a_257:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingNormal)")
   if (_a_1=="simPrecisionScalingExtended"):
    try:
     _a_258=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e+00 <= _a_258):
      _a_0._task_1put_1param_SD("MSK_DPAR_SIM_PRECISION_SCALING_EXTENDED",_a_258)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingExtended)")
    except mosek_fusion_ValueConversionError as _a_259:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrecisionScalingExtended)")
   if (_a_1=="basisTolX"):
    try:
     _a_260=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-09 <= _a_260):
      _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_a_260)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
    except mosek_fusion_ValueConversionError as _a_261:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_a_1=="basisTolS"):
    try:
     _a_262=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-09 <= _a_262):
      _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_a_262)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
    except mosek_fusion_ValueConversionError as _a_263:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_a_1=="basisRelTolS"):
    try:
     _a_264=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_264):
      _a_0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_a_264)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
    except mosek_fusion_ValueConversionError as _a_265:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_a_1=="presolveTolX"):
    try:
     _a_266=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_266):
      _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_a_266)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
    except mosek_fusion_ValueConversionError as _a_267:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_a_1=="presolveTolPrimalInfeasPerturbation"):
    try:
     _a_268=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_268):
      _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION",_a_268)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
    except mosek_fusion_ValueConversionError as _a_269:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
   if (_a_1=="presolveTolS"):
    try:
     _a_270=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_270):
      _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_a_270)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
    except mosek_fusion_ValueConversionError as _a_271:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_a_1=="presolveTolAbsLindep"):
    try:
     _a_272=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_272):
      _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_a_272)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
    except mosek_fusion_ValueConversionError as _a_273:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_a_1=="presolveTolRelLindep"):
    try:
     _a_274=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_274):
      _a_0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_a_274)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
    except mosek_fusion_ValueConversionError as _a_275:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_a_1=="foldingTolEq"):
    try:
     _a_276=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (0.000000e+00 <= _a_276):
      _a_0._task_1put_1param_SD("MSK_DPAR_FOLDING_TOL_EQ",_a_276)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingTolEq)")
    except mosek_fusion_ValueConversionError as _a_277:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (foldingTolEq)")
   if (_a_1=="simplexAbsTolPiv"):
    try:
     _a_278=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if (1.000000e-12 <= _a_278):
      _a_0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_a_278)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
    except mosek_fusion_ValueConversionError as _a_279:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_a_1=="mioTolFeas"):
    try:
     _a_280=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((1.000000e-09 <= _a_280) and (_a_280 <= 1.000000e-03)):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_a_280)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
    except mosek_fusion_ValueConversionError as _a_281:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_a_1=="mioTolRelDualBoundImprovement"):
    try:
     _a_282=mosek.fusion.Utils.Tools._toDouble_S(_a_2)
     if ((0.000000e+00 <= _a_282) and (_a_282 <= 1.000000e+00)):
      _a_0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_a_282)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    except mosek_fusion_ValueConversionError as _a_283:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   if (_a_1=="dataFileName"):
    _a_0._task_1put_1param_SS("MSK_SPAR_DATA_FILE_NAME",_a_2)
    return 
   if (_a_1=="remoteOptserverHost"):
    _a_0._task_1put_1param_SS("MSK_SPAR_REMOTE_OPTSERVER_HOST",_a_2)
    return 
   if (_a_1=="remoteTlsCertPath"):
    _a_0._task_1put_1param_SS("MSK_SPAR_REMOTE_TLS_CERT_PATH",_a_2)
    return 
   if (_a_1=="remoteTlsCert"):
    _a_0._task_1put_1param_SS("MSK_SPAR_REMOTE_TLS_CERT",_a_2)
    return 
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def __string_1to_1variabletype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1variabletype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1variabletype_1value_S(_a_0):
   if (_a_0=="typeCont"):
    return numpy.int32(0)
   if (_a_0=="typeInt"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1value_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1value_1value_S(_a_0)
  @staticmethod
  def __string_1to_1value_1value_S(_a_0):
   if (_a_0=="maxStrLen"):
    return numpy.int32(1024)
   if (_a_0=="licenseBufferLength"):
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1streamtype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1streamtype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1streamtype_1value_S(_a_0):
   if (_a_0=="log"):
    return numpy.int32(0)
   if (_a_0=="msg"):
    return numpy.int32(1)
   if (_a_0=="err"):
    return numpy.int32(2)
   if (_a_0=="wrn"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1startpointtype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1startpointtype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1startpointtype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="guess"):
    return numpy.int32(1)
   if (_a_0=="constant"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1stakey_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1stakey_1value_S(_a_0)
  @staticmethod
  def __string_1to_1stakey_1value_S(_a_0):
   if (_a_0=="unk"):
    return numpy.int32(0)
   if (_a_0=="bas"):
    return numpy.int32(1)
   if (_a_0=="supbas"):
    return numpy.int32(2)
   if (_a_0=="low"):
    return numpy.int32(3)
   if (_a_0=="upr"):
    return numpy.int32(4)
   if (_a_0=="fix"):
    return numpy.int32(5)
   if (_a_0=="inf"):
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sparam_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1sparam_1value_S(_a_0)
  @staticmethod
  def __string_1to_1sparam_1value_S(_a_0):
   if (_a_0=="dataFileName"):
    return numpy.int32(1)
   if (_a_0=="paramReadFileName"):
    return numpy.int32(7)
   if (_a_0=="paramWriteFileName"):
    return numpy.int32(8)
   if (_a_0=="paramCommentSign"):
    return numpy.int32(6)
   if (_a_0=="debugFileName"):
    return numpy.int32(2)
   if (_a_0=="basSolFileName"):
    return numpy.int32(0)
   if (_a_0=="itrSolFileName"):
    return numpy.int32(4)
   if (_a_0=="intSolFileName"):
    return numpy.int32(3)
   if (_a_0=="solFilterXcLow"):
    return numpy.int32(18)
   if (_a_0=="solFilterXcUpr"):
    return numpy.int32(19)
   if (_a_0=="solFilterXxLow"):
    return numpy.int32(20)
   if (_a_0=="solFilterXxUpr"):
    return numpy.int32(21)
   if (_a_0=="readMpsObjName"):
    return numpy.int32(10)
   if (_a_0=="readMpsRanName"):
    return numpy.int32(11)
   if (_a_0=="readMpsRhsName"):
    return numpy.int32(12)
   if (_a_0=="readMpsBouName"):
    return numpy.int32(9)
   if (_a_0=="statName"):
    return numpy.int32(23)
   if (_a_0=="statKey"):
    return numpy.int32(22)
   if (_a_0=="sensitivityResFileName"):
    return numpy.int32(17)
   if (_a_0=="sensitivityFileName"):
    return numpy.int32(16)
   if (_a_0=="mioDebugString"):
    return numpy.int32(5)
   if (_a_0=="remoteOptserverHost"):
    return numpy.int32(13)
   if (_a_0=="remoteTlsCertPath"):
    return numpy.int32(15)
   if (_a_0=="remoteTlsCert"):
    return numpy.int32(14)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solveform_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1solveform_1value_S(_a_0)
  @staticmethod
  def __string_1to_1solveform_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="primal"):
    return numpy.int32(1)
   if (_a_0=="dual"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1soltype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1soltype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1soltype_1value_S(_a_0):
   if (_a_0=="bas"):
    return numpy.int32(1)
   if (_a_0=="itr"):
    return numpy.int32(0)
   if (_a_0=="itg"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solsta_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1solsta_1value_S(_a_0)
  @staticmethod
  def __string_1to_1solsta_1value_S(_a_0):
   if (_a_0=="unknown"):
    return numpy.int32(0)
   if (_a_0=="optimal"):
    return numpy.int32(1)
   if (_a_0=="primFeas"):
    return numpy.int32(2)
   if (_a_0=="dualFeas"):
    return numpy.int32(3)
   if (_a_0=="primAndDualFeas"):
    return numpy.int32(4)
   if (_a_0=="primInfeasCer"):
    return numpy.int32(5)
   if (_a_0=="dualInfeasCer"):
    return numpy.int32(6)
   if (_a_0=="primIllposedCer"):
    return numpy.int32(7)
   if (_a_0=="dualIllposedCer"):
    return numpy.int32(8)
   if (_a_0=="integerOptimal"):
    return numpy.int32(9)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solitem_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1solitem_1value_S(_a_0)
  @staticmethod
  def __string_1to_1solitem_1value_S(_a_0):
   if (_a_0=="xc"):
    return numpy.int32(0)
   if (_a_0=="xx"):
    return numpy.int32(1)
   if (_a_0=="y"):
    return numpy.int32(2)
   if (_a_0=="slc"):
    return numpy.int32(3)
   if (_a_0=="suc"):
    return numpy.int32(4)
   if (_a_0=="slx"):
    return numpy.int32(5)
   if (_a_0=="sux"):
    return numpy.int32(6)
   if (_a_0=="snx"):
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simseltype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1simseltype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1simseltype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="full"):
    return numpy.int32(1)
   if (_a_0=="ase"):
    return numpy.int32(2)
   if (_a_0=="devex"):
    return numpy.int32(3)
   if (_a_0=="se"):
    return numpy.int32(4)
   if (_a_0=="partial"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sensitivitytype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1sensitivitytype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1sensitivitytype_1value_S(_a_0):
   if (_a_0=="basis"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingmethod_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1scalingmethod_1value_S(_a_0)
  @staticmethod
  def __string_1to_1scalingmethod_1value_S(_a_0):
   if (_a_0=="pow2"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingtype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1scalingtype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1scalingtype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="none"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescodetype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1rescodetype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1rescodetype_1value_S(_a_0):
   if (_a_0=="ok"):
    return numpy.int32(0)
   if (_a_0=="wrn"):
    return numpy.int32(1)
   if (_a_0=="trm"):
    return numpy.int32(2)
   if (_a_0=="err"):
    return numpy.int32(3)
   if (_a_0=="unk"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescode_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1rescode_1value_S(_a_0)
  @staticmethod
  def __string_1to_1rescode_1value_S(_a_0):
   if (_a_0=="ok"):
    return numpy.int32(0)
   if (_a_0=="wrnOpenParamFile"):
    return numpy.int32(50)
   if (_a_0=="wrnLargeBound"):
    return numpy.int32(51)
   if (_a_0=="wrnLargeLoBound"):
    return numpy.int32(52)
   if (_a_0=="wrnLargeUpBound"):
    return numpy.int32(53)
   if (_a_0=="wrnLargeConFx"):
    return numpy.int32(54)
   if (_a_0=="wrnLargeCj"):
    return numpy.int32(57)
   if (_a_0=="wrnLargeAij"):
    return numpy.int32(62)
   if (_a_0=="wrnZeroAij"):
    return numpy.int32(63)
   if (_a_0=="wrnNameMaxLen"):
    return numpy.int32(65)
   if (_a_0=="wrnSparMaxLen"):
    return numpy.int32(66)
   if (_a_0=="wrnMpsSplitRhsVector"):
    return numpy.int32(70)
   if (_a_0=="wrnMpsSplitRanVector"):
    return numpy.int32(71)
   if (_a_0=="wrnMpsSplitBouVector"):
    return numpy.int32(72)
   if (_a_0=="wrnLpOldQuadFormat"):
    return numpy.int32(80)
   if (_a_0=="wrnLpDropVariable"):
    return numpy.int32(85)
   if (_a_0=="wrnNzInUprTri"):
    return numpy.int32(200)
   if (_a_0=="wrnDroppedNzQobj"):
    return numpy.int32(201)
   if (_a_0=="wrnIgnoreInteger"):
    return numpy.int32(250)
   if (_a_0=="wrnNoGlobalOptimizer"):
    return numpy.int32(251)
   if (_a_0=="wrnMioInfeasibleFinal"):
    return numpy.int32(270)
   if (_a_0=="wrnSolFilter"):
    return numpy.int32(300)
   if (_a_0=="wrnUndefSolFileName"):
    return numpy.int32(350)
   if (_a_0=="wrnSolFileIgnoredCon"):
    return numpy.int32(351)
   if (_a_0=="wrnSolFileIgnoredVar"):
    return numpy.int32(352)
   if (_a_0=="wrnTooFewBasisVars"):
    return numpy.int32(400)
   if (_a_0=="wrnTooManyBasisVars"):
    return numpy.int32(405)
   if (_a_0=="wrnLicenseExpire"):
    return numpy.int32(500)
   if (_a_0=="wrnLicenseServer"):
    return numpy.int32(501)
   if (_a_0=="wrnEmptyName"):
    return numpy.int32(502)
   if (_a_0=="wrnUsingGenericNames"):
    return numpy.int32(503)
   if (_a_0=="wrnInvalidMpsName"):
    return numpy.int32(504)
   if (_a_0=="wrnInvalidMpsObjName"):
    return numpy.int32(505)
   if (_a_0=="wrnLicenseFeatureExpire"):
    return numpy.int32(509)
   if (_a_0=="wrnParamNameDou"):
    return numpy.int32(510)
   if (_a_0=="wrnParamNameInt"):
    return numpy.int32(511)
   if (_a_0=="wrnParamNameStr"):
    return numpy.int32(512)
   if (_a_0=="wrnParamStrValue"):
    return numpy.int32(515)
   if (_a_0=="wrnParamIgnoredCmio"):
    return numpy.int32(516)
   if (_a_0=="wrnZerosInSparseRow"):
    return numpy.int32(705)
   if (_a_0=="wrnZerosInSparseCol"):
    return numpy.int32(710)
   if (_a_0=="wrnIncompleteLinearDependencyCheck"):
    return numpy.int32(800)
   if (_a_0=="wrnEliminatorSpace"):
    return numpy.int32(801)
   if (_a_0=="wrnPresolveOutofspace"):
    return numpy.int32(802)
   if (_a_0=="wrnPresolvePrimalPerturbations"):
    return numpy.int32(803)
   if (_a_0=="wrnWriteChangedNames"):
    return numpy.int32(830)
   if (_a_0=="wrnWriteDiscardedCfix"):
    return numpy.int32(831)
   if (_a_0=="wrnDuplicateConstraintNames"):
    return numpy.int32(850)
   if (_a_0=="wrnDuplicateVariableNames"):
    return numpy.int32(851)
   if (_a_0=="wrnDuplicateBarvariableNames"):
    return numpy.int32(852)
   if (_a_0=="wrnDuplicateConeNames"):
    return numpy.int32(853)
   if (_a_0=="wrnAnaLargeBounds"):
    return numpy.int32(900)
   if (_a_0=="wrnAnaCZero"):
    return numpy.int32(901)
   if (_a_0=="wrnAnaEmptyCols"):
    return numpy.int32(902)
   if (_a_0=="wrnAnaCloseBounds"):
    return numpy.int32(903)
   if (_a_0=="wrnAnaAlmostIntBounds"):
    return numpy.int32(904)
   if (_a_0=="wrnNoInfeasibilityReportWhenMatrixVariables"):
    return numpy.int32(930)
   if (_a_0=="wrnGetdualIgnoresIntegrality"):
    return numpy.int32(940)
   if (_a_0=="wrnNoDualizer"):
    return numpy.int32(950)
   if (_a_0=="wrnSymMatLarge"):
    return numpy.int32(960)
   if (_a_0=="wrnModifiedDoubleParameter"):
    return numpy.int32(970)
   if (_a_0=="wrnLargeFij"):
    return numpy.int32(980)
   if (_a_0=="wrnPtfUnknownSection"):
    return numpy.int32(981)
   if (_a_0=="errLicense"):
    return numpy.int32(1000)
   if (_a_0=="errLicenseExpired"):
    return numpy.int32(1001)
   if (_a_0=="errLicenseVersion"):
    return numpy.int32(1002)
   if (_a_0=="errLicenseOldServerVersion"):
    return numpy.int32(1003)
   if (_a_0=="errSizeLicense"):
    return numpy.int32(1005)
   if (_a_0=="errProbLicense"):
    return numpy.int32(1006)
   if (_a_0=="errFileLicense"):
    return numpy.int32(1007)
   if (_a_0=="errMissingLicenseFile"):
    return numpy.int32(1008)
   if (_a_0=="errSizeLicenseCon"):
    return numpy.int32(1010)
   if (_a_0=="errSizeLicenseVar"):
    return numpy.int32(1011)
   if (_a_0=="errSizeLicenseIntvar"):
    return numpy.int32(1012)
   if (_a_0=="errOptimizerLicense"):
    return numpy.int32(1013)
   if (_a_0=="errFlexlm"):
    return numpy.int32(1014)
   if (_a_0=="errLicenseServer"):
    return numpy.int32(1015)
   if (_a_0=="errLicenseMax"):
    return numpy.int32(1016)
   if (_a_0=="errLicenseMoseklmDaemon"):
    return numpy.int32(1017)
   if (_a_0=="errLicenseFeature"):
    return numpy.int32(1018)
   if (_a_0=="errPlatformNotLicensed"):
    return numpy.int32(1019)
   if (_a_0=="errLicenseCannotAllocate"):
    return numpy.int32(1020)
   if (_a_0=="errLicenseCannotConnect"):
    return numpy.int32(1021)
   if (_a_0=="errLicenseInvalidHostid"):
    return numpy.int32(1025)
   if (_a_0=="errLicenseServerVersion"):
    return numpy.int32(1026)
   if (_a_0=="errLicenseNoServerSupport"):
    return numpy.int32(1027)
   if (_a_0=="errLicenseNoServerLine"):
    return numpy.int32(1028)
   if (_a_0=="errOlderDll"):
    return numpy.int32(1035)
   if (_a_0=="errNewerDll"):
    return numpy.int32(1036)
   if (_a_0=="errLinkFileDll"):
    return numpy.int32(1040)
   if (_a_0=="errThreadMutexInit"):
    return numpy.int32(1045)
   if (_a_0=="errThreadMutexLock"):
    return numpy.int32(1046)
   if (_a_0=="errThreadMutexUnlock"):
    return numpy.int32(1047)
   if (_a_0=="errThreadCreate"):
    return numpy.int32(1048)
   if (_a_0=="errThreadCondInit"):
    return numpy.int32(1049)
   if (_a_0=="errUnknown"):
    return numpy.int32(1050)
   if (_a_0=="errSpace"):
    return numpy.int32(1051)
   if (_a_0=="errFileOpen"):
    return numpy.int32(1052)
   if (_a_0=="errFileRead"):
    return numpy.int32(1053)
   if (_a_0=="errFileWrite"):
    return numpy.int32(1054)
   if (_a_0=="errDataFileExt"):
    return numpy.int32(1055)
   if (_a_0=="errInvalidFileName"):
    return numpy.int32(1056)
   if (_a_0=="errInvalidSolFileName"):
    return numpy.int32(1057)
   if (_a_0=="errEndOfFile"):
    return numpy.int32(1059)
   if (_a_0=="errNullEnv"):
    return numpy.int32(1060)
   if (_a_0=="errNullTask"):
    return numpy.int32(1061)
   if (_a_0=="errInvalidStream"):
    return numpy.int32(1062)
   if (_a_0=="errNoInitEnv"):
    return numpy.int32(1063)
   if (_a_0=="errInvalidTask"):
    return numpy.int32(1064)
   if (_a_0=="errNullPointer"):
    return numpy.int32(1065)
   if (_a_0=="errLivingTasks"):
    return numpy.int32(1066)
   if (_a_0=="errReadGzip"):
    return numpy.int32(1067)
   if (_a_0=="errReadZstd"):
    return numpy.int32(1068)
   if (_a_0=="errReadAsync"):
    return numpy.int32(1069)
   if (_a_0=="errBlankName"):
    return numpy.int32(1070)
   if (_a_0=="errDupName"):
    return numpy.int32(1071)
   if (_a_0=="errFormatString"):
    return numpy.int32(1072)
   if (_a_0=="errSparsitySpecification"):
    return numpy.int32(1073)
   if (_a_0=="errMismatchingDimension"):
    return numpy.int32(1074)
   if (_a_0=="errInvalidObjName"):
    return numpy.int32(1075)
   if (_a_0=="errInvalidConName"):
    return numpy.int32(1076)
   if (_a_0=="errInvalidVarName"):
    return numpy.int32(1077)
   if (_a_0=="errInvalidConeName"):
    return numpy.int32(1078)
   if (_a_0=="errInvalidBarvarName"):
    return numpy.int32(1079)
   if (_a_0=="errSpaceLeaking"):
    return numpy.int32(1080)
   if (_a_0=="errSpaceNoInfo"):
    return numpy.int32(1081)
   if (_a_0=="errDimensionSpecification"):
    return numpy.int32(1082)
   if (_a_0=="errAxisNameSpecification"):
    return numpy.int32(1083)
   if (_a_0=="errReadPrematureEof"):
    return numpy.int32(1089)
   if (_a_0=="errReadFormat"):
    return numpy.int32(1090)
   if (_a_0=="errWriteLpInvalidVarNames"):
    return numpy.int32(1091)
   if (_a_0=="errWriteLpDuplicateVarNames"):
    return numpy.int32(1092)
   if (_a_0=="errWriteLpInvalidConNames"):
    return numpy.int32(1093)
   if (_a_0=="errWriteLpDuplicateConNames"):
    return numpy.int32(1094)
   if (_a_0=="errMpsFile"):
    return numpy.int32(1100)
   if (_a_0=="errMpsInvField"):
    return numpy.int32(1101)
   if (_a_0=="errMpsInvMarker"):
    return numpy.int32(1102)
   if (_a_0=="errMpsNullConName"):
    return numpy.int32(1103)
   if (_a_0=="errMpsNullVarName"):
    return numpy.int32(1104)
   if (_a_0=="errMpsUndefConName"):
    return numpy.int32(1105)
   if (_a_0=="errMpsUndefVarName"):
    return numpy.int32(1106)
   if (_a_0=="errMpsInvalidConKey"):
    return numpy.int32(1107)
   if (_a_0=="errMpsInvalidBoundKey"):
    return numpy.int32(1108)
   if (_a_0=="errMpsInvalidSecName"):
    return numpy.int32(1109)
   if (_a_0=="errMpsNoObjective"):
    return numpy.int32(1110)
   if (_a_0=="errMpsSplittedVar"):
    return numpy.int32(1111)
   if (_a_0=="errMpsMulConName"):
    return numpy.int32(1112)
   if (_a_0=="errMpsMulQsec"):
    return numpy.int32(1113)
   if (_a_0=="errMpsMulQobj"):
    return numpy.int32(1114)
   if (_a_0=="errMpsInvSecOrder"):
    return numpy.int32(1115)
   if (_a_0=="errMpsMulCsec"):
    return numpy.int32(1116)
   if (_a_0=="errMpsConeType"):
    return numpy.int32(1117)
   if (_a_0=="errMpsConeOverlap"):
    return numpy.int32(1118)
   if (_a_0=="errMpsConeRepeat"):
    return numpy.int32(1119)
   if (_a_0=="errMpsNonSymmetricQ"):
    return numpy.int32(1120)
   if (_a_0=="errMpsDuplicateQElement"):
    return numpy.int32(1121)
   if (_a_0=="errMpsInvalidObjsense"):
    return numpy.int32(1122)
   if (_a_0=="errMpsTabInField2"):
    return numpy.int32(1125)
   if (_a_0=="errMpsTabInField3"):
    return numpy.int32(1126)
   if (_a_0=="errMpsTabInField5"):
    return numpy.int32(1127)
   if (_a_0=="errMpsInvalidObjName"):
    return numpy.int32(1128)
   if (_a_0=="errMpsInvalidKey"):
    return numpy.int32(1129)
   if (_a_0=="errMpsInvalidIndicatorConstraint"):
    return numpy.int32(1130)
   if (_a_0=="errMpsInvalidIndicatorVariable"):
    return numpy.int32(1131)
   if (_a_0=="errMpsInvalidIndicatorValue"):
    return numpy.int32(1132)
   if (_a_0=="errMpsInvalidIndicatorQuadraticConstraint"):
    return numpy.int32(1133)
   if (_a_0=="errOpfSyntax"):
    return numpy.int32(1134)
   if (_a_0=="errOpfPrematureEof"):
    return numpy.int32(1136)
   if (_a_0=="errOpfMismatchedTag"):
    return numpy.int32(1137)
   if (_a_0=="errOpfDuplicateBound"):
    return numpy.int32(1138)
   if (_a_0=="errOpfDuplicateConstraintName"):
    return numpy.int32(1139)
   if (_a_0=="errOpfInvalidConeType"):
    return numpy.int32(1140)
   if (_a_0=="errOpfIncorrectTagParam"):
    return numpy.int32(1141)
   if (_a_0=="errOpfInvalidTag"):
    return numpy.int32(1142)
   if (_a_0=="errOpfDuplicateConeEntry"):
    return numpy.int32(1143)
   if (_a_0=="errOpfTooLarge"):
    return numpy.int32(1144)
   if (_a_0=="errOpfDualIntegerSolution"):
    return numpy.int32(1146)
   if (_a_0=="errLpEmpty"):
    return numpy.int32(1151)
   if (_a_0=="errWriteMpsInvalidName"):
    return numpy.int32(1153)
   if (_a_0=="errLpInvalidVarName"):
    return numpy.int32(1154)
   if (_a_0=="errWriteOpfInvalidVarName"):
    return numpy.int32(1156)
   if (_a_0=="errLpFileFormat"):
    return numpy.int32(1157)
   if (_a_0=="errLpExpectedNumber"):
    return numpy.int32(1158)
   if (_a_0=="errReadLpMissingEndTag"):
    return numpy.int32(1159)
   if (_a_0=="errLpIndicatorVar"):
    return numpy.int32(1160)
   if (_a_0=="errLpExpectedObjective"):
    return numpy.int32(1161)
   if (_a_0=="errLpExpectedConstraintRelation"):
    return numpy.int32(1162)
   if (_a_0=="errLpAmbiguousConstraintBound"):
    return numpy.int32(1163)
   if (_a_0=="errLpDuplicateSection"):
    return numpy.int32(1164)
   if (_a_0=="errReadLpDelayedRowsNotSupported"):
    return numpy.int32(1165)
   if (_a_0=="errWritingFile"):
    return numpy.int32(1166)
   if (_a_0=="errWriteAsync"):
    return numpy.int32(1167)
   if (_a_0=="errInvalidNameInSolFile"):
    return numpy.int32(1170)
   if (_a_0=="errJsonSyntax"):
    return numpy.int32(1175)
   if (_a_0=="errJsonString"):
    return numpy.int32(1176)
   if (_a_0=="errJsonNumberOverflow"):
    return numpy.int32(1177)
   if (_a_0=="errJsonFormat"):
    return numpy.int32(1178)
   if (_a_0=="errJsonData"):
    return numpy.int32(1179)
   if (_a_0=="errJsonMissingData"):
    return numpy.int32(1180)
   if (_a_0=="errPtfIncompatibility"):
    return numpy.int32(1181)
   if (_a_0=="errPtfUndefinedItem"):
    return numpy.int32(1182)
   if (_a_0=="errPtfInconsistency"):
    return numpy.int32(1183)
   if (_a_0=="errPtfFormat"):
    return numpy.int32(1184)
   if (_a_0=="errArgumentLenneq"):
    return numpy.int32(1197)
   if (_a_0=="errArgumentType"):
    return numpy.int32(1198)
   if (_a_0=="errNumArguments"):
    return numpy.int32(1199)
   if (_a_0=="errInArgument"):
    return numpy.int32(1200)
   if (_a_0=="errArgumentDimension"):
    return numpy.int32(1201)
   if (_a_0=="errShapeIsTooLarge"):
    return numpy.int32(1202)
   if (_a_0=="errIndexIsTooSmall"):
    return numpy.int32(1203)
   if (_a_0=="errIndexIsTooLarge"):
    return numpy.int32(1204)
   if (_a_0=="errIndexIsNotUnique"):
    return numpy.int32(1205)
   if (_a_0=="errParamName"):
    return numpy.int32(1206)
   if (_a_0=="errParamNameDou"):
    return numpy.int32(1207)
   if (_a_0=="errParamNameInt"):
    return numpy.int32(1208)
   if (_a_0=="errParamNameStr"):
    return numpy.int32(1209)
   if (_a_0=="errParamIndex"):
    return numpy.int32(1210)
   if (_a_0=="errParamIsTooLarge"):
    return numpy.int32(1215)
   if (_a_0=="errParamIsTooSmall"):
    return numpy.int32(1216)
   if (_a_0=="errParamValueStr"):
    return numpy.int32(1217)
   if (_a_0=="errParamType"):
    return numpy.int32(1218)
   if (_a_0=="errInfDouIndex"):
    return numpy.int32(1219)
   if (_a_0=="errInfIntIndex"):
    return numpy.int32(1220)
   if (_a_0=="errIndexArrIsTooSmall"):
    return numpy.int32(1221)
   if (_a_0=="errIndexArrIsTooLarge"):
    return numpy.int32(1222)
   if (_a_0=="errInfLintIndex"):
    return numpy.int32(1225)
   if (_a_0=="errArgIsTooSmall"):
    return numpy.int32(1226)
   if (_a_0=="errArgIsTooLarge"):
    return numpy.int32(1227)
   if (_a_0=="errInvalidWhichsol"):
    return numpy.int32(1228)
   if (_a_0=="errInfDouName"):
    return numpy.int32(1230)
   if (_a_0=="errInfIntName"):
    return numpy.int32(1231)
   if (_a_0=="errInfType"):
    return numpy.int32(1232)
   if (_a_0=="errInfLintName"):
    return numpy.int32(1234)
   if (_a_0=="errIndex"):
    return numpy.int32(1235)
   if (_a_0=="errWhichsol"):
    return numpy.int32(1236)
   if (_a_0=="errSolitem"):
    return numpy.int32(1237)
   if (_a_0=="errWhichitemNotAllowed"):
    return numpy.int32(1238)
   if (_a_0=="errMaxnumcon"):
    return numpy.int32(1240)
   if (_a_0=="errMaxnumvar"):
    return numpy.int32(1241)
   if (_a_0=="errMaxnumbarvar"):
    return numpy.int32(1242)
   if (_a_0=="errMaxnumqnz"):
    return numpy.int32(1243)
   if (_a_0=="errTooSmallMaxNumNz"):
    return numpy.int32(1245)
   if (_a_0=="errInvalidIdx"):
    return numpy.int32(1246)
   if (_a_0=="errInvalidMaxNum"):
    return numpy.int32(1247)
   if (_a_0=="errUnallowedWhichsol"):
    return numpy.int32(1248)
   if (_a_0=="errNumconlim"):
    return numpy.int32(1250)
   if (_a_0=="errNumvarlim"):
    return numpy.int32(1251)
   if (_a_0=="errTooSmallMaxnumanz"):
    return numpy.int32(1252)
   if (_a_0=="errInvAptre"):
    return numpy.int32(1253)
   if (_a_0=="errMulAElement"):
    return numpy.int32(1254)
   if (_a_0=="errInvBk"):
    return numpy.int32(1255)
   if (_a_0=="errInvBkc"):
    return numpy.int32(1256)
   if (_a_0=="errInvBkx"):
    return numpy.int32(1257)
   if (_a_0=="errInvVarType"):
    return numpy.int32(1258)
   if (_a_0=="errSolverProbtype"):
    return numpy.int32(1259)
   if (_a_0=="errObjectiveRange"):
    return numpy.int32(1260)
   if (_a_0=="errInvRescode"):
    return numpy.int32(1261)
   if (_a_0=="errInvIinf"):
    return numpy.int32(1262)
   if (_a_0=="errInvLiinf"):
    return numpy.int32(1263)
   if (_a_0=="errInvDinf"):
    return numpy.int32(1264)
   if (_a_0=="errBasis"):
    return numpy.int32(1266)
   if (_a_0=="errInvSkc"):
    return numpy.int32(1267)
   if (_a_0=="errInvSkx"):
    return numpy.int32(1268)
   if (_a_0=="errInvSkn"):
    return numpy.int32(1274)
   if (_a_0=="errInvSkStr"):
    return numpy.int32(1269)
   if (_a_0=="errInvSk"):
    return numpy.int32(1270)
   if (_a_0=="errInvConeTypeStr"):
    return numpy.int32(1271)
   if (_a_0=="errInvConeType"):
    return numpy.int32(1272)
   if (_a_0=="errInvalidSurplus"):
    return numpy.int32(1275)
   if (_a_0=="errInvNameItem"):
    return numpy.int32(1280)
   if (_a_0=="errProItem"):
    return numpy.int32(1281)
   if (_a_0=="errInvalidFormatType"):
    return numpy.int32(1283)
   if (_a_0=="errFirsti"):
    return numpy.int32(1285)
   if (_a_0=="errLasti"):
    return numpy.int32(1286)
   if (_a_0=="errFirstj"):
    return numpy.int32(1287)
   if (_a_0=="errLastj"):
    return numpy.int32(1288)
   if (_a_0=="errMaxLenIsTooSmall"):
    return numpy.int32(1289)
   if (_a_0=="errNonlinearEquality"):
    return numpy.int32(1290)
   if (_a_0=="errNonconvex"):
    return numpy.int32(1291)
   if (_a_0=="errNonlinearRanged"):
    return numpy.int32(1292)
   if (_a_0=="errConQNotPsd"):
    return numpy.int32(1293)
   if (_a_0=="errConQNotNsd"):
    return numpy.int32(1294)
   if (_a_0=="errObjQNotPsd"):
    return numpy.int32(1295)
   if (_a_0=="errObjQNotNsd"):
    return numpy.int32(1296)
   if (_a_0=="errArgumentPermArray"):
    return numpy.int32(1299)
   if (_a_0=="errConeIndex"):
    return numpy.int32(1300)
   if (_a_0=="errConeSize"):
    return numpy.int32(1301)
   if (_a_0=="errConeOverlap"):
    return numpy.int32(1302)
   if (_a_0=="errConeRepVar"):
    return numpy.int32(1303)
   if (_a_0=="errMaxnumcone"):
    return numpy.int32(1304)
   if (_a_0=="errConeType"):
    return numpy.int32(1305)
   if (_a_0=="errConeTypeStr"):
    return numpy.int32(1306)
   if (_a_0=="errConeOverlapAppend"):
    return numpy.int32(1307)
   if (_a_0=="errRemoveConeVariable"):
    return numpy.int32(1310)
   if (_a_0=="errAppendingTooBigCone"):
    return numpy.int32(1311)
   if (_a_0=="errConeParameter"):
    return numpy.int32(1320)
   if (_a_0=="errSolFileInvalidNumber"):
    return numpy.int32(1350)
   if (_a_0=="errHugeC"):
    return numpy.int32(1375)
   if (_a_0=="errHugeAij"):
    return numpy.int32(1380)
   if (_a_0=="errDuplicateAij"):
    return numpy.int32(1385)
   if (_a_0=="errLowerBoundIsANan"):
    return numpy.int32(1390)
   if (_a_0=="errUpperBoundIsANan"):
    return numpy.int32(1391)
   if (_a_0=="errInfiniteBound"):
    return numpy.int32(1400)
   if (_a_0=="errInvQobjSubi"):
    return numpy.int32(1401)
   if (_a_0=="errInvQobjSubj"):
    return numpy.int32(1402)
   if (_a_0=="errInvQobjVal"):
    return numpy.int32(1403)
   if (_a_0=="errInvQconSubk"):
    return numpy.int32(1404)
   if (_a_0=="errInvQconSubi"):
    return numpy.int32(1405)
   if (_a_0=="errInvQconSubj"):
    return numpy.int32(1406)
   if (_a_0=="errInvQconVal"):
    return numpy.int32(1407)
   if (_a_0=="errQconSubiTooSmall"):
    return numpy.int32(1408)
   if (_a_0=="errQconSubiTooLarge"):
    return numpy.int32(1409)
   if (_a_0=="errQobjUpperTriangle"):
    return numpy.int32(1415)
   if (_a_0=="errQconUpperTriangle"):
    return numpy.int32(1417)
   if (_a_0=="errFixedBoundValues"):
    return numpy.int32(1420)
   if (_a_0=="errTooSmallATruncationValue"):
    return numpy.int32(1421)
   if (_a_0=="errInvalidObjectiveSense"):
    return numpy.int32(1445)
   if (_a_0=="errUndefinedObjectiveSense"):
    return numpy.int32(1446)
   if (_a_0=="errYIsUndefined"):
    return numpy.int32(1449)
   if (_a_0=="errNanInDoubleData"):
    return numpy.int32(1450)
   if (_a_0=="errInfInDoubleData"):
    return numpy.int32(1451)
   if (_a_0=="errNanInBlc"):
    return numpy.int32(1461)
   if (_a_0=="errNanInBuc"):
    return numpy.int32(1462)
   if (_a_0=="errInvalidCfix"):
    return numpy.int32(1469)
   if (_a_0=="errNanInC"):
    return numpy.int32(1470)
   if (_a_0=="errNanInBlx"):
    return numpy.int32(1471)
   if (_a_0=="errNanInBux"):
    return numpy.int32(1472)
   if (_a_0=="errInvalidAij"):
    return numpy.int32(1473)
   if (_a_0=="errInvalidCj"):
    return numpy.int32(1474)
   if (_a_0=="errSymMatInvalid"):
    return numpy.int32(1480)
   if (_a_0=="errSymMatHuge"):
    return numpy.int32(1482)
   if (_a_0=="errInvProblem"):
    return numpy.int32(1500)
   if (_a_0=="errMixedConicAndNl"):
    return numpy.int32(1501)
   if (_a_0=="errGlobalInvConicProblem"):
    return numpy.int32(1503)
   if (_a_0=="errInvOptimizer"):
    return numpy.int32(1550)
   if (_a_0=="errMioNoOptimizer"):
    return numpy.int32(1551)
   if (_a_0=="errNoOptimizerVarType"):
    return numpy.int32(1552)
   if (_a_0=="errFinalSolution"):
    return numpy.int32(1560)
   if (_a_0=="errFirst"):
    return numpy.int32(1570)
   if (_a_0=="errLast"):
    return numpy.int32(1571)
   if (_a_0=="errSliceSize"):
    return numpy.int32(1572)
   if (_a_0=="errNegativeSurplus"):
    return numpy.int32(1573)
   if (_a_0=="errNegativeAppend"):
    return numpy.int32(1578)
   if (_a_0=="errPostsolve"):
    return numpy.int32(1580)
   if (_a_0=="errOverflow"):
    return numpy.int32(1590)
   if (_a_0=="errNoBasisSol"):
    return numpy.int32(1600)
   if (_a_0=="errBasisFactor"):
    return numpy.int32(1610)
   if (_a_0=="errBasisSingular"):
    return numpy.int32(1615)
   if (_a_0=="errFactor"):
    return numpy.int32(1650)
   if (_a_0=="errFeasrepairCannotRelax"):
    return numpy.int32(1700)
   if (_a_0=="errFeasrepairSolvingRelaxed"):
    return numpy.int32(1701)
   if (_a_0=="errFeasrepairInconsistentBound"):
    return numpy.int32(1702)
   if (_a_0=="errRepairInvalidProblem"):
    return numpy.int32(1710)
   if (_a_0=="errRepairOptimizationFailed"):
    return numpy.int32(1711)
   if (_a_0=="errNameMaxLen"):
    return numpy.int32(1750)
   if (_a_0=="errNameIsNull"):
    return numpy.int32(1760)
   if (_a_0=="errInvalidCompression"):
    return numpy.int32(1800)
   if (_a_0=="errInvalidIomode"):
    return numpy.int32(1801)
   if (_a_0=="errNoPrimalInfeasCer"):
    return numpy.int32(2000)
   if (_a_0=="errNoDualInfeasCer"):
    return numpy.int32(2001)
   if (_a_0=="errNoSolutionInCallback"):
    return numpy.int32(2500)
   if (_a_0=="errInvMarki"):
    return numpy.int32(2501)
   if (_a_0=="errInvMarkj"):
    return numpy.int32(2502)
   if (_a_0=="errInvNumi"):
    return numpy.int32(2503)
   if (_a_0=="errInvNumj"):
    return numpy.int32(2504)
   if (_a_0=="errTaskIncompatible"):
    return numpy.int32(2560)
   if (_a_0=="errTaskInvalid"):
    return numpy.int32(2561)
   if (_a_0=="errTaskWrite"):
    return numpy.int32(2562)
   if (_a_0=="errReadWrite"):
    return numpy.int32(2563)
   if (_a_0=="errTaskPrematureEof"):
    return numpy.int32(2564)
   if (_a_0=="errLuMaxNumTries"):
    return numpy.int32(2800)
   if (_a_0=="errInvalidUtf8"):
    return numpy.int32(2900)
   if (_a_0=="errInvalidWchar"):
    return numpy.int32(2901)
   if (_a_0=="errNoDualForItgSol"):
    return numpy.int32(2950)
   if (_a_0=="errNoSnxForBasSol"):
    return numpy.int32(2953)
   if (_a_0=="errInternal"):
    return numpy.int32(3000)
   if (_a_0=="errApiArrayTooSmall"):
    return numpy.int32(3001)
   if (_a_0=="errApiCbConnect"):
    return numpy.int32(3002)
   if (_a_0=="errApiFatalError"):
    return numpy.int32(3005)
   if (_a_0=="errApiInternal"):
    return numpy.int32(3999)
   if (_a_0=="errSenFormat"):
    return numpy.int32(3050)
   if (_a_0=="errSenUndefName"):
    return numpy.int32(3051)
   if (_a_0=="errSenIndexRange"):
    return numpy.int32(3052)
   if (_a_0=="errSenBoundInvalidUp"):
    return numpy.int32(3053)
   if (_a_0=="errSenBoundInvalidLo"):
    return numpy.int32(3054)
   if (_a_0=="errSenIndexInvalid"):
    return numpy.int32(3055)
   if (_a_0=="errSenInvalidRegexp"):
    return numpy.int32(3056)
   if (_a_0=="errSenSolutionStatus"):
    return numpy.int32(3057)
   if (_a_0=="errSenNumerical"):
    return numpy.int32(3058)
   if (_a_0=="errSenUnhandledProblemType"):
    return numpy.int32(3080)
   if (_a_0=="errUnbStepSize"):
    return numpy.int32(3100)
   if (_a_0=="errIdenticalTasks"):
    return numpy.int32(3101)
   if (_a_0=="errAdInvalidCodelist"):
    return numpy.int32(3102)
   if (_a_0=="errInternalTestFailed"):
    return numpy.int32(3500)
   if (_a_0=="errInt64ToInt32Cast"):
    return numpy.int32(3800)
   if (_a_0=="errInfeasUndefined"):
    return numpy.int32(3910)
   if (_a_0=="errNoBarxForSolution"):
    return numpy.int32(3915)
   if (_a_0=="errNoBarsForSolution"):
    return numpy.int32(3916)
   if (_a_0=="errBarVarDim"):
    return numpy.int32(3920)
   if (_a_0=="errSymMatInvalidRowIndex"):
    return numpy.int32(3940)
   if (_a_0=="errSymMatInvalidColIndex"):
    return numpy.int32(3941)
   if (_a_0=="errSymMatNotLowerTringular"):
    return numpy.int32(3942)
   if (_a_0=="errSymMatInvalidValue"):
    return numpy.int32(3943)
   if (_a_0=="errSymMatDuplicate"):
    return numpy.int32(3944)
   if (_a_0=="errInvalidSymMatDim"):
    return numpy.int32(3950)
   if (_a_0=="errInvalidFileFormatForSymMat"):
    return numpy.int32(4000)
   if (_a_0=="errInvalidFileFormatForCfix"):
    return numpy.int32(4001)
   if (_a_0=="errInvalidFileFormatForRangedConstraints"):
    return numpy.int32(4002)
   if (_a_0=="errInvalidFileFormatForFreeConstraints"):
    return numpy.int32(4003)
   if (_a_0=="errInvalidFileFormatForCones"):
    return numpy.int32(4005)
   if (_a_0=="errInvalidFileFormatForQuadraticTerms"):
    return numpy.int32(4006)
   if (_a_0=="errInvalidFileFormatForNonlinear"):
    return numpy.int32(4010)
   if (_a_0=="errInvalidFileFormatForDisjunctiveConstraints"):
    return numpy.int32(4011)
   if (_a_0=="errInvalidFileFormatForAffineConicConstraints"):
    return numpy.int32(4012)
   if (_a_0=="errDuplicateConstraintNames"):
    return numpy.int32(4500)
   if (_a_0=="errDuplicateVariableNames"):
    return numpy.int32(4501)
   if (_a_0=="errDuplicateBarvariableNames"):
    return numpy.int32(4502)
   if (_a_0=="errDuplicateConeNames"):
    return numpy.int32(4503)
   if (_a_0=="errDuplicateDomainNames"):
    return numpy.int32(4504)
   if (_a_0=="errDuplicateDjcNames"):
    return numpy.int32(4505)
   if (_a_0=="errNonUniqueArray"):
    return numpy.int32(5000)
   if (_a_0=="errArgumentIsTooSmall"):
    return numpy.int32(5004)
   if (_a_0=="errArgumentIsTooLarge"):
    return numpy.int32(5005)
   if (_a_0=="errMioInternal"):
    return numpy.int32(5010)
   if (_a_0=="errInvalidProblemType"):
    return numpy.int32(6000)
   if (_a_0=="errUnhandledSolutionStatus"):
    return numpy.int32(6010)
   if (_a_0=="errUpperTriangle"):
    return numpy.int32(6020)
   if (_a_0=="errLauSingularMatrix"):
    return numpy.int32(7000)
   if (_a_0=="errLauNotPositiveDefinite"):
    return numpy.int32(7001)
   if (_a_0=="errLauInvalidLowerTriangularMatrix"):
    return numpy.int32(7002)
   if (_a_0=="errLauUnknown"):
    return numpy.int32(7005)
   if (_a_0=="errLauArgM"):
    return numpy.int32(7010)
   if (_a_0=="errLauArgN"):
    return numpy.int32(7011)
   if (_a_0=="errLauArgK"):
    return numpy.int32(7012)
   if (_a_0=="errLauArgTransa"):
    return numpy.int32(7015)
   if (_a_0=="errLauArgTransb"):
    return numpy.int32(7016)
   if (_a_0=="errLauArgUplo"):
    return numpy.int32(7017)
   if (_a_0=="errLauArgTrans"):
    return numpy.int32(7018)
   if (_a_0=="errLauInvalidSparseSymmetricMatrix"):
    return numpy.int32(7019)
   if (_a_0=="errCbfParse"):
    return numpy.int32(7100)
   if (_a_0=="errCbfObjSense"):
    return numpy.int32(7101)
   if (_a_0=="errCbfNoVariables"):
    return numpy.int32(7102)
   if (_a_0=="errCbfTooManyConstraints"):
    return numpy.int32(7103)
   if (_a_0=="errCbfTooManyVariables"):
    return numpy.int32(7104)
   if (_a_0=="errCbfNoVersionSpecified"):
    return numpy.int32(7105)
   if (_a_0=="errCbfSyntax"):
    return numpy.int32(7106)
   if (_a_0=="errCbfDuplicateObj"):
    return numpy.int32(7107)
   if (_a_0=="errCbfDuplicateCon"):
    return numpy.int32(7108)
   if (_a_0=="errCbfDuplicateVar"):
    return numpy.int32(7110)
   if (_a_0=="errCbfDuplicateInt"):
    return numpy.int32(7111)
   if (_a_0=="errCbfInvalidVarType"):
    return numpy.int32(7112)
   if (_a_0=="errCbfInvalidConType"):
    return numpy.int32(7113)
   if (_a_0=="errCbfInvalidDomainDimension"):
    return numpy.int32(7114)
   if (_a_0=="errCbfDuplicateObjacoord"):
    return numpy.int32(7115)
   if (_a_0=="errCbfDuplicateBcoord"):
    return numpy.int32(7116)
   if (_a_0=="errCbfDuplicateAcoord"):
    return numpy.int32(7117)
   if (_a_0=="errCbfTooFewVariables"):
    return numpy.int32(7118)
   if (_a_0=="errCbfTooFewConstraints"):
    return numpy.int32(7119)
   if (_a_0=="errCbfTooFewInts"):
    return numpy.int32(7120)
   if (_a_0=="errCbfTooManyInts"):
    return numpy.int32(7121)
   if (_a_0=="errCbfInvalidIntIndex"):
    return numpy.int32(7122)
   if (_a_0=="errCbfUnsupported"):
    return numpy.int32(7123)
   if (_a_0=="errCbfDuplicatePsdvar"):
    return numpy.int32(7124)
   if (_a_0=="errCbfInvalidPsdvarDimension"):
    return numpy.int32(7125)
   if (_a_0=="errCbfTooFewPsdvar"):
    return numpy.int32(7126)
   if (_a_0=="errCbfInvalidExpDimension"):
    return numpy.int32(7127)
   if (_a_0=="errCbfDuplicatePowCones"):
    return numpy.int32(7130)
   if (_a_0=="errCbfDuplicatePowStarCones"):
    return numpy.int32(7131)
   if (_a_0=="errCbfInvalidPower"):
    return numpy.int32(7132)
   if (_a_0=="errCbfPowerConeIsTooLong"):
    return numpy.int32(7133)
   if (_a_0=="errCbfInvalidPowerConeIndex"):
    return numpy.int32(7134)
   if (_a_0=="errCbfInvalidPowerStarConeIndex"):
    return numpy.int32(7135)
   if (_a_0=="errCbfUnhandledPowerConeType"):
    return numpy.int32(7136)
   if (_a_0=="errCbfUnhandledPowerStarConeType"):
    return numpy.int32(7137)
   if (_a_0=="errCbfPowerConeMismatch"):
    return numpy.int32(7138)
   if (_a_0=="errCbfPowerStarConeMismatch"):
    return numpy.int32(7139)
   if (_a_0=="errCbfInvalidNumberOfCones"):
    return numpy.int32(7140)
   if (_a_0=="errCbfInvalidDimensionOfCones"):
    return numpy.int32(7141)
   if (_a_0=="errCbfInvalidNumObjacoord"):
    return numpy.int32(7150)
   if (_a_0=="errCbfInvalidNumObjfcoord"):
    return numpy.int32(7151)
   if (_a_0=="errCbfInvalidNumAcoord"):
    return numpy.int32(7152)
   if (_a_0=="errCbfInvalidNumBcoord"):
    return numpy.int32(7153)
   if (_a_0=="errCbfInvalidNumFcoord"):
    return numpy.int32(7155)
   if (_a_0=="errCbfInvalidNumHcoord"):
    return numpy.int32(7156)
   if (_a_0=="errCbfInvalidNumDcoord"):
    return numpy.int32(7157)
   if (_a_0=="errCbfExpectedAKeyword"):
    return numpy.int32(7158)
   if (_a_0=="errCbfInvalidNumPsdcon"):
    return numpy.int32(7200)
   if (_a_0=="errCbfDuplicatePsdcon"):
    return numpy.int32(7201)
   if (_a_0=="errCbfInvalidDimensionOfPsdcon"):
    return numpy.int32(7202)
   if (_a_0=="errCbfInvalidPsdconIndex"):
    return numpy.int32(7203)
   if (_a_0=="errCbfInvalidPsdconVariableIndex"):
    return numpy.int32(7204)
   if (_a_0=="errCbfInvalidPsdconBlockIndex"):
    return numpy.int32(7205)
   if (_a_0=="errCbfUnsupportedChange"):
    return numpy.int32(7210)
   if (_a_0=="errMioInvalidRootOptimizer"):
    return numpy.int32(7700)
   if (_a_0=="errMioInvalidNodeOptimizer"):
    return numpy.int32(7701)
   if (_a_0=="errMpsWriteCplexInvalidConeType"):
    return numpy.int32(7750)
   if (_a_0=="errToconicConstrQNotPsd"):
    return numpy.int32(7800)
   if (_a_0=="errToconicConstraintFx"):
    return numpy.int32(7801)
   if (_a_0=="errToconicConstraintRa"):
    return numpy.int32(7802)
   if (_a_0=="errToconicConstrNotConic"):
    return numpy.int32(7803)
   if (_a_0=="errToconicObjectiveNotPsd"):
    return numpy.int32(7804)
   if (_a_0=="errGetdualNotAvailable"):
    return numpy.int32(7820)
   if (_a_0=="errServerConnect"):
    return numpy.int32(8000)
   if (_a_0=="errServerProtocol"):
    return numpy.int32(8001)
   if (_a_0=="errServerStatus"):
    return numpy.int32(8002)
   if (_a_0=="errServerToken"):
    return numpy.int32(8003)
   if (_a_0=="errServerAddress"):
    return numpy.int32(8004)
   if (_a_0=="errServerCertificate"):
    return numpy.int32(8005)
   if (_a_0=="errServerTlsClient"):
    return numpy.int32(8006)
   if (_a_0=="errServerAccessToken"):
    return numpy.int32(8007)
   if (_a_0=="errServerProblemSize"):
    return numpy.int32(8008)
   if (_a_0=="errServerHardTimeout"):
    return numpy.int32(8009)
   if (_a_0=="errDuplicateIndexInASparseMatrix"):
    return numpy.int32(20050)
   if (_a_0=="errDuplicateIndexInAfeidxList"):
    return numpy.int32(20060)
   if (_a_0=="errDuplicateFij"):
    return numpy.int32(20100)
   if (_a_0=="errInvalidFij"):
    return numpy.int32(20101)
   if (_a_0=="errHugeFij"):
    return numpy.int32(20102)
   if (_a_0=="errInvalidG"):
    return numpy.int32(20103)
   if (_a_0=="errInvalidB"):
    return numpy.int32(20150)
   if (_a_0=="errDomainInvalidIndex"):
    return numpy.int32(20400)
   if (_a_0=="errDomainDimension"):
    return numpy.int32(20401)
   if (_a_0=="errDomainDimensionPsd"):
    return numpy.int32(20402)
   if (_a_0=="errNotPowerDomain"):
    return numpy.int32(20403)
   if (_a_0=="errDomainPowerInvalidAlpha"):
    return numpy.int32(20404)
   if (_a_0=="errDomainPowerNegativeAlpha"):
    return numpy.int32(20405)
   if (_a_0=="errDomainPowerNleft"):
    return numpy.int32(20406)
   if (_a_0=="errAfeInvalidIndex"):
    return numpy.int32(20500)
   if (_a_0=="errAccInvalidIndex"):
    return numpy.int32(20600)
   if (_a_0=="errAccInvalidEntryIndex"):
    return numpy.int32(20601)
   if (_a_0=="errAccAfeDomainMismatch"):
    return numpy.int32(20602)
   if (_a_0=="errDjcInvalidIndex"):
    return numpy.int32(20700)
   if (_a_0=="errDjcUnsupportedDomainType"):
    return numpy.int32(20701)
   if (_a_0=="errDjcAfeDomainMismatch"):
    return numpy.int32(20702)
   if (_a_0=="errDjcInvalidTermSize"):
    return numpy.int32(20703)
   if (_a_0=="errDjcDomainTermsizeMismatch"):
    return numpy.int32(20704)
   if (_a_0=="errDjcTotalNumTermsMismatch"):
    return numpy.int32(20705)
   if (_a_0=="errUndefSolution"):
    return numpy.int32(22000)
   if (_a_0=="errNoDoty"):
    return numpy.int32(22010)
   if (_a_0=="trmMaxIterations"):
    return numpy.int32(100000)
   if (_a_0=="trmMaxTime"):
    return numpy.int32(100001)
   if (_a_0=="trmObjectiveRange"):
    return numpy.int32(100002)
   if (_a_0=="trmMioNumRelaxs"):
    return numpy.int32(100008)
   if (_a_0=="trmMioNumBranches"):
    return numpy.int32(100009)
   if (_a_0=="trmNumMaxNumIntSolutions"):
    return numpy.int32(100015)
   if (_a_0=="trmStall"):
    return numpy.int32(100006)
   if (_a_0=="trmUserCallback"):
    return numpy.int32(100007)
   if (_a_0=="trmMaxNumSetbacks"):
    return numpy.int32(100020)
   if (_a_0=="trmNumericalProblem"):
    return numpy.int32(100025)
   if (_a_0=="trmLostRace"):
    return numpy.int32(100027)
   if (_a_0=="trmInternal"):
    return numpy.int32(100030)
   if (_a_0=="trmInternalStop"):
    return numpy.int32(100031)
   if (_a_0=="trmServerMaxTime"):
    return numpy.int32(100032)
   if (_a_0=="trmServerMaxMemory"):
    return numpy.int32(100033)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1prosta_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1prosta_1value_S(_a_0)
  @staticmethod
  def __string_1to_1prosta_1value_S(_a_0):
   if (_a_0=="unknown"):
    return numpy.int32(0)
   if (_a_0=="primAndDualFeas"):
    return numpy.int32(1)
   if (_a_0=="primFeas"):
    return numpy.int32(2)
   if (_a_0=="dualFeas"):
    return numpy.int32(3)
   if (_a_0=="primInfeas"):
    return numpy.int32(4)
   if (_a_0=="dualInfeas"):
    return numpy.int32(5)
   if (_a_0=="primAndDualInfeas"):
    return numpy.int32(6)
   if (_a_0=="illPosed"):
    return numpy.int32(7)
   if (_a_0=="primInfeasOrUnbounded"):
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemtype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1problemtype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1problemtype_1value_S(_a_0):
   if (_a_0=="lo"):
    return numpy.int32(0)
   if (_a_0=="qo"):
    return numpy.int32(1)
   if (_a_0=="qcqo"):
    return numpy.int32(2)
   if (_a_0=="conic"):
    return numpy.int32(3)
   if (_a_0=="mixed"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemitem_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1problemitem_1value_S(_a_0)
  @staticmethod
  def __string_1to_1problemitem_1value_S(_a_0):
   if (_a_0=="var"):
    return numpy.int32(0)
   if (_a_0=="con"):
    return numpy.int32(1)
   if (_a_0=="cone"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1parametertype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1parametertype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1parametertype_1value_S(_a_0):
   if (_a_0=="invalidType"):
    return numpy.int32(0)
   if (_a_0=="douType"):
    return numpy.int32(1)
   if (_a_0=="intType"):
    return numpy.int32(2)
   if (_a_0=="strType"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1foldingmode_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1foldingmode_1value_S(_a_0)
  @staticmethod
  def __string_1to_1foldingmode_1value_S(_a_0):
   if (_a_0=="off"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(1)
   if (_a_0=="freeUnlessBasic"):
    return numpy.int32(2)
   if (_a_0=="force"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1presolvemode_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1presolvemode_1value_S(_a_0)
  @staticmethod
  def __string_1to_1presolvemode_1value_S(_a_0):
   if (_a_0=="off"):
    return numpy.int32(0)
   if (_a_0=="on"):
    return numpy.int32(1)
   if (_a_0=="free"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1orderingtype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1orderingtype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1orderingtype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="appminloc"):
    return numpy.int32(1)
   if (_a_0=="experimental"):
    return numpy.int32(2)
   if (_a_0=="tryGraphpar"):
    return numpy.int32(3)
   if (_a_0=="forceGraphpar"):
    return numpy.int32(4)
   if (_a_0=="none"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1optimizertype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1optimizertype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1optimizertype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(2)
   if (_a_0=="intpnt"):
    return numpy.int32(4)
   if (_a_0=="conic"):
    return numpy.int32(0)
   if (_a_0=="primalSimplex"):
    return numpy.int32(8)
   if (_a_0=="dualSimplex"):
    return numpy.int32(1)
   if (_a_0=="newPrimalSimplex"):
    return numpy.int32(7)
   if (_a_0=="newDualSimplex"):
    return numpy.int32(6)
   if (_a_0=="freeSimplex"):
    return numpy.int32(3)
   if (_a_0=="mixedInt"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1onoffkey_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1onoffkey_1value_S(_a_0)
  @staticmethod
  def __string_1to_1onoffkey_1value_S(_a_0):
   if (_a_0=="on"):
    return numpy.int32(1)
   if (_a_0=="off"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1objsense_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1objsense_1value_S(_a_0)
  @staticmethod
  def __string_1to_1objsense_1value_S(_a_0):
   if (_a_0=="minimize"):
    return numpy.int32(0)
   if (_a_0=="maximize"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mpsformat_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1mpsformat_1value_S(_a_0)
  @staticmethod
  def __string_1to_1mpsformat_1value_S(_a_0):
   if (_a_0=="strict"):
    return numpy.int32(0)
   if (_a_0=="relaxed"):
    return numpy.int32(1)
   if (_a_0=="free"):
    return numpy.int32(2)
   if (_a_0=="cplex"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miovarseltype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1miovarseltype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1miovarseltype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="pseudocost"):
    return numpy.int32(1)
   if (_a_0=="strong"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mionodeseltype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1mionodeseltype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1mionodeseltype_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="first"):
    return numpy.int32(1)
   if (_a_0=="best"):
    return numpy.int32(2)
   if (_a_0=="pseudo"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miomode_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1miomode_1value_S(_a_0)
  @staticmethod
  def __string_1to_1miomode_1value_S(_a_0):
   if (_a_0=="ignored"):
    return numpy.int32(0)
   if (_a_0=="satisfied"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miocontsoltype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1miocontsoltype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1miocontsoltype_1value_S(_a_0):
   if (_a_0=="none"):
    return numpy.int32(0)
   if (_a_0=="root"):
    return numpy.int32(1)
   if (_a_0=="itg"):
    return numpy.int32(2)
   if (_a_0=="itgRel"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miodatapermmethod_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1miodatapermmethod_1value_S(_a_0)
  @staticmethod
  def __string_1to_1miodatapermmethod_1value_S(_a_0):
   if (_a_0=="none"):
    return numpy.int32(0)
   if (_a_0=="cyclicShift"):
    return numpy.int32(1)
   if (_a_0=="random"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miqcqoreformmethod_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1miqcqoreformmethod_1value_S(_a_0)
  @staticmethod
  def __string_1to_1miqcqoreformmethod_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="none"):
    return numpy.int32(1)
   if (_a_0=="linearization"):
    return numpy.int32(2)
   if (_a_0=="eigenValMethod"):
    return numpy.int32(3)
   if (_a_0=="diagSdp"):
    return numpy.int32(4)
   if (_a_0=="relaxSdp"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1branchdir_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1branchdir_1value_S(_a_0)
  @staticmethod
  def __string_1to_1branchdir_1value_S(_a_0):
   if (_a_0=="free"):
    return numpy.int32(0)
   if (_a_0=="up"):
    return numpy.int32(1)
   if (_a_0=="down"):
    return numpy.int32(2)
   if (_a_0=="near"):
    return numpy.int32(3)
   if (_a_0=="far"):
    return numpy.int32(4)
   if (_a_0=="rootLp"):
    return numpy.int32(5)
   if (_a_0=="guided"):
    return numpy.int32(6)
   if (_a_0=="pseudocost"):
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iparam_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1iparam_1value_S(_a_0)
  @staticmethod
  def __string_1to_1iparam_1value_S(_a_0):
   if (_a_0=="autoUpdateSolInfo"):
    return numpy.int32(3)
   if (_a_0=="removeUnusedSolutions"):
    return numpy.int32(134)
   if (_a_0=="intpntHotstart"):
    return numpy.int32(19)
   if (_a_0=="numThreads"):
    return numpy.int32(100)
   if (_a_0=="timingLevel"):
    return numpy.int32(167)
   if (_a_0=="mtSpincount"):
    return numpy.int32(98)
   if (_a_0=="maxNumWarnings"):
    return numpy.int32(56)
   if (_a_0=="optimizer"):
    return numpy.int32(110)
   if (_a_0=="simPrecision"):
    return numpy.int32(150)
   if (_a_0=="biMaxIterations"):
    return numpy.int32(8)
   if (_a_0=="licenseTrhExpiryWrn"):
    return numpy.int32(32)
   if (_a_0=="logIncludeSummary"):
    return numpy.int32(42)
   if (_a_0=="logCutSecondOpt"):
    return numpy.int32(38)
   if (_a_0=="logAnaPro"):
    return numpy.int32(35)
   if (_a_0=="logLocalInfo"):
    return numpy.int32(45)
   if (_a_0=="logBi"):
    return numpy.int32(36)
   if (_a_0=="logBiFreq"):
    return numpy.int32(37)
   if (_a_0=="biCleanOptimizer"):
    return numpy.int32(5)
   if (_a_0=="intpntStartingPoint"):
    return numpy.int32(28)
   if (_a_0=="intpntDiffStep"):
    return numpy.int32(18)
   if (_a_0=="intpntScaling"):
    return numpy.int32(26)
   if (_a_0=="intpntSolveForm"):
    return numpy.int32(27)
   if (_a_0=="logIntpnt"):
    return numpy.int32(44)
   if (_a_0=="intpntMaxIterations"):
    return numpy.int32(20)
   if (_a_0=="intpntOffColTrh"):
    return numpy.int32(22)
   if (_a_0=="intpntOrderMethod"):
    return numpy.int32(24)
   if (_a_0=="intpntOrderGpNumSeeds"):
    return numpy.int32(23)
   if (_a_0=="intpntBasis"):
    return numpy.int32(17)
   if (_a_0=="biIgnoreMaxIter"):
    return numpy.int32(6)
   if (_a_0=="biIgnoreNumError"):
    return numpy.int32(7)
   if (_a_0=="intpntMaxNumCor"):
    return numpy.int32(21)
   if (_a_0=="presolveUse"):
    return numpy.int32(121)
   if (_a_0=="logPresolve"):
    return numpy.int32(49)
   if (_a_0=="presolveLindepUse"):
    return numpy.int32(118)
   if (_a_0=="presolveLindepNew"):
    return numpy.int32(116)
   if (_a_0=="presolveMaxNumPass"):
    return numpy.int32(119)
   if (_a_0=="presolveEliminatorMaxNumTries"):
    return numpy.int32(114)
   if (_a_0=="presolveEliminatorMaxFill"):
    return numpy.int32(113)
   if (_a_0=="presolveMaxNumReductions"):
    return numpy.int32(120)
   if (_a_0=="foldingUse"):
    return numpy.int32(11)
   if (_a_0=="simDetectPwl"):
    return numpy.int32(139)
   if (_a_0=="simPrimalCrash"):
    return numpy.int32(152)
   if (_a_0=="logSim"):
    return numpy.int32(52)
   if (_a_0=="logSimFreq"):
    return numpy.int32(53)
   if (_a_0=="logSimFreqGigaTicks"):
    return numpy.int32(54)
   if (_a_0=="heartbeatSimFreqTicks"):
    return numpy.int32(13)
   if (_a_0=="simPrimalRestrictSelection"):
    return numpy.int32(154)
   if (_a_0=="simPrimalSelection"):
    return numpy.int32(155)
   if (_a_0=="simDualRestrictSelection"):
    return numpy.int32(142)
   if (_a_0=="simDualSelection"):
    return numpy.int32(143)
   if (_a_0=="simMaxIterations"):
    return numpy.int32(147)
   if (_a_0=="simHotstartLu"):
    return numpy.int32(146)
   if (_a_0=="simRefactorFreq"):
    return numpy.int32(156)
   if (_a_0=="simSeed"):
    return numpy.int32(161)
   if (_a_0=="mioMode"):
    return numpy.int32(81)
   if (_a_0=="logMio"):
    return numpy.int32(46)
   if (_a_0=="logMioFreq"):
    return numpy.int32(47)
   if (_a_0=="mioMaxNumRelaxs"):
    return numpy.int32(75)
   if (_a_0=="mioMaxNumBranches"):
    return numpy.int32(74)
   if (_a_0=="mioMaxNumRestarts"):
    return numpy.int32(76)
   if (_a_0=="mioMaxNumRootCutRounds"):
    return numpy.int32(77)
   if (_a_0=="mioMaxNumSolutions"):
    return numpy.int32(78)
   if (_a_0=="mioNodeSelection"):
    return numpy.int32(83)
   if (_a_0=="mioVarSelection"):
    return numpy.int32(96)
   if (_a_0=="mioMinRel"):
    return numpy.int32(80)
   if (_a_0=="mioHeuristicLevel"):
    return numpy.int32(72)
   if (_a_0=="mioProbingLevel"):
    return numpy.int32(88)
   if (_a_0=="mioSymmetryLevel"):
    return numpy.int32(95)
   if (_a_0=="mioDualRayAnalysisLevel"):
    return numpy.int32(70)
   if (_a_0=="mioConflictAnalysisLevel"):
    return numpy.int32(58)
   if (_a_0=="mioPresolveAggregatorUse"):
    return numpy.int32(87)
   if (_a_0=="mioNumericalEmphasisLevel"):
    return numpy.int32(84)
   if (_a_0=="mioMemoryEmphasisLevel"):
    return numpy.int32(79)
   if (_a_0=="mioCutSelectionLevel"):
    return numpy.int32(68)
   if (_a_0=="mioVbDetectionLevel"):
    return numpy.int32(97)
   if (_a_0=="mioBranchDir"):
    return numpy.int32(57)
   if (_a_0=="mioRootOptimizer"):
    return numpy.int32(93)
   if (_a_0=="mioNodeOptimizer"):
    return numpy.int32(82)
   if (_a_0=="mioPerspectiveReformulate"):
    return numpy.int32(86)
   if (_a_0=="mioPropagateObjectiveConstraint"):
    return numpy.int32(89)
   if (_a_0=="mioSeed"):
    return numpy.int32(94)
   if (_a_0=="mioConicOuterApproximation"):
    return numpy.int32(59)
   if (_a_0=="mioQcqoReformulationMethod"):
    return numpy.int32(90)
   if (_a_0=="mioDataPermutationMethod"):
    return numpy.int32(69)
   if (_a_0=="readAsync"):
    return numpy.int32(127)
   if (_a_0=="writeAsync"):
    return numpy.int32(168)
   if (_a_0=="readKeepFreeCon"):
    return numpy.int32(129)
   if (_a_0=="readMpsFormat"):
    return numpy.int32(130)
   if (_a_0=="writeMpsFormat"):
    return numpy.int32(182)
   if (_a_0=="readMpsWidth"):
    return numpy.int32(131)
   if (_a_0=="readDebug"):
    return numpy.int32(128)
   if (_a_0=="writeFreeCon"):
    return numpy.int32(173)
   if (_a_0=="writeGenericNames"):
    return numpy.int32(174)
   if (_a_0=="writeCompression"):
    return numpy.int32(172)
   if (_a_0=="writeMpsInt"):
    return numpy.int32(183)
   if (_a_0=="writeLpLineWidth"):
    return numpy.int32(181)
   if (_a_0=="writeLpFullObj"):
    return numpy.int32(180)
   if (_a_0=="writeJsonIndentation"):
    return numpy.int32(179)
   if (_a_0=="writeSolIgnoreInvalidNames"):
    return numpy.int32(187)
   if (_a_0=="writeSolHead"):
    return numpy.int32(186)
   if (_a_0=="writeSolConstraints"):
    return numpy.int32(185)
   if (_a_0=="writeSolVariables"):
    return numpy.int32(188)
   if (_a_0=="writeSolBarvariables"):
    return numpy.int32(184)
   if (_a_0=="writeBasHead"):
    return numpy.int32(170)
   if (_a_0=="writeBasConstraints"):
    return numpy.int32(169)
   if (_a_0=="writeBasVariables"):
    return numpy.int32(171)
   if (_a_0=="writeIntHead"):
    return numpy.int32(177)
   if (_a_0=="writeIntConstraints"):
    return numpy.int32(176)
   if (_a_0=="writeIntVariables"):
    return numpy.int32(178)
   if (_a_0=="solReadNameWidth"):
    return numpy.int32(165)
   if (_a_0=="solReadWidth"):
    return numpy.int32(166)
   if (_a_0=="infeasReportAuto"):
    return numpy.int32(15)
   if (_a_0=="infeasReportLevel"):
    return numpy.int32(16)
   if (_a_0=="infeasGenericNames"):
    return numpy.int32(14)
   if (_a_0=="logInfeasAna"):
    return numpy.int32(43)
   if (_a_0=="licenseWait"):
    return numpy.int32(33)
   if (_a_0=="licenseSuppressExpireWrns"):
    return numpy.int32(31)
   if (_a_0=="licensePauseTime"):
    return numpy.int32(30)
   if (_a_0=="licenseDebug"):
    return numpy.int32(29)
   if (_a_0=="solFilterKeepBasic"):
    return numpy.int32(164)
   if (_a_0=="log"):
    return numpy.int32(34)
   if (_a_0=="logExpand"):
    return numpy.int32(39)
   if (_a_0=="logFile"):
    return numpy.int32(41)
   if (_a_0=="logOrder"):
    return numpy.int32(48)
   if (_a_0=="logSensitivity"):
    return numpy.int32(50)
   if (_a_0=="logSensitivityOpt"):
    return numpy.int32(51)
   if (_a_0=="readTaskIgnoreParam"):
    return numpy.int32(132)
   if (_a_0=="paramReadCaseName"):
    return numpy.int32(111)
   if (_a_0=="paramReadIgnError"):
    return numpy.int32(112)
   if (_a_0=="simScaling"):
    return numpy.int32(159)
   if (_a_0=="simScalingMethod"):
    return numpy.int32(160)
   if (_a_0=="simPrimalPhaseoneMethod"):
    return numpy.int32(153)
   if (_a_0=="simDualPhaseoneMethod"):
    return numpy.int32(141)
   if (_a_0=="simMaxNumSetbacks"):
    return numpy.int32(148)
   if (_a_0=="simHotstart"):
    return numpy.int32(145)
   if (_a_0=="simBasisFactorUse"):
    return numpy.int32(137)
   if (_a_0=="simPrecisionBoost"):
    return numpy.int32(151)
   if (_a_0=="simDegen"):
    return numpy.int32(138)
   if (_a_0=="simReformulation"):
    return numpy.int32(157)
   if (_a_0=="simExploitDupvec"):
    return numpy.int32(144)
   if (_a_0=="simSaveLu"):
    return numpy.int32(158)
   if (_a_0=="simNonSingular"):
    return numpy.int32(149)
   if (_a_0=="simDualCrash"):
    return numpy.int32(140)
   if (_a_0=="logStorage"):
    return numpy.int32(55)
   if (_a_0=="opfWriteLineLength"):
    return numpy.int32(103)
   if (_a_0=="opfWriteHints"):
    return numpy.int32(102)
   if (_a_0=="opfWriteParameters"):
    return numpy.int32(104)
   if (_a_0=="opfWriteProblem"):
    return numpy.int32(105)
   if (_a_0=="opfWriteHeader"):
    return numpy.int32(101)
   if (_a_0=="opfWriteSolutions"):
    return numpy.int32(109)
   if (_a_0=="opfWriteSolBas"):
    return numpy.int32(106)
   if (_a_0=="opfWriteSolItg"):
    return numpy.int32(107)
   if (_a_0=="opfWriteSolItr"):
    return numpy.int32(108)
   if (_a_0=="ptfWriteTransform"):
    return numpy.int32(126)
   if (_a_0=="ptfWriteSolutions"):
    return numpy.int32(125)
   if (_a_0=="ptfWriteParameters"):
    return numpy.int32(123)
   if (_a_0=="ptfWriteSinglePsdTerms"):
    return numpy.int32(124)
   if (_a_0=="primalRepairOptimizer"):
    return numpy.int32(122)
   if (_a_0=="mioCutCmir"):
    return numpy.int32(63)
   if (_a_0=="mioCutClique"):
    return numpy.int32(62)
   if (_a_0=="mioCutImpliedBound"):
    return numpy.int32(65)
   if (_a_0=="mioCutKnapsackCover"):
    return numpy.int32(66)
   if (_a_0=="mioCutGmi"):
    return numpy.int32(64)
   if (_a_0=="mioCutLipro"):
    return numpy.int32(67)
   if (_a_0=="sensitivityType"):
    return numpy.int32(136)
   if (_a_0=="mioConstructSol"):
    return numpy.int32(60)
   if (_a_0=="presolveLindepRelWorkTrh"):
    return numpy.int32(117)
   if (_a_0=="presolveLindepAbsWorkTrh"):
    return numpy.int32(115)
   if (_a_0=="sensitivityAll"):
    return numpy.int32(135)
   if (_a_0=="logFeasRepair"):
    return numpy.int32(40)
   if (_a_0=="cacheLicense"):
    return numpy.int32(9)
   if (_a_0=="intpntRegularizationUse"):
    return numpy.int32(25)
   if (_a_0=="simSolveForm"):
    return numpy.int32(162)
   if (_a_0=="simSwitchOptimizer"):
    return numpy.int32(163)
   if (_a_0=="writeIgnoreIncompatibleItems"):
    return numpy.int32(175)
   if (_a_0=="autoSortABeforeOpt"):
    return numpy.int32(2)
   if (_a_0=="anaSolBasis"):
    return numpy.int32(0)
   if (_a_0=="anaSolPrintViolated"):
    return numpy.int32(1)
   if (_a_0=="basisSolveUsePlusOne"):
    return numpy.int32(4)
   if (_a_0=="compressStatfile"):
    return numpy.int32(10)
   if (_a_0=="mioRinsMaxNodes"):
    return numpy.int32(92)
   if (_a_0=="mioRensMaxNodes"):
    return numpy.int32(91)
   if (_a_0=="mioCrossoverMaxNodes"):
    return numpy.int32(61)
   if (_a_0=="mioOptFaceMaxNodes"):
    return numpy.int32(85)
   if (_a_0=="mioFeaspumpLevel"):
    return numpy.int32(71)
   if (_a_0=="mioIndependentBlockLevel"):
    return numpy.int32(73)
   if (_a_0=="ng"):
    return numpy.int32(99)
   if (_a_0=="remoteUseCompression"):
    return numpy.int32(133)
   if (_a_0=="getdualConvertLmis"):
    return numpy.int32(12)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iomode_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1iomode_1value_S(_a_0)
  @staticmethod
  def __string_1to_1iomode_1value_S(_a_0):
   if (_a_0=="read"):
    return numpy.int32(0)
   if (_a_0=="write"):
    return numpy.int32(1)
   if (_a_0=="readwrite"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1iinf_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1internal_1iinf_1value_S(_a_0)
  @staticmethod
  def __string_1to_1internal_1iinf_1value_S(_a_0):
   if (_a_0=="versionMajor"):
    return numpy.int32(144)
   if (_a_0=="versionMinor"):
    return numpy.int32(145)
   if (_a_0=="versionRevision"):
    return numpy.int32(146)
   if (_a_0=="presolveLindepWork"):
    return numpy.int32(79)
   if (_a_0=="presolveLindepPivots"):
    return numpy.int32(77)
   if (_a_0=="presolveLindepSkipped"):
    return numpy.int32(78)
   if (_a_0=="presolveNumPrimalLinDepAttempts"):
    return numpy.int32(85)
   if (_a_0=="presolveNumPrimalLinDepSuccessAttempts"):
    return numpy.int32(86)
   if (_a_0=="presolveNumDualLinDepAttempts"):
    return numpy.int32(81)
   if (_a_0=="presolveNumDualLinDepSuccessAttempts"):
    return numpy.int32(82)
   if (_a_0=="presolveOutofspace"):
    return numpy.int32(104)
   if (_a_0=="optObjectiveSense"):
    return numpy.int32(49)
   if (_a_0=="optimizer"):
    return numpy.int32(50)
   if (_a_0=="intpntFirRefIter"):
    return numpy.int32(28)
   if (_a_0=="intpntNumRefSteps"):
    return numpy.int32(33)
   if (_a_0=="intpntFactorSchurNumDup"):
    return numpy.int32(26)
   if (_a_0=="intpntFactorSchurNumBlk"):
    return numpy.int32(25)
   if (_a_0=="intpntFactorSchurMinBlkDim"):
    return numpy.int32(24)
   if (_a_0=="intpntFactorSchurMaxBlkDim"):
    return numpy.int32(23)
   if (_a_0=="intpntFactorSchurNumSingular"):
    return numpy.int32(27)
   if (_a_0=="intpntFactorDim"):
    return numpy.int32(13)
   if (_a_0=="intpntFactorLDim"):
    return numpy.int32(14)
   if (_a_0=="intpntFactorOrderMlLNumDense"):
    return numpy.int32(22)
   if (_a_0=="intpntFactorOrderMlLMaxHeight"):
    return numpy.int32(21)
   if (_a_0=="intpntFactorOrderGpLMaxHeight"):
    return numpy.int32(20)
   if (_a_0=="intpntFactorNumDenseA"):
    return numpy.int32(16)
   if (_a_0=="intpntFactorNumDenseADup"):
    return numpy.int32(17)
   if (_a_0=="intpntFactorNumDenseW"):
    return numpy.int32(18)
   if (_a_0=="intpntNumcon"):
    return numpy.int32(40)
   if (_a_0=="intpntNumvar"):
    return numpy.int32(47)
   if (_a_0=="intpntNumbarvar"):
    return numpy.int32(34)
   if (_a_0=="intpntNumblo"):
    return numpy.int32(37)
   if (_a_0=="intpntNumbup"):
    return numpy.int32(39)
   if (_a_0=="intpntNumbfr"):
    return numpy.int32(35)
   if (_a_0=="intpntNumbfx"):
    return numpy.int32(36)
   if (_a_0=="intpntNumcone"):
    return numpy.int32(41)
   if (_a_0=="intpntNumconevar"):
    return numpy.int32(42)
   if (_a_0=="intpntNumbndcone"):
    return numpy.int32(38)
   if (_a_0=="intpntNumrqcones"):
    return numpy.int32(46)
   if (_a_0=="intpntNumqcones"):
    return numpy.int32(45)
   if (_a_0=="intpntNumpexpcones"):
    return numpy.int32(43)
   if (_a_0=="intpntNumppowcones"):
    return numpy.int32(44)
   if (_a_0=="intpntMinconedim"):
    return numpy.int32(32)
   if (_a_0=="intpntMaxconedim"):
    return numpy.int32(31)
   if (_a_0=="intpntMaxbarvardim"):
    return numpy.int32(30)
   if (_a_0=="presolveNumcon"):
    return numpy.int32(93)
   if (_a_0=="presolveNumcfr"):
    return numpy.int32(89)
   if (_a_0=="presolveNumcfx"):
    return numpy.int32(90)
   if (_a_0=="presolveNumclo"):
    return numpy.int32(91)
   if (_a_0=="presolveNumcup"):
    return numpy.int32(95)
   if (_a_0=="presolveNumcra"):
    return numpy.int32(94)
   if (_a_0=="presolveNumcnl"):
    return numpy.int32(92)
   if (_a_0=="presolveNumvar"):
    return numpy.int32(97)
   if (_a_0=="presolveNumvfr"):
    return numpy.int32(98)
   if (_a_0=="presolveNumvfx"):
    return numpy.int32(99)
   if (_a_0=="presolveNumvlo"):
    return numpy.int32(100)
   if (_a_0=="presolveNumvup"):
    return numpy.int32(103)
   if (_a_0=="presolveNumvra"):
    return numpy.int32(102)
   if (_a_0=="presolveNumvnl"):
    return numpy.int32(101)
   if (_a_0=="presolveNumnza"):
    return numpy.int32(96)
   if (_a_0=="presolveFnumcon"):
    return numpy.int32(60)
   if (_a_0=="presolveFnumcfr"):
    return numpy.int32(56)
   if (_a_0=="presolveFnumcfx"):
    return numpy.int32(57)
   if (_a_0=="presolveFnumclo"):
    return numpy.int32(58)
   if (_a_0=="presolveFnumcup"):
    return numpy.int32(62)
   if (_a_0=="presolveFnumcra"):
    return numpy.int32(61)
   if (_a_0=="presolveFnumcnl"):
    return numpy.int32(59)
   if (_a_0=="presolveFnumvar"):
    return numpy.int32(64)
   if (_a_0=="presolveFnumvfr"):
    return numpy.int32(65)
   if (_a_0=="presolveFnumvfx"):
    return numpy.int32(66)
   if (_a_0=="presolveFnumvlo"):
    return numpy.int32(67)
   if (_a_0=="presolveFnumvup"):
    return numpy.int32(70)
   if (_a_0=="presolveFnumvra"):
    return numpy.int32(69)
   if (_a_0=="presolveFnumvnl"):
    return numpy.int32(68)
   if (_a_0=="presolveFnumnza"):
    return numpy.int32(63)
   if (_a_0=="presolveNumElimns"):
    return numpy.int32(84)
   if (_a_0=="presolveEliNumTries"):
    return numpy.int32(55)
   if (_a_0=="presolveEliNumFreedCon"):
    return numpy.int32(53)
   if (_a_0=="presolveEliNumFreedConTotal"):
    return numpy.int32(54)
   if (_a_0=="presolveLindepNumTries"):
    return numpy.int32(75)
   if (_a_0=="presolveNumPrimalLinDeps"):
    return numpy.int32(87)
   if (_a_0=="presolveNumDualLinDeps"):
    return numpy.int32(83)
   if (_a_0=="presolveForceConNum"):
    return numpy.int32(71)
   if (_a_0=="presolveForceConNumVar"):
    return numpy.int32(72)
   if (_a_0=="presolveForceVarNum"):
    return numpy.int32(73)
   if (_a_0=="presolveForceVarNumCon"):
    return numpy.int32(74)
   if (_a_0=="presolvePivOnConNum"):
    return numpy.int32(105)
   if (_a_0=="presolveNumDouBlocks"):
    return numpy.int32(80)
   if (_a_0=="presolveNumSimplifiedDouBlocks"):
    return numpy.int32(88)
   if (_a_0=="presolveSizeSimplifiedDouBlocks"):
    return numpy.int32(106)
   if (_a_0=="presolveAccNumDupVarInNrmtwo"):
    return numpy.int32(52)
   if (_a_0=="presolveAccNumDoubletonChainInNrmtwo"):
    return numpy.int32(51)
   if (_a_0=="intpntFactorNum"):
    return numpy.int32(15)
   if (_a_0=="intpntFactorNumSolve"):
    return numpy.int32(19)
   if (_a_0=="simplexPrimalHotstartNumBasics"):
    return numpy.int32(134)
   if (_a_0=="simplexPrimalHotstartBasisRank"):
    return numpy.int32(133)
   if (_a_0=="simplexDualHotstartNumBasics"):
    return numpy.int32(128)
   if (_a_0=="simplexDualHotstartBasisRank"):
    return numpy.int32(127)
   if (_a_0=="intpntGpOrderEmployed"):
    return numpy.int32(29)
   if (_a_0=="numLuFactorizations"):
    return numpy.int32(48)
   if (_a_0=="simplexPwlNumPotential"):
    return numpy.int32(140)
   if (_a_0=="simplexPwlNumUsed"):
    return numpy.int32(141)
   if (_a_0=="simplexPwlNumVariables"):
    return numpy.int32(142)
   if (_a_0=="simplexPwlMinNumBreakpoints"):
    return numpy.int32(139)
   if (_a_0=="simplexPwlMaxNumBreakpoints"):
    return numpy.int32(137)
   if (_a_0=="simplexPwlMaxNz"):
    return numpy.int32(138)
   if (_a_0=="simplexPwlNzReduction"):
    return numpy.int32(143)
   if (_a_0=="simplexNumSetbacks"):
    return numpy.int32(131)
   if (_a_0=="simplexPrimalNumSetbacks"):
    return numpy.int32(135)
   if (_a_0=="simplexDualNumSetbacks"):
    return numpy.int32(129)
   if (_a_0=="simplexPrimalFeasNa"):
    return numpy.int32(132)
   if (_a_0=="simplexDualFeasNa"):
    return numpy.int32(126)
   if (_a_0=="simplexPrimalObjNa"):
    return numpy.int32(136)
   if (_a_0=="simplexDualObjNa"):
    return numpy.int32(130)
   if (_a_0=="simNumPrimalBoundswaps"):
    return numpy.int32(125)
   if (_a_0=="simNumDualBoundswaps"):
    return numpy.int32(123)
   if (_a_0=="simNumDualIntegerPivots"):
    return numpy.int32(124)
   if (_a_0=="purifyNumRow"):
    return numpy.int32(117)
   if (_a_0=="purifyNumVar"):
    return numpy.int32(118)
   if (_a_0=="purifyPNumNullRow"):
    return numpy.int32(119)
   if (_a_0=="purifyPNumSingletonCol"):
    return numpy.int32(120)
   if (_a_0=="purifyCrashL11NumRow"):
    return numpy.int32(107)
   if (_a_0=="purifyCrashL22NumRow"):
    return numpy.int32(108)
   if (_a_0=="purifyCrashL33NumRow"):
    return numpy.int32(110)
   if (_a_0=="purifyCrashL33NumCol"):
    return numpy.int32(109)
   if (_a_0=="purifyCrashSingularity"):
    return numpy.int32(111)
   if (_a_0=="purifyPrimalNumBypass"):
    return numpy.int32(122)
   if (_a_0=="purifyPrimalInitNumSuperBasics"):
    return numpy.int32(121)
   if (_a_0=="purifyDualNumBypass"):
    return numpy.int32(116)
   if (_a_0=="purifyDualInitNumSuperBasics"):
    return numpy.int32(115)
   if (_a_0=="purifyDualInitNumBasisRowSingletons"):
    return numpy.int32(113)
   if (_a_0=="purifyDualInitNumBasisColSingletons"):
    return numpy.int32(112)
   if (_a_0=="purifyDualInitNumSuperBasicRowSingletons"):
    return numpy.int32(114)
   if (_a_0=="biPrimalInfo"):
    return numpy.int32(3)
   if (_a_0=="biDualInfo"):
    return numpy.int32(1)
   if (_a_0=="biPrimalFeasInfo"):
    return numpy.int32(2)
   if (_a_0=="biDualFeasInfo"):
    return numpy.int32(0)
   if (_a_0=="presolveLindepNumTruncTries"):
    return numpy.int32(76)
   if (_a_0=="foldingNumvarBefore"):
    return numpy.int32(11)
   if (_a_0=="foldingNumvarAfter"):
    return numpy.int32(10)
   if (_a_0=="foldingNumconBefore"):
    return numpy.int32(9)
   if (_a_0=="foldingNumconAfter"):
    return numpy.int32(8)
   if (_a_0=="foldingStatus"):
    return numpy.int32(12)
   if (_a_0=="foldingBiPrimalFeasInfoIsValid"):
    return numpy.int32(6)
   if (_a_0=="foldingBiPrimalObjInfoIsValid"):
    return numpy.int32(7)
   if (_a_0=="foldingBiDualFeasInfoIsValid"):
    return numpy.int32(4)
   if (_a_0=="foldingBiDualObjInfoIsValid"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1dinf_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1internal_1dinf_1value_S(_a_0)
  @staticmethod
  def __string_1to_1internal_1dinf_1value_S(_a_0):
   if (_a_0=="sensitivityPrimalTime"):
    return numpy.int32(97)
   if (_a_0=="sensitivityDualTime"):
    return numpy.int32(96)
   if (_a_0=="intpntGfeas"):
    return numpy.int32(72)
   if (_a_0=="intpntMu"):
    return numpy.int32(79)
   if (_a_0=="intpntInitIterTime"):
    return numpy.int32(74)
   if (_a_0=="intpntFactorTime"):
    return numpy.int32(70)
   if (_a_0=="intpntInitSearchTime"):
    return numpy.int32(75)
   if (_a_0=="intpntFormSearchTime"):
    return numpy.int32(71)
   if (_a_0=="intpntCorrectorTime"):
    return numpy.int32(17)
   if (_a_0=="intpntUpdateTime"):
    return numpy.int32(84)
   if (_a_0=="intpntFactorSetupTime"):
    return numpy.int32(63)
   if (_a_0=="intpntFactorSchurTime"):
    return numpy.int32(56)
   if (_a_0=="intpntFactorHatSchurTime"):
    return numpy.int32(53)
   if (_a_0=="intpntFactorHatSchurPushTime"):
    return numpy.int32(52)
   if (_a_0=="intpntFactorHatSchurPullTime"):
    return numpy.int32(50)
   if (_a_0=="intpntFactorBarSchurTime"):
    return numpy.int32(22)
   if (_a_0=="intpntFactorBarSchurDeTabTime"):
    return numpy.int32(18)
   if (_a_0=="intpntFactorBarSchurSpTabTime"):
    return numpy.int32(21)
   if (_a_0=="intpntFactorSparseLTime"):
    return numpy.int32(67)
   if (_a_0=="intpntFactorSparseLUpdateLastTime"):
    return numpy.int32(69)
   if (_a_0=="intpntFactorSparseLFactorLastTime"):
    return numpy.int32(65)
   if (_a_0=="intpntFactorDenseLTime"):
    return numpy.int32(45)
   if (_a_0=="intpntFactorDenseTime"):
    return numpy.int32(46)
   if (_a_0=="intpntFactorDenseDotaTime"):
    return numpy.int32(33)
   if (_a_0=="intpntFactorDenseDotaSolveTime"):
    return numpy.int32(32)
   if (_a_0=="intpntFactorDenseDotatdotaTime"):
    return numpy.int32(35)
   if (_a_0=="intpntFactorDenseDotlInitTime"):
    return numpy.int32(42)
   if (_a_0=="intpntFactorDenseDotlFactorTime"):
    return numpy.int32(41)
   if (_a_0=="intpntFactorBarSchurUpdateTime"):
    return numpy.int32(30)
   if (_a_0=="intpntFactorBarSchurUpdateCompressedETime"):
    return numpy.int32(23)
   if (_a_0=="intpntFactorBarSchurUpdateSparseTime"):
    return numpy.int32(29)
   if (_a_0=="intpntFactorBarSchurUpdateSparseSyr2kTime"):
    return numpy.int32(28)
   if (_a_0=="intpntFactorBarSchurUpdateSparseDotTime"):
    return numpy.int32(27)
   if (_a_0=="intpntFactorBarSchurUpdateDenseTime"):
    return numpy.int32(26)
   if (_a_0=="intpntFactorBarSchurUpdateDenseSyr2kTime"):
    return numpy.int32(25)
   if (_a_0=="intpntFactorBarSchurUpdateDenseDotTime"):
    return numpy.int32(24)
   if (_a_0=="intpntFactorBarSchurPushTime"):
    return numpy.int32(20)
   if (_a_0=="intpntIterNonCorrectorFlops"):
    return numpy.int32(76)
   if (_a_0=="intpntIterOneCorrectorFlops"):
    return numpy.int32(77)
   if (_a_0=="intpntSolveTime"):
    return numpy.int32(83)
   if (_a_0=="intpntIterRefTime"):
    return numpy.int32(78)
   if (_a_0=="intpntSolveSparseLTime"):
    return numpy.int32(82)
   if (_a_0=="intpntSolveDenseLTime"):
    return numpy.int32(81)
   if (_a_0=="intpntFactorSetupFlops"):
    return numpy.int32(58)
   if (_a_0=="intpntFactorSetupHatSchurFlops"):
    return numpy.int32(61)
   if (_a_0=="intpntFactorSchurFlops"):
    return numpy.int32(55)
   if (_a_0=="intpntFactorHatSchurFlops"):
    return numpy.int32(48)
   if (_a_0=="intpntFactorHatSchurPushFlops"):
    return numpy.int32(51)
   if (_a_0=="intpntFactorHatSchurPullFlops"):
    return numpy.int32(49)
   if (_a_0=="intpntFactorBarSchurFlops"):
    return numpy.int32(19)
   if (_a_0=="intpntFactorSparseLFlops"):
    return numpy.int32(66)
   if (_a_0=="intpntFactorMlOrderSparseLFlops"):
    return numpy.int32(54)
   if (_a_0=="intpntFactorGpOrderSparseLFlops"):
    return numpy.int32(47)
   if (_a_0=="intpntFactorSparseLUpdateLastFlops"):
    return numpy.int32(68)
   if (_a_0=="intpntFactorSparseLFactorLastFlops"):
    return numpy.int32(64)
   if (_a_0=="intpntFactorDenseLFlops"):
    return numpy.int32(44)
   if (_a_0=="intpntFactorDenseFlops"):
    return numpy.int32(43)
   if (_a_0=="intpntFactorDenseDotaFlops"):
    return numpy.int32(31)
   if (_a_0=="intpntFactorDenseDotatdotaFlops"):
    return numpy.int32(34)
   if (_a_0=="intpntFactorDenseDotlFactor_initFlops"):
    return numpy.int32(39)
   if (_a_0=="intpntFactorDenseDotlFactorFlops"):
    return numpy.int32(40)
   if (_a_0=="intpntFactorDenseDotl11FactorFlops"):
    return numpy.int32(36)
   if (_a_0=="intpntFactorDenseDotl21FactorFlops"):
    return numpy.int32(37)
   if (_a_0=="intpntFactorDenseDotl22FactorFlops"):
    return numpy.int32(38)
   if (_a_0=="presolvePrimalLinDepTime"):
    return numpy.int32(91)
   if (_a_0=="presolveDualLinDepTime"):
    return numpy.int32(87)
   if (_a_0=="presolveAcoltTime"):
    return numpy.int32(85)
   if (_a_0=="presolveSetupTime"):
    return numpy.int32(92)
   if (_a_0=="presolveCheckproTime"):
    return numpy.int32(86)
   if (_a_0=="presolveDupconTime"):
    return numpy.int32(88)
   if (_a_0=="presolveDupvarTime"):
    return numpy.int32(89)
   if (_a_0=="presolveFinalTime"):
    return numpy.int32(90)
   if (_a_0=="presolveSubDomvarTime"):
    return numpy.int32(93)
   if (_a_0=="presolveSubRelaxTime"):
    return numpy.int32(94)
   if (_a_0=="primalSimplexInftime"):
    return numpy.int32(95)
   if (_a_0=="dualSimplexInftime"):
    return numpy.int32(10)
   if (_a_0=="intpntGpOrderSavedFlops"):
    return numpy.int32(73)
   if (_a_0=="intpntFactorSetupDetectDenseTime"):
    return numpy.int32(57)
   if (_a_0=="intpntFactorSetupMlOrderTime"):
    return numpy.int32(62)
   if (_a_0=="intpntFactorSetupGpOrderTime"):
    return numpy.int32(60)
   if (_a_0=="intpntFactorSetupGpOrderPostTime"):
    return numpy.int32(59)
   if (_a_0=="biInitTime"):
    return numpy.int32(5)
   if (_a_0=="biFactorTime"):
    return numpy.int32(3)
   if (_a_0=="biFactorWork"):
    return numpy.int32(4)
   if (_a_0=="biPrimalDone"):
    return numpy.int32(7)
   if (_a_0=="biDualDone"):
    return numpy.int32(0)
   if (_a_0=="simplexBasiscondition"):
    return numpy.int32(98)
   if (_a_0=="simplexPrimalObj"):
    return numpy.int32(102)
   if (_a_0=="simplexPrimalFeas"):
    return numpy.int32(101)
   if (_a_0=="simplexDualObj"):
    return numpy.int32(100)
   if (_a_0=="simplexDualFeas"):
    return numpy.int32(99)
   if (_a_0=="biInitialBasisCond"):
    return numpy.int32(6)
   if (_a_0=="biPrimalObj"):
    return numpy.int32(9)
   if (_a_0=="biDualObj"):
    return numpy.int32(2)
   if (_a_0=="biPrimalFeas"):
    return numpy.int32(8)
   if (_a_0=="biDualFeas"):
    return numpy.int32(1)
   if (_a_0=="intpntPurifyTime"):
    return numpy.int32(80)
   if (_a_0=="foldingUniqueNzRatio"):
    return numpy.int32(16)
   if (_a_0=="foldingBiCrashTime"):
    return numpy.int32(11)
   if (_a_0=="foldingBiOptimizerPrimalFeas"):
    return numpy.int32(14)
   if (_a_0=="foldingBiOptimizerPrimalObj"):
    return numpy.int32(15)
   if (_a_0=="foldingBiOptimizerDualFeas"):
    return numpy.int32(12)
   if (_a_0=="foldingBiOptimizerDualObj"):
    return numpy.int32(13)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1inftype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1inftype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1inftype_1value_S(_a_0):
   if (_a_0=="douType"):
    return numpy.int32(0)
   if (_a_0=="intType"):
    return numpy.int32(1)
   if (_a_0=="lintType"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iinfitem_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1iinfitem_1value_S(_a_0)
  @staticmethod
  def __string_1to_1iinfitem_1value_S(_a_0):
   if (_a_0=="anaProNumCon"):
    return numpy.int32(0)
   if (_a_0=="anaProNumConLo"):
    return numpy.int32(3)
   if (_a_0=="anaProNumConUp"):
    return numpy.int32(5)
   if (_a_0=="anaProNumConRa"):
    return numpy.int32(4)
   if (_a_0=="anaProNumConEq"):
    return numpy.int32(1)
   if (_a_0=="anaProNumConFr"):
    return numpy.int32(2)
   if (_a_0=="anaProNumVar"):
    return numpy.int32(6)
   if (_a_0=="anaProNumVarLo"):
    return numpy.int32(12)
   if (_a_0=="anaProNumVarUp"):
    return numpy.int32(14)
   if (_a_0=="anaProNumVarRa"):
    return numpy.int32(13)
   if (_a_0=="anaProNumVarEq"):
    return numpy.int32(9)
   if (_a_0=="anaProNumVarFr"):
    return numpy.int32(10)
   if (_a_0=="anaProNumVarCont"):
    return numpy.int32(8)
   if (_a_0=="anaProNumVarBin"):
    return numpy.int32(7)
   if (_a_0=="anaProNumVarInt"):
    return numpy.int32(11)
   if (_a_0=="optimizeResponse"):
    return numpy.int32(106)
   if (_a_0=="presolveNumPrimalPerturbations"):
    return numpy.int32(107)
   if (_a_0=="intpntIter"):
    return numpy.int32(17)
   if (_a_0=="intpntFactorDimDense"):
    return numpy.int32(16)
   if (_a_0=="intpntSolveDual"):
    return numpy.int32(19)
   if (_a_0=="mioNodeDepth"):
    return numpy.int32(41)
   if (_a_0=="mioNumvar"):
    return numpy.int32(81)
   if (_a_0=="mioNumbin"):
    return numpy.int32(65)
   if (_a_0=="mioNumint"):
    return numpy.int32(75)
   if (_a_0=="mioNumcont"):
    return numpy.int32(70)
   if (_a_0=="mioNumcon"):
    return numpy.int32(67)
   if (_a_0=="mioNumcone"):
    return numpy.int32(68)
   if (_a_0=="mioNumqcones"):
    return numpy.int32(79)
   if (_a_0=="mioNumrqcones"):
    return numpy.int32(80)
   if (_a_0=="mioNumpexpcones"):
    return numpy.int32(77)
   if (_a_0=="mioNumdexpcones"):
    return numpy.int32(72)
   if (_a_0=="mioNumppowcones"):
    return numpy.int32(78)
   if (_a_0=="mioNumdpowcones"):
    return numpy.int32(74)
   if (_a_0=="mioNumconevar"):
    return numpy.int32(69)
   if (_a_0=="mioNumbinconevar"):
    return numpy.int32(66)
   if (_a_0=="mioNumintconevar"):
    return numpy.int32(76)
   if (_a_0=="mioNumcontconevar"):
    return numpy.int32(71)
   if (_a_0=="mioNumdjc"):
    return numpy.int32(73)
   if (_a_0=="mioPresolvedNumvar"):
    return numpy.int32(99)
   if (_a_0=="mioPresolvedNumbin"):
    return numpy.int32(83)
   if (_a_0=="mioPresolvedNumint"):
    return numpy.int32(93)
   if (_a_0=="mioPresolvedNumcont"):
    return numpy.int32(88)
   if (_a_0=="mioPresolvedNumcon"):
    return numpy.int32(85)
   if (_a_0=="mioPresolvedNumcone"):
    return numpy.int32(86)
   if (_a_0=="mioPresolvedNumqcones"):
    return numpy.int32(97)
   if (_a_0=="mioPresolvedNumrqcones"):
    return numpy.int32(98)
   if (_a_0=="mioPresolvedNumpexpcones"):
    return numpy.int32(95)
   if (_a_0=="mioPresolvedNumdexpcones"):
    return numpy.int32(90)
   if (_a_0=="mioPresolvedNumppowcones"):
    return numpy.int32(96)
   if (_a_0=="mioPresolvedNumdpowcones"):
    return numpy.int32(92)
   if (_a_0=="mioPresolvedNumconevar"):
    return numpy.int32(87)
   if (_a_0=="mioPresolvedNumbinconevar"):
    return numpy.int32(84)
   if (_a_0=="mioPresolvedNumintconevar"):
    return numpy.int32(94)
   if (_a_0=="mioPresolvedNumcontconevar"):
    return numpy.int32(89)
   if (_a_0=="mioPresolvedNumdjc"):
    return numpy.int32(91)
   if (_a_0=="mioFinalNumvar"):
    return numpy.int32(39)
   if (_a_0=="mioFinalNumbin"):
    return numpy.int32(23)
   if (_a_0=="mioFinalNumint"):
    return numpy.int32(33)
   if (_a_0=="mioFinalNumcont"):
    return numpy.int32(28)
   if (_a_0=="mioFinalNumcon"):
    return numpy.int32(25)
   if (_a_0=="mioFinalNumcone"):
    return numpy.int32(26)
   if (_a_0=="mioFinalNumqcones"):
    return numpy.int32(37)
   if (_a_0=="mioFinalNumrqcones"):
    return numpy.int32(38)
   if (_a_0=="mioFinalNumpexpcones"):
    return numpy.int32(35)
   if (_a_0=="mioFinalNumdexpcones"):
    return numpy.int32(30)
   if (_a_0=="mioFinalNumppowcones"):
    return numpy.int32(36)
   if (_a_0=="mioFinalNumdpowcones"):
    return numpy.int32(32)
   if (_a_0=="mioFinalNumconevar"):
    return numpy.int32(27)
   if (_a_0=="mioFinalNumbinconevar"):
    return numpy.int32(24)
   if (_a_0=="mioFinalNumintconevar"):
    return numpy.int32(34)
   if (_a_0=="mioFinalNumcontconevar"):
    return numpy.int32(29)
   if (_a_0=="mioFinalNumdjc"):
    return numpy.int32(31)
   if (_a_0=="mioCliqueTableSize"):
    return numpy.int32(21)
   if (_a_0=="mioConstructSolution"):
    return numpy.int32(22)
   if (_a_0=="mioInitialFeasibleSolution"):
    return numpy.int32(40)
   if (_a_0=="mioNumIntSolutions"):
    return numpy.int32(47)
   if (_a_0=="mioObjBoundDefined"):
    return numpy.int32(82)
   if (_a_0=="mioNumActiveNodes"):
    return numpy.int32(42)
   if (_a_0=="mioNumRelax"):
    return numpy.int32(48)
   if (_a_0=="mioNumSolvedNodes"):
    return numpy.int32(64)
   if (_a_0=="mioNumBranch"):
    return numpy.int32(46)
   if (_a_0=="mioNumRestarts"):
    return numpy.int32(50)
   if (_a_0=="mioNumRootCutRounds"):
    return numpy.int32(51)
   if (_a_0=="mioNumActiveRootCuts"):
    return numpy.int32(43)
   if (_a_0=="mioTotalNumSelectedCuts"):
    return numpy.int32(101)
   if (_a_0=="mioNumSelectedCmirCuts"):
    return numpy.int32(53)
   if (_a_0=="mioNumSelectedCliqueCuts"):
    return numpy.int32(52)
   if (_a_0=="mioNumSelectedImpliedBoundCuts"):
    return numpy.int32(55)
   if (_a_0=="mioNumSelectedKnapsackCoverCuts"):
    return numpy.int32(56)
   if (_a_0=="mioNumSelectedGomoryCuts"):
    return numpy.int32(54)
   if (_a_0=="mioNumSelectedLiproCuts"):
    return numpy.int32(57)
   if (_a_0=="mioTotalNumSeparatedCuts"):
    return numpy.int32(102)
   if (_a_0=="mioNumSeparatedCmirCuts"):
    return numpy.int32(59)
   if (_a_0=="mioNumSeparatedCliqueCuts"):
    return numpy.int32(58)
   if (_a_0=="mioNumSeparatedImpliedBoundCuts"):
    return numpy.int32(61)
   if (_a_0=="mioNumSeparatedKnapsackCoverCuts"):
    return numpy.int32(62)
   if (_a_0=="mioNumSeparatedGomoryCuts"):
    return numpy.int32(60)
   if (_a_0=="mioNumSeparatedLiproCuts"):
    return numpy.int32(63)
   if (_a_0=="mioNumRepeatedPresolve"):
    return numpy.int32(49)
   if (_a_0=="mioNumBlocksSolvedInPresolve"):
    return numpy.int32(45)
   if (_a_0=="mioNumBlocksSolvedInBb"):
    return numpy.int32(44)
   if (_a_0=="mioUserObjCut"):
    return numpy.int32(103)
   if (_a_0=="mioRelgapSatisfied"):
    return numpy.int32(100)
   if (_a_0=="mioAbsgapSatisfied"):
    return numpy.int32(20)
   if (_a_0=="foldingApplied"):
    return numpy.int32(15)
   if (_a_0=="rdProtype"):
    return numpy.int32(116)
   if (_a_0=="rdNumcon"):
    return numpy.int32(111)
   if (_a_0=="rdNumvar"):
    return numpy.int32(115)
   if (_a_0=="rdNumbarvar"):
    return numpy.int32(110)
   if (_a_0=="rdNumintvar"):
    return numpy.int32(113)
   if (_a_0=="rdNumq"):
    return numpy.int32(114)
   if (_a_0=="simDualDegIter"):
    return numpy.int32(117)
   if (_a_0=="simDualInfIter"):
    return numpy.int32(120)
   if (_a_0=="simDualHotstartLu"):
    return numpy.int32(119)
   if (_a_0=="simPrimalIter"):
    return numpy.int32(128)
   if (_a_0=="simDualIter"):
    return numpy.int32(121)
   if (_a_0=="intpntNumThreads"):
    return numpy.int32(18)
   if (_a_0=="simPrimalInfIter"):
    return numpy.int32(127)
   if (_a_0=="simPrimalDegIter"):
    return numpy.int32(124)
   if (_a_0=="simPrimalHotstart"):
    return numpy.int32(125)
   if (_a_0=="simPrimalHotstartLu"):
    return numpy.int32(126)
   if (_a_0=="simDualHotstart"):
    return numpy.int32(118)
   if (_a_0=="solItrProsta"):
    return numpy.int32(134)
   if (_a_0=="solItrSolsta"):
    return numpy.int32(135)
   if (_a_0=="solBasProsta"):
    return numpy.int32(130)
   if (_a_0=="solBasSolsta"):
    return numpy.int32(131)
   if (_a_0=="solItgProsta"):
    return numpy.int32(132)
   if (_a_0=="solItgSolsta"):
    return numpy.int32(133)
   if (_a_0=="simNumcon"):
    return numpy.int32(122)
   if (_a_0=="simNumvar"):
    return numpy.int32(123)
   if (_a_0=="optNumcon"):
    return numpy.int32(104)
   if (_a_0=="optNumvar"):
    return numpy.int32(105)
   if (_a_0=="stoNumARealloc"):
    return numpy.int32(136)
   if (_a_0=="rdNumcone"):
    return numpy.int32(112)
   if (_a_0=="simSolveDual"):
    return numpy.int32(129)
   if (_a_0=="purifyPrimalSuccess"):
    return numpy.int32(109)
   if (_a_0=="purifyDualSuccess"):
    return numpy.int32(108)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1liinf_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1internal_1liinf_1value_S(_a_0)
  @staticmethod
  def __string_1to_1internal_1liinf_1value_S(_a_0):
   if (_a_0=="intpntLenbarvar"):
    return numpy.int32(8)
   if (_a_0=="presolveStackSize"):
    return numpy.int32(9)
   if (_a_0=="intpntFactorNumNzBefore"):
    return numpy.int32(7)
   if (_a_0=="intpntFactorNumNzAfter"):
    return numpy.int32(6)
   if (_a_0=="intpntFactorGpOrderSavedNzs"):
    return numpy.int32(5)
   if (_a_0=="simplexPrimalIter"):
    return numpy.int32(28)
   if (_a_0=="simplexDualIter"):
    return numpy.int32(10)
   if (_a_0=="simplexDualpurifyIter"):
    return numpy.int32(12)
   if (_a_0=="simplexTicks"):
    return numpy.int32(30)
   if (_a_0=="simplexPrimalTicks"):
    return numpy.int32(29)
   if (_a_0=="simplexDualTicks"):
    return numpy.int32(11)
   if (_a_0=="simplexNumGradfreeze"):
    return numpy.int32(20)
   if (_a_0=="simplexNumMovelock"):
    return numpy.int32(21)
   if (_a_0=="simplexNumDualIllposedCer"):
    return numpy.int32(16)
   if (_a_0=="simplexNumCand"):
    return numpy.int32(15)
   if (_a_0=="simplexNumProgressStall"):
    return numpy.int32(24)
   if (_a_0=="simplexNumRejectStepvalue"):
    return numpy.int32(26)
   if (_a_0=="simplexNumRejectPivot"):
    return numpy.int32(25)
   if (_a_0=="simplexNumSingularBases"):
    return numpy.int32(27)
   if (_a_0=="simplexNumFatalFeasibilityLoss"):
    return numpy.int32(17)
   if (_a_0=="simplexNumFatalGradientStall"):
    return numpy.int32(18)
   if (_a_0=="simplexNumFatalPurificationStall"):
    return numpy.int32(19)
   if (_a_0=="simplexNumPrematureGradscoreweightsInit"):
    return numpy.int32(23)
   if (_a_0=="simplexNumPrecisionBoost"):
    return numpy.int32(22)
   if (_a_0=="simplexLuFactorTicks"):
    return numpy.int32(13)
   if (_a_0=="simplexLuSolveTicks"):
    return numpy.int32(14)
   if (_a_0=="foldingTicks"):
    return numpy.int32(4)
   if (_a_0=="foldingNnzBefore"):
    return numpy.int32(2)
   if (_a_0=="foldingNnzAfter"):
    return numpy.int32(1)
   if (_a_0=="foldingNnzTouched"):
    return numpy.int32(3)
   if (_a_0=="foldingBiUnfoldIter"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1liinfitem_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1liinfitem_1value_S(_a_0)
  @staticmethod
  def __string_1to_1liinfitem_1value_S(_a_0):
   if (_a_0=="anaProScalarizedConstraintMatrixNumRows"):
    return numpy.int32(2)
   if (_a_0=="anaProScalarizedConstraintMatrixNumColumns"):
    return numpy.int32(0)
   if (_a_0=="anaProScalarizedConstraintMatrixNumNz"):
    return numpy.int32(1)
   if (_a_0=="mioAnz"):
    return numpy.int32(10)
   if (_a_0=="mioPresolvedAnz"):
    return numpy.int32(15)
   if (_a_0=="mioFinalAnz"):
    return numpy.int32(11)
   if (_a_0=="mioSimplexIter"):
    return numpy.int32(16)
   if (_a_0=="mioIntpntIter"):
    return numpy.int32(12)
   if (_a_0=="mioNumPrimIllposedCer"):
    return numpy.int32(14)
   if (_a_0=="mioNumDualIllposedCer"):
    return numpy.int32(13)
   if (_a_0=="biPrimalIter"):
    return numpy.int32(5)
   if (_a_0=="biDualIter"):
    return numpy.int32(4)
   if (_a_0=="biCleanIter"):
    return numpy.int32(3)
   if (_a_0=="intpntFactorNumNz"):
    return numpy.int32(9)
   if (_a_0=="foldingBiPrimalIter"):
    return numpy.int32(8)
   if (_a_0=="foldingBiDualIter"):
    return numpy.int32(6)
   if (_a_0=="foldingBiOptimizerIter"):
    return numpy.int32(7)
   if (_a_0=="rdNumacc"):
    return numpy.int32(17)
   if (_a_0=="rdNumdjc"):
    return numpy.int32(19)
   if (_a_0=="rdNumanz"):
    return numpy.int32(18)
   if (_a_0=="rdNumqnz"):
    return numpy.int32(20)
   if (_a_0=="simplexIter"):
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dparam_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1dparam_1value_S(_a_0)
  @staticmethod
  def __string_1to_1dparam_1value_S(_a_0):
   if (_a_0=="dataTolCjLarge"):
    return numpy.int32(12)
   if (_a_0=="dataTolCHuge"):
    return numpy.int32(11)
   if (_a_0=="dataTolAijLarge"):
    return numpy.int32(8)
   if (_a_0=="dataTolAijHuge"):
    return numpy.int32(7)
   if (_a_0=="dataSymMatTol"):
    return numpy.int32(4)
   if (_a_0=="dataSymMatTolLarge"):
    return numpy.int32(6)
   if (_a_0=="dataSymMatTolHuge"):
    return numpy.int32(5)
   if (_a_0=="dataTolBoundInf"):
    return numpy.int32(9)
   if (_a_0=="dataTolBoundWrn"):
    return numpy.int32(10)
   if (_a_0=="dataTolQij"):
    return numpy.int32(13)
   if (_a_0=="dataTolX"):
    return numpy.int32(14)
   if (_a_0=="semidefiniteTolApprox"):
    return numpy.int32(57)
   if (_a_0=="optimizerMaxTime"):
    return numpy.int32(50)
   if (_a_0=="optimizerMaxTicks"):
    return numpy.int32(49)
   if (_a_0=="lowerObjCut"):
    return numpy.int32(38)
   if (_a_0=="upperObjCut"):
    return numpy.int32(62)
   if (_a_0=="upperObjCutFiniteTrh"):
    return numpy.int32(63)
   if (_a_0=="lowerObjCutFiniteTrh"):
    return numpy.int32(39)
   if (_a_0=="intpntTolRelGap"):
    return numpy.int32(35)
   if (_a_0=="intpntTolStepSize"):
    return numpy.int32(37)
   if (_a_0=="simLuTolRelPiv"):
    return numpy.int32(58)
   if (_a_0=="intpntTolRelStep"):
    return numpy.int32(36)
   if (_a_0=="intpntTolPath"):
    return numpy.int32(32)
   if (_a_0=="intpntTolPfeas"):
    return numpy.int32(33)
   if (_a_0=="intpntTolDfeas"):
    return numpy.int32(28)
   if (_a_0=="intpntTolMuRed"):
    return numpy.int32(31)
   if (_a_0=="intpntTolInfeas"):
    return numpy.int32(30)
   if (_a_0=="intpntCoTolRelGap"):
    return numpy.int32(21)
   if (_a_0=="intpntCoTolPfeas"):
    return numpy.int32(20)
   if (_a_0=="intpntCoTolDfeas"):
    return numpy.int32(16)
   if (_a_0=="intpntCoTolMuRed"):
    return numpy.int32(18)
   if (_a_0=="intpntCoTolNearRel"):
    return numpy.int32(19)
   if (_a_0=="intpntCoTolInfeas"):
    return numpy.int32(17)
   if (_a_0=="intpntQoTolRelGap"):
    return numpy.int32(27)
   if (_a_0=="intpntQoTolPfeas"):
    return numpy.int32(26)
   if (_a_0=="intpntQoTolDfeas"):
    return numpy.int32(22)
   if (_a_0=="intpntQoTolMuRed"):
    return numpy.int32(24)
   if (_a_0=="intpntQoTolNearRel"):
    return numpy.int32(25)
   if (_a_0=="intpntQoTolInfeas"):
    return numpy.int32(23)
   if (_a_0=="intpntTolPsafe"):
    return numpy.int32(34)
   if (_a_0=="intpntTolDsafe"):
    return numpy.int32(29)
   if (_a_0=="mioMaxTime"):
    return numpy.int32(42)
   if (_a_0=="mioRelGapConst"):
    return numpy.int32(43)
   if (_a_0=="mioTolRelGap"):
    return numpy.int32(48)
   if (_a_0=="mioTolAbsGap"):
    return numpy.int32(44)
   if (_a_0=="mioTolAbsRelaxInt"):
    return numpy.int32(45)
   if (_a_0=="mioDjcMaxBigm"):
    return numpy.int32(41)
   if (_a_0=="mioCliqueTableSizeFactor"):
    return numpy.int32(40)
   if (_a_0=="simPrecisionScalingNormal"):
    return numpy.int32(60)
   if (_a_0=="simPrecisionScalingExtended"):
    return numpy.int32(59)
   if (_a_0=="basisTolX"):
    return numpy.int32(3)
   if (_a_0=="basisTolS"):
    return numpy.int32(2)
   if (_a_0=="basisRelTolS"):
    return numpy.int32(1)
   if (_a_0=="presolveTolX"):
    return numpy.int32(55)
   if (_a_0=="presolveTolPrimalInfeasPerturbation"):
    return numpy.int32(52)
   if (_a_0=="presolveTolS"):
    return numpy.int32(54)
   if (_a_0=="presolveTolAbsLindep"):
    return numpy.int32(51)
   if (_a_0=="presolveTolRelLindep"):
    return numpy.int32(53)
   if (_a_0=="foldingTolEq"):
    return numpy.int32(15)
   if (_a_0=="simplexAbsTolPiv"):
    return numpy.int32(61)
   if (_a_0=="mioTolFeas"):
    return numpy.int32(46)
   if (_a_0=="anaSolInfeasTol"):
    return numpy.int32(0)
   if (_a_0=="qcqoReformulateRelDropTol"):
    return numpy.int32(56)
   if (_a_0=="mioTolRelDualBoundImprovement"):
    return numpy.int32(47)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1feature_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1feature_1value_S(_a_0)
  @staticmethod
  def __string_1to_1feature_1value_S(_a_0):
   if (_a_0=="pts"):
    return numpy.int32(0)
   if (_a_0=="pton"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dinfitem_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1dinfitem_1value_S(_a_0)
  @staticmethod
  def __string_1to_1dinfitem_1value_S(_a_0):
   if (_a_0=="anaProScalarizedConstraintMatrixDensity"):
    return numpy.int32(0)
   if (_a_0=="biTime"):
    return numpy.int32(4)
   if (_a_0=="biPrimalTime"):
    return numpy.int32(3)
   if (_a_0=="biDualTime"):
    return numpy.int32(2)
   if (_a_0=="biCleanTime"):
    return numpy.int32(1)
   if (_a_0=="foldingBiUnfoldInitializeTime"):
    return numpy.int32(7)
   if (_a_0=="foldingBiUnfoldPrimalTime"):
    return numpy.int32(8)
   if (_a_0=="foldingBiUnfoldDualTime"):
    return numpy.int32(6)
   if (_a_0=="foldingBiOptimizeTime"):
    return numpy.int32(5)
   if (_a_0=="foldingBiUnfoldTime"):
    return numpy.int32(9)
   if (_a_0=="intpntTime"):
    return numpy.int32(19)
   if (_a_0=="intpntOrderTime"):
    return numpy.int32(16)
   if (_a_0=="intpntPrimalObj"):
    return numpy.int32(18)
   if (_a_0=="intpntDualObj"):
    return numpy.int32(13)
   if (_a_0=="intpntPrimalFeas"):
    return numpy.int32(17)
   if (_a_0=="intpntDualFeas"):
    return numpy.int32(12)
   if (_a_0=="intpntOptStatus"):
    return numpy.int32(15)
   if (_a_0=="simTime"):
    return numpy.int32(66)
   if (_a_0=="simPrimalTime"):
    return numpy.int32(65)
   if (_a_0=="simDualTime"):
    return numpy.int32(62)
   if (_a_0=="simObj"):
    return numpy.int32(64)
   if (_a_0=="simFeas"):
    return numpy.int32(63)
   if (_a_0=="mioTime"):
    return numpy.int32(47)
   if (_a_0=="mioRootPresolveTime"):
    return numpy.int32(43)
   if (_a_0=="mioRootOptimizerTime"):
    return numpy.int32(42)
   if (_a_0=="mioRootTime"):
    return numpy.int32(44)
   if (_a_0=="toConicTime"):
    return numpy.int32(114)
   if (_a_0=="mioConstructSolutionObj"):
    return numpy.int32(24)
   if (_a_0=="mioInitialFeasibleSolutionObj"):
    return numpy.int32(30)
   if (_a_0=="mioObjInt"):
    return numpy.int32(37)
   if (_a_0=="mioObjBound"):
    return numpy.int32(36)
   if (_a_0=="mioObjRelGap"):
    return numpy.int32(38)
   if (_a_0=="mioObjAbsGap"):
    return numpy.int32(35)
   if (_a_0=="mioUserObjCut"):
    return numpy.int32(48)
   if (_a_0=="mioCmirSeparationTime"):
    return numpy.int32(23)
   if (_a_0=="mioCliqueSeparationTime"):
    return numpy.int32(21)
   if (_a_0=="mioKnapsackCoverSeparationTime"):
    return numpy.int32(32)
   if (_a_0=="mioGmiSeparationTime"):
    return numpy.int32(27)
   if (_a_0=="mioImpliedBoundSeparationTime"):
    return numpy.int32(29)
   if (_a_0=="mioLiproSeparationTime"):
    return numpy.int32(34)
   if (_a_0=="mioRootCutSeparationTime"):
    return numpy.int32(41)
   if (_a_0=="mioCmirSelectionTime"):
    return numpy.int32(22)
   if (_a_0=="mioCliqueSelectionTime"):
    return numpy.int32(20)
   if (_a_0=="mioKnapsackCoverSelectionTime"):
    return numpy.int32(31)
   if (_a_0=="mioGmiSelectionTime"):
    return numpy.int32(26)
   if (_a_0=="mioImpliedBoundSelectionTime"):
    return numpy.int32(28)
   if (_a_0=="mioLiproSelectionTime"):
    return numpy.int32(33)
   if (_a_0=="mioRootCutSelectionTime"):
    return numpy.int32(40)
   if (_a_0=="mioProbingTime"):
    return numpy.int32(39)
   if (_a_0=="mioSymmetryDetectionTime"):
    return numpy.int32(45)
   if (_a_0=="optimizerTime"):
    return numpy.int32(50)
   if (_a_0=="optimizerTicks"):
    return numpy.int32(49)
   if (_a_0=="presolveTime"):
    return numpy.int32(53)
   if (_a_0=="mioSymmetryFactor"):
    return numpy.int32(46)
   if (_a_0=="mioDualBoundAfterPresolve"):
    return numpy.int32(25)
   if (_a_0=="presolveEliTime"):
    return numpy.int32(51)
   if (_a_0=="presolveLindepTime"):
    return numpy.int32(52)
   if (_a_0=="foldingTime"):
    return numpy.int32(11)
   if (_a_0=="foldingFactor"):
    return numpy.int32(10)
   if (_a_0=="readDataTime"):
    return numpy.int32(60)
   if (_a_0=="writeDataTime"):
    return numpy.int32(115)
   if (_a_0=="solItrPrimalObj"):
    return numpy.int32(108)
   if (_a_0=="solItrPviolcon"):
    return numpy.int32(111)
   if (_a_0=="solItrPviolvar"):
    return numpy.int32(113)
   if (_a_0=="solItrPviolbarvar"):
    return numpy.int32(110)
   if (_a_0=="solItrPviolcones"):
    return numpy.int32(112)
   if (_a_0=="solItrPviolacc"):
    return numpy.int32(109)
   if (_a_0=="solItrDualObj"):
    return numpy.int32(92)
   if (_a_0=="solItrDviolcon"):
    return numpy.int32(95)
   if (_a_0=="solItrDviolvar"):
    return numpy.int32(97)
   if (_a_0=="solItrDviolbarvar"):
    return numpy.int32(94)
   if (_a_0=="solItrDviolcones"):
    return numpy.int32(96)
   if (_a_0=="solItrDviolacc"):
    return numpy.int32(93)
   if (_a_0=="solItrNrmXc"):
    return numpy.int32(105)
   if (_a_0=="solItrNrmXx"):
    return numpy.int32(106)
   if (_a_0=="solItrNrmBarx"):
    return numpy.int32(99)
   if (_a_0=="solItrNrmY"):
    return numpy.int32(107)
   if (_a_0=="solItrNrmSlc"):
    return numpy.int32(100)
   if (_a_0=="solItrNrmSuc"):
    return numpy.int32(103)
   if (_a_0=="solItrNrmSlx"):
    return numpy.int32(101)
   if (_a_0=="solItrNrmSux"):
    return numpy.int32(104)
   if (_a_0=="solItrNrmSnx"):
    return numpy.int32(102)
   if (_a_0=="solItrNrmBars"):
    return numpy.int32(98)
   if (_a_0=="solBasPrimalObj"):
    return numpy.int32(78)
   if (_a_0=="solBasPviolcon"):
    return numpy.int32(79)
   if (_a_0=="solBasPviolvar"):
    return numpy.int32(80)
   if (_a_0=="solBasDualObj"):
    return numpy.int32(67)
   if (_a_0=="solBasDviolcon"):
    return numpy.int32(68)
   if (_a_0=="solBasDviolvar"):
    return numpy.int32(69)
   if (_a_0=="solBasNrmXc"):
    return numpy.int32(75)
   if (_a_0=="solBasNrmXx"):
    return numpy.int32(76)
   if (_a_0=="solBasNrmBarx"):
    return numpy.int32(70)
   if (_a_0=="solBasNrmY"):
    return numpy.int32(77)
   if (_a_0=="solBasNrmSlc"):
    return numpy.int32(71)
   if (_a_0=="solBasNrmSuc"):
    return numpy.int32(73)
   if (_a_0=="solBasNrmSlx"):
    return numpy.int32(72)
   if (_a_0=="solBasNrmSux"):
    return numpy.int32(74)
   if (_a_0=="solItgPrimalObj"):
    return numpy.int32(84)
   if (_a_0=="solItgPviolcon"):
    return numpy.int32(87)
   if (_a_0=="solItgPviolvar"):
    return numpy.int32(91)
   if (_a_0=="solItgPviolbarvar"):
    return numpy.int32(86)
   if (_a_0=="solItgPviolcones"):
    return numpy.int32(88)
   if (_a_0=="solItgPviolacc"):
    return numpy.int32(85)
   if (_a_0=="solItgPviolitg"):
    return numpy.int32(90)
   if (_a_0=="solItgPvioldjc"):
    return numpy.int32(89)
   if (_a_0=="solItgNrmXc"):
    return numpy.int32(82)
   if (_a_0=="solItgNrmXx"):
    return numpy.int32(83)
   if (_a_0=="solItgNrmBarx"):
    return numpy.int32(81)
   if (_a_0=="presolveTotalPrimalPerturbation"):
    return numpy.int32(54)
   if (_a_0=="intpntFactorNumFlops"):
    return numpy.int32(14)
   if (_a_0=="qcqoReformulateTime"):
    return numpy.int32(57)
   if (_a_0=="qcqoReformulateMaxPerturbation"):
    return numpy.int32(56)
   if (_a_0=="qcqoReformulateWorstCholeskyDiagScaling"):
    return numpy.int32(59)
   if (_a_0=="qcqoReformulateWorstCholeskyColumnScaling"):
    return numpy.int32(58)
   if (_a_0=="primalRepairPenaltyObj"):
    return numpy.int32(55)
   if (_a_0=="remoteTime"):
    return numpy.int32(61)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solformat_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1solformat_1value_S(_a_0)
  @staticmethod
  def __string_1to_1solformat_1value_S(_a_0):
   if (_a_0=="extension"):
    return numpy.int32(0)
   if (_a_0=="b"):
    return numpy.int32(1)
   if (_a_0=="task"):
    return numpy.int32(2)
   if (_a_0=="jsonTask"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dataformat_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1dataformat_1value_S(_a_0)
  @staticmethod
  def __string_1to_1dataformat_1value_S(_a_0):
   if (_a_0=="extension"):
    return numpy.int32(0)
   if (_a_0=="mps"):
    return numpy.int32(1)
   if (_a_0=="lp"):
    return numpy.int32(2)
   if (_a_0=="op"):
    return numpy.int32(3)
   if (_a_0=="freeMps"):
    return numpy.int32(4)
   if (_a_0=="task"):
    return numpy.int32(5)
   if (_a_0=="ptf"):
    return numpy.int32(6)
   if (_a_0=="cb"):
    return numpy.int32(7)
   if (_a_0=="jsonTask"):
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1symmattype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1symmattype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1symmattype_1value_S(_a_0):
   if (_a_0=="sparse"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1nametype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1nametype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1nametype_1value_S(_a_0):
   if (_a_0=="gen"):
    return numpy.int32(0)
   if (_a_0=="mps"):
    return numpy.int32(1)
   if (_a_0=="lp"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1domaintype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1domaintype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1domaintype_1value_S(_a_0):
   if (_a_0=="r"):
    return numpy.int32(0)
   if (_a_0=="rzero"):
    return numpy.int32(1)
   if (_a_0=="rplus"):
    return numpy.int32(2)
   if (_a_0=="rminus"):
    return numpy.int32(3)
   if (_a_0=="quadraticCone"):
    return numpy.int32(4)
   if (_a_0=="rquadraticCone"):
    return numpy.int32(5)
   if (_a_0=="primalExpCone"):
    return numpy.int32(6)
   if (_a_0=="dualExpCone"):
    return numpy.int32(7)
   if (_a_0=="primalPowerCone"):
    return numpy.int32(8)
   if (_a_0=="dualPowerCone"):
    return numpy.int32(9)
   if (_a_0=="primalGeoMeanCone"):
    return numpy.int32(10)
   if (_a_0=="dualGeoMeanCone"):
    return numpy.int32(11)
   if (_a_0=="svecPsdCone"):
    return numpy.int32(12)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1conetype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1conetype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1conetype_1value_S(_a_0):
   if (_a_0=="quad"):
    return numpy.int32(0)
   if (_a_0=="rquad"):
    return numpy.int32(1)
   if (_a_0=="pexp"):
    return numpy.int32(2)
   if (_a_0=="dexp"):
    return numpy.int32(3)
   if (_a_0=="ppow"):
    return numpy.int32(4)
   if (_a_0=="dpow"):
    return numpy.int32(5)
   if (_a_0=="zero"):
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1compresstype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1compresstype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1compresstype_1value_S(_a_0):
   if (_a_0=="none"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(1)
   if (_a_0=="gzip"):
    return numpy.int32(2)
   if (_a_0=="zstd"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1callbackcode_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1callbackcode_1value_S(_a_0)
  @staticmethod
  def __string_1to_1callbackcode_1value_S(_a_0):
   if (_a_0=="beginRootCutgen"):
    return numpy.int32(29)
   if (_a_0=="imRootCutgen"):
    return numpy.int32(88)
   if (_a_0=="endRootCutgen"):
    return numpy.int32(66)
   if (_a_0=="beginSolveRootRelax"):
    return numpy.int32(31)
   if (_a_0=="endSolveRootRelax"):
    return numpy.int32(69)
   if (_a_0=="beginOptimizer"):
    return numpy.int32(19)
   if (_a_0=="endOptimizer"):
    return numpy.int32(56)
   if (_a_0=="beginFolding"):
    return numpy.int32(7)
   if (_a_0=="endFolding"):
    return numpy.int32(44)
   if (_a_0=="beginFoldingBi"):
    return numpy.int32(8)
   if (_a_0=="beginFoldingBiInitialize"):
    return numpy.int32(10)
   if (_a_0=="endFoldingBiInitialize"):
    return numpy.int32(47)
   if (_a_0=="beginFoldingBiPrimal"):
    return numpy.int32(12)
   if (_a_0=="foldingBiPrimal"):
    return numpy.int32(74)
   if (_a_0=="endFoldingBiPrimal"):
    return numpy.int32(49)
   if (_a_0=="beginFoldingBiDual"):
    return numpy.int32(9)
   if (_a_0=="foldingBiDual"):
    return numpy.int32(72)
   if (_a_0=="endFoldingBiDual"):
    return numpy.int32(46)
   if (_a_0=="beginFoldingBiOptimizer"):
    return numpy.int32(11)
   if (_a_0=="foldingBiOptimizer"):
    return numpy.int32(73)
   if (_a_0=="endFoldingBiOptimizer"):
    return numpy.int32(48)
   if (_a_0=="endFoldingBi"):
    return numpy.int32(45)
   if (_a_0=="beginPresolve"):
    return numpy.int32(20)
   if (_a_0=="updatePresolve"):
    return numpy.int32(102)
   if (_a_0=="endPresolve"):
    return numpy.int32(57)
   if (_a_0=="beginIntpnt"):
    return numpy.int32(15)
   if (_a_0=="intpnt"):
    return numpy.int32(90)
   if (_a_0=="endIntpnt"):
    return numpy.int32(52)
   if (_a_0=="beginConic"):
    return numpy.int32(1)
   if (_a_0=="conic"):
    return numpy.int32(34)
   if (_a_0=="endConic"):
    return numpy.int32(38)
   if (_a_0=="primalSimplex"):
    return numpy.int32(93)
   if (_a_0=="dualSimplex"):
    return numpy.int32(36)
   if (_a_0=="beginBi"):
    return numpy.int32(0)
   if (_a_0=="endBi"):
    return numpy.int32(37)
   if (_a_0=="beginInitializeBi"):
    return numpy.int32(14)
   if (_a_0=="endInitializeBi"):
    return numpy.int32(51)
   if (_a_0=="beginPrimalBi"):
    return numpy.int32(21)
   if (_a_0=="updatePrimalBi"):
    return numpy.int32(103)
   if (_a_0=="endPrimalBi"):
    return numpy.int32(58)
   if (_a_0=="beginDualBi"):
    return numpy.int32(2)
   if (_a_0=="updateDualBi"):
    return numpy.int32(99)
   if (_a_0=="endDualBi"):
    return numpy.int32(39)
   if (_a_0=="beginOptimizeBi"):
    return numpy.int32(18)
   if (_a_0=="optimizeBi"):
    return numpy.int32(92)
   if (_a_0=="endOptimizeBi"):
    return numpy.int32(55)
   if (_a_0=="beginPrimalSimplexBi"):
    return numpy.int32(26)
   if (_a_0=="updatePrimalSimplexBi"):
    return numpy.int32(105)
   if (_a_0=="endPrimalSimplexBi"):
    return numpy.int32(63)
   if (_a_0=="beginDualSimplexBi"):
    return numpy.int32(6)
   if (_a_0=="updateDualSimplexBi"):
    return numpy.int32(101)
   if (_a_0=="endDualSimplexBi"):
    return numpy.int32(43)
   if (_a_0=="endSimplexBi"):
    return numpy.int32(68)
   if (_a_0=="beginMio"):
    return numpy.int32(17)
   if (_a_0=="imMio"):
    return numpy.int32(80)
   if (_a_0=="newIntMio"):
    return numpy.int32(91)
   if (_a_0=="endMio"):
    return numpy.int32(54)
   if (_a_0=="restartMio"):
    return numpy.int32(97)
   if (_a_0=="decompMio"):
    return numpy.int32(35)
   if (_a_0=="beginSimplex"):
    return numpy.int32(30)
   if (_a_0=="imSimplex"):
    return numpy.int32(89)
   if (_a_0=="updateSimplex"):
    return numpy.int32(106)
   if (_a_0=="beginDualSimplex"):
    return numpy.int32(5)
   if (_a_0=="imDualSimplex"):
    return numpy.int32(77)
   if (_a_0=="updateDualSimplex"):
    return numpy.int32(100)
   if (_a_0=="endDualSimplex"):
    return numpy.int32(42)
   if (_a_0=="beginPrimalSimplex"):
    return numpy.int32(25)
   if (_a_0=="imPrimalSimplex"):
    return numpy.int32(86)
   if (_a_0=="updatePrimalSimplex"):
    return numpy.int32(104)
   if (_a_0=="endPrimalSimplex"):
    return numpy.int32(62)
   if (_a_0=="endSimplex"):
    return numpy.int32(67)
   if (_a_0=="beginInfeasAna"):
    return numpy.int32(13)
   if (_a_0=="endInfeasAna"):
    return numpy.int32(50)
   if (_a_0=="imPrimalSensivity"):
    return numpy.int32(85)
   if (_a_0=="imDualSensivity"):
    return numpy.int32(76)
   if (_a_0=="imMioIntpnt"):
    return numpy.int32(82)
   if (_a_0=="imMioPrimalSimplex"):
    return numpy.int32(83)
   if (_a_0=="imMioDualSimplex"):
    return numpy.int32(81)
   if (_a_0=="beginPrimalSetupBi"):
    return numpy.int32(24)
   if (_a_0=="endPrimalSetupBi"):
    return numpy.int32(61)
   if (_a_0=="beginDualSetupBi"):
    return numpy.int32(4)
   if (_a_0=="endDualSetupBi"):
    return numpy.int32(41)
   if (_a_0=="beginPrimalSensitivity"):
    return numpy.int32(23)
   if (_a_0=="endPrimalSensitivity"):
    return numpy.int32(60)
   if (_a_0=="beginDualSensitivity"):
    return numpy.int32(3)
   if (_a_0=="endDualSensitivity"):
    return numpy.int32(40)
   if (_a_0=="beginLicenseWait"):
    return numpy.int32(16)
   if (_a_0=="endLicenseWait"):
    return numpy.int32(53)
   if (_a_0=="imLicenseWait"):
    return numpy.int32(78)
   if (_a_0=="beginQcqoReformulate"):
    return numpy.int32(27)
   if (_a_0=="qoReformulate"):
    return numpy.int32(94)
   if (_a_0=="endQcqoReformulate"):
    return numpy.int32(64)
   if (_a_0=="beginToConic"):
    return numpy.int32(32)
   if (_a_0=="endToConic"):
    return numpy.int32(70)
   if (_a_0=="beginPrimalRepair"):
    return numpy.int32(22)
   if (_a_0=="endPrimalRepair"):
    return numpy.int32(59)
   if (_a_0=="beginRead"):
    return numpy.int32(28)
   if (_a_0=="imRead"):
    return numpy.int32(87)
   if (_a_0=="endRead"):
    return numpy.int32(65)
   if (_a_0=="beginWrite"):
    return numpy.int32(33)
   if (_a_0=="endWrite"):
    return numpy.int32(71)
   if (_a_0=="readOpfSection"):
    return numpy.int32(96)
   if (_a_0=="imLu"):
    return numpy.int32(79)
   if (_a_0=="imOrder"):
    return numpy.int32(84)
   if (_a_0=="readOpf"):
    return numpy.int32(95)
   if (_a_0=="writeOpf"):
    return numpy.int32(107)
   if (_a_0=="solvingRemote"):
    return numpy.int32(98)
   if (_a_0=="heartbeat"):
    return numpy.int32(75)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1intpnthotstart_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1intpnthotstart_1value_S(_a_0)
  @staticmethod
  def __string_1to_1intpnthotstart_1value_S(_a_0):
   if (_a_0=="none"):
    return numpy.int32(0)
   if (_a_0=="primal"):
    return numpy.int32(1)
   if (_a_0=="dual"):
    return numpy.int32(2)
   if (_a_0=="primalDual"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simhotstart_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1simhotstart_1value_S(_a_0)
  @staticmethod
  def __string_1to_1simhotstart_1value_S(_a_0):
   if (_a_0=="none"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(1)
   if (_a_0=="statusKeys"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdupvec_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1simdupvec_1value_S(_a_0)
  @staticmethod
  def __string_1to_1simdupvec_1value_S(_a_0):
   if (_a_0=="on"):
    return numpy.int32(1)
   if (_a_0=="off"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simreform_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1simreform_1value_S(_a_0)
  @staticmethod
  def __string_1to_1simreform_1value_S(_a_0):
   if (_a_0=="on"):
    return numpy.int32(1)
   if (_a_0=="off"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(2)
   if (_a_0=="aggressive"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1uplo_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1uplo_1value_S(_a_0)
  @staticmethod
  def __string_1to_1uplo_1value_S(_a_0):
   if (_a_0=="lo"):
    return numpy.int32(0)
   if (_a_0=="up"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1transpose_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1transpose_1value_S(_a_0)
  @staticmethod
  def __string_1to_1transpose_1value_S(_a_0):
   if (_a_0=="no"):
    return numpy.int32(0)
   if (_a_0=="yes"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdegen_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1simdegen_1value_S(_a_0)
  @staticmethod
  def __string_1to_1simdegen_1value_S(_a_0):
   if (_a_0=="none"):
    return numpy.int32(0)
   if (_a_0=="free"):
    return numpy.int32(1)
   if (_a_0=="aggressive"):
    return numpy.int32(2)
   if (_a_0=="moderate"):
    return numpy.int32(3)
   if (_a_0=="minimum"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simprecision_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1simprecision_1value_S(_a_0)
  @staticmethod
  def __string_1to_1simprecision_1value_S(_a_0):
   if (_a_0=="normal"):
    return numpy.int32(0)
   if (_a_0=="extended"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mark_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1mark_1value_S(_a_0)
  @staticmethod
  def __string_1to_1mark_1value_S(_a_0):
   if (_a_0=="lo"):
    return numpy.int32(0)
   if (_a_0=="up"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1boundkey_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1boundkey_1value_S(_a_0)
  @staticmethod
  def __string_1to_1boundkey_1value_S(_a_0):
   if (_a_0=="lo"):
    return numpy.int32(0)
   if (_a_0=="up"):
    return numpy.int32(1)
   if (_a_0=="fx"):
    return numpy.int32(2)
   if (_a_0=="fr"):
    return numpy.int32(3)
   if (_a_0=="ra"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1basindtype_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1basindtype_1value_S(_a_0)
  @staticmethod
  def __string_1to_1basindtype_1value_S(_a_0):
   if (_a_0=="never"):
    return numpy.int32(0)
   if (_a_0=="always"):
    return numpy.int32(1)
   if (_a_0=="noError"):
    return numpy.int32(2)
   if (_a_0=="ifFeasible"):
    return numpy.int32(3)
   if (_a_0=="reservered"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1language_1value_alt_S(_t__a_0):
    return mosek_fusion_Parameters.__string_1to_1language_1value_S(_a_0)
  @staticmethod
  def __string_1to_1language_1value_S(_a_0):
   if (_a_0=="eng"):
    return numpy.int32(0)
   if (_a_0=="dan"):
    return numpy.int32(1)
   return numpy.int32((- 1))
 return Parameters
mosek_fusion_Parameters=__mk_mosek_fusion_Parameters()
del __mk_mosek_fusion_Parameters
def __mk_mosek_fusion_Utils_StringIntMap():
  class StringIntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_S(self,key): return key in self.__d
    def _getItem_S(self,key): return self.__d[key]
    def _setItem_SI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  return StringIntMap
mosek_fusion_Utils_StringIntMap=__mk_mosek_fusion_Utils_StringIntMap()
def __mk_mosek_fusion_Utils_IntMap():
  class IntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_J(self,key): return key in self.__d
    def _getItem_J(self,key): return self.__d[key]
    def _setItem_JI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  
  
  
  return IntMap
mosek_fusion_Utils_IntMap=__mk_mosek_fusion_Utils_IntMap()
def __mk_mosek_fusion_Utils_StringBuffer():
  class StringBuffer:
    def __init__(self):
      self.__buf = []
    def __a(self,v):
      self.__buf.append(str(v))
      return self
    def __a_array(self,v):
      if v is None: self.__buf.append("None")
      else: self.__buf.append(str(v))
      return self
  
    _a_Z   = __a
    _a_I   = __a
    _a_J   = __a
    _a_U   = __a
    _a_D   = __a
    _a_S   = __a
    _a_B   = __a
    _a__3I = __a_array
    def _a__3J(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%i' % i for i in v]),']'])
      else:             self.__buf.append('None')
      return self
    def _a__3D(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%g' % i for i in v]),']'])
      else:             self.__buf.append('None')
      return self
    _a__3S = __a_array
    def _lf_(self):
      self.__buf.append('\n')
      return self
    def _clear_ (self):
      self.__buf = []
      return self
    def _toString_(self):
      return ''.join(self.__buf)
    def _toString_(self):
      return ''.join(self.__buf)
    def _consolePrint_(self):
      print(self._toString_())
      self._clear_()
      return(self)
  return StringBuffer
mosek_fusion_Utils_StringBuffer=__mk_mosek_fusion_Utils_StringBuffer()
def __mk_mosek_fusion_Utils_Tools():
  
  import random,ctypes,math
  class Tools:
    @staticmethod
    def __arraycopy(src,srcoffset,tgt,tgtoffset,size):
      if len(tgt) < tgtoffset+size or len(src) < srcoffset+size:
        raise IndexError("Copy slice out of range")
      tgt[tgtoffset:tgtoffset+size] = src[srcoffset:srcoffset+size]
  
    _arraycopy__3II_3III =  __arraycopy
    _arraycopy__3JI_3JII = __arraycopy
    _arraycopy__3_3II_3_3III = __arraycopy
    _arraycopy__3_3DI_3_3DII = __arraycopy
    _arraycopy__3DI_3DII = __arraycopy
    _arraycopy__3IJ_3IJJ = __arraycopy
    _arraycopy__3JJ_3JJJ = __arraycopy
    _arraycopy__3DJ_3DJJ = __arraycopy
  
    @staticmethod
    def __arrayclone(a):
      if a is None:
        raise FatalError("Unexpected None passed to arraycopy. Cloning a None array is not allowed.")
      if isinstance(a,numpy.ndarray):
        return a.copy()
      else:      
        return numpy.array(a)
  
    _arraycopy__3D = __arrayclone
    _arraycopy__3I = __arrayclone
    _arraycopy__3J = __arrayclone
    _arraycopy__3S = __arrayclone
  
    @staticmethod
    def __arraylength(a): return len(a)
  
    _arraylength__3Lmosek_4fusion_4Variable_2   = __arraylength
    _arraylength__3Lmosek_4fusion_4Constranit_2 = __arraylength  
    _arraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength  
    _arraylength__3S   = __arraylength  
    _arraylength__3I   = __arraylength  
    _arraylength__3J   = __arraylength  
    _arraylength__3D   = __arraylength  
    _arraylength__3_3D = __arraylength  
    _arraylength__3_3I = __arraylength  
    _uarraylength__3I  = __arraylength 
    _uarraylength__3J  = __arraylength 
    _uarraylength__3D  = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Variable_2   = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Constraint_2 = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength 
    _uarraylength__3_3S = __arraylength 
    _uarraylength__3_3D = __arraylength 
    _uarraylength__3_3I = __arraylength 
  
    @staticmethod
    def __matrixheight(m): return m.shape[0]
    @staticmethod
    def __matrixwidth(m): return m.shape[1]
    
    _matrixheight__3_3D = __matrixheight
    _matrixwidth__3_3D  = __matrixwidth
    _matrixheight__3_3Lmosek_4fusion_4Matrix_2 = __matrixheight
    _matrixwidth__3_3Lmosek_4fusion_4Matrix_2  = __matrixwidth
   
    @staticmethod   
    def _range_J (last): return numpy.arange(last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJ(first,last): return numpy.arange(first,last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJJ(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int64)
  
    @staticmethod   
    def _range_I (last): return numpy.arange(last,dtype=numpy.int32)
    @staticmethod   
    def _range_II(first,last): return numpy.arange(first,last,dtype=numpy.int32)
    @staticmethod   
    def _range_III(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int32)
  
    @staticmethod   
    def _zeros_I (num): return  numpy.zeros((num,),dtype=numpy.float64)
    @staticmethod   
    def _zeros_II (dimi,dimj): return  numpy.zeros((dimi,dimj),dtype=numpy.float64)
    @staticmethod   
    def _ones_I(num):  return  numpy.ones((num,),numpy.float64)
    
    __rand = random.Random()
    @staticmethod   
    def _randInt_I(max):
      return Tools.__rand.randint(0,max-1)
      
    @staticmethod   
    def _argsort__3J_3I_3JII(perm,val1,val2,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val1[lhs],val1[rhs]) or cmp(val2[lhs],val2[rhs]))
        perm[first:last] = p
  
    @staticmethod   
    def _argsort__3J_3I_3I(perm,val1,val2):    
      Tools._argsort__3I_3I_3III(perm,val1,val2,0,len(perm))
    
    @staticmethod   
    def _argsort__3J_3I(perm,vals):
      Tools._argsort__3I_3III(perm,vals,0,len(perm))
  
    @staticmethod   
    def _argsort__3J_3III(perm,val,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val[lhs],val[rhs]))
        perm[first:last] = p
  
    @staticmethod
    def _sort__3I_II (vals,first,last):
      if last-first > 1:
        tmp = vals[first:last]
        tmp.sort()
        vals[first:last] = tmp
  
    @staticmethod   
    def _makevector_DI(val,num): 
      r = numpy.zeros((num,), numpy.float64)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_II(val,num): 
      r = numpy.zeros((num,), numpy.int32)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_JI(val,num): 
      r = numpy.zeros((num,), numpy.int64)
      r[:] = val
      return r
    @staticmethod   
    def _repeatrange_III(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int32)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod   
    def _repeatrange_JJJ(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int64)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod
    def  _stringvalue_I(v): return str(v)
    @staticmethod
    def  _stringvalue_J(v): return str(v)
  
    @staticmethod
    def _toDouble_S(v):    
      return float(v)
  
    @staticmethod
    def _sqrt_D(v):
      return math.sqrt(v)
    
    @staticmethod
    def _toInt_S(v):
      return int(v)
  
  
    @staticmethod 
    def _argsort2(perm,v,first,last):
      l = sorted(perm[first:last],key=lambda i: v[i])
      perm[first:last] = l
    
    @staticmethod 
    def _argsort2x(perm,v0,v1,first,last):
      l = sorted(perm[first:last],key=lambda i: (v0[i],v1[i]))
      perm[first:last] = l
  
  
  
    @staticmethod 
    def _argsort__3J_3IJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
    
    @staticmethod 
    def _argsort__3J_3JJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
  
    @staticmethod 
    def _argsort__3J_3I_3IJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
    
    @staticmethod 
    def _argsort__3J_3J_3JJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
  
    @staticmethod
    def _bucketsort__3JJJ_3III(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        if perm_ct.strides[0] == 8:
          #print( perm_ct.strides[:], perm_ct.shape[:],perm_ct.get_data())
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
        if v_ct.strides[0] == 4:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int32)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3III_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
        del arg_perm,arg_v
  
        if copy_v: 
          v[:] = tmpv
          del tmpv
        if copy_perm: 
          perm[first:last] = tmpperm
          del tmpperm
  
      
    @staticmethod
    def _bucketsort__3JJJ_3JJJ(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
        #print( rperm,v)
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        
       
        if perm_ct.strides[0] == 8:
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
  
        if v_ct.strides[0] == 8:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int64)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3JJJ_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
  
        if copy_v: v[:] = tmpv
        if copy_perm: perm[first:last] = tmpperm
  
  
  
  
  return Tools
mosek_fusion_Utils_Tools=__mk_mosek_fusion_Utils_Tools()
def __mk_mosek_fusion_SolverInfo():
  from bisect import bisect_left
  import mosek
  class SolverInfo:
    dinfnames  = [ "anaProScalarizedConstraintMatrixDensity","biCleanTime","biDualTime","biPrimalTime","biTime","foldingBiOptimizeTime","foldingBiUnfoldDualTime","foldingBiUnfoldInitializeTime","foldingBiUnfoldPrimalTime","foldingBiUnfoldTime","foldingFactor","foldingTime","intpntDualFeas","intpntDualObj","intpntFactorNumFlops","intpntOptStatus","intpntOrderTime","intpntPrimalFeas","intpntPrimalObj","intpntTime","mioCliqueSelectionTime","mioCliqueSeparationTime","mioCmirSelectionTime","mioCmirSeparationTime","mioConstructSolutionObj","mioDualBoundAfterPresolve","mioGmiSelectionTime","mioGmiSeparationTime","mioImpliedBoundSelectionTime","mioImpliedBoundSeparationTime","mioInitialFeasibleSolutionObj","mioKnapsackCoverSelectionTime","mioKnapsackCoverSeparationTime","mioLiproSelectionTime","mioLiproSeparationTime","mioObjAbsGap","mioObjBound","mioObjInt","mioObjRelGap","mioProbingTime","mioRootCutSelectionTime","mioRootCutSeparationTime","mioRootOptimizerTime","mioRootPresolveTime","mioRootTime","mioSymmetryDetectionTime","mioSymmetryFactor","mioTime","mioUserObjCut","optimizerTicks","optimizerTime","presolveEliTime","presolveLindepTime","presolveTime","presolveTotalPrimalPerturbation","primalRepairPenaltyObj","qcqoReformulateMaxPerturbation","qcqoReformulateTime","qcqoReformulateWorstCholeskyColumnScaling","qcqoReformulateWorstCholeskyDiagScaling","readDataTime","remoteTime","simDualTime","simFeas","simObj","simPrimalTime","simTime","solBasDualObj","solBasDviolcon","solBasDviolvar","solBasNrmBarx","solBasNrmSlc","solBasNrmSlx","solBasNrmSuc","solBasNrmSux","solBasNrmXc","solBasNrmXx","solBasNrmY","solBasPrimalObj","solBasPviolcon","solBasPviolvar","solItgNrmBarx","solItgNrmXc","solItgNrmXx","solItgPrimalObj","solItgPviolacc","solItgPviolbarvar","solItgPviolcon","solItgPviolcones","solItgPvioldjc","solItgPviolitg","solItgPviolvar","solItrDualObj","solItrDviolacc","solItrDviolbarvar","solItrDviolcon","solItrDviolcones","solItrDviolvar","solItrNrmBars","solItrNrmBarx","solItrNrmSlc","solItrNrmSlx","solItrNrmSnx","solItrNrmSuc","solItrNrmSux","solItrNrmXc","solItrNrmXx","solItrNrmY","solItrPrimalObj","solItrPviolacc","solItrPviolbarvar","solItrPviolcon","solItrPviolcones","solItrPviolvar","toConicTime","writeDataTime" ];
    iinfnames  = [ "anaProNumCon","anaProNumConEq","anaProNumConFr","anaProNumConLo","anaProNumConRa","anaProNumConUp","anaProNumVar","anaProNumVarBin","anaProNumVarCont","anaProNumVarEq","anaProNumVarFr","anaProNumVarInt","anaProNumVarLo","anaProNumVarRa","anaProNumVarUp","foldingApplied","intpntFactorDimDense","intpntIter","intpntNumThreads","intpntSolveDual","mioAbsgapSatisfied","mioCliqueTableSize","mioConstructSolution","mioFinalNumbin","mioFinalNumbinconevar","mioFinalNumcon","mioFinalNumcone","mioFinalNumconevar","mioFinalNumcont","mioFinalNumcontconevar","mioFinalNumdexpcones","mioFinalNumdjc","mioFinalNumdpowcones","mioFinalNumint","mioFinalNumintconevar","mioFinalNumpexpcones","mioFinalNumppowcones","mioFinalNumqcones","mioFinalNumrqcones","mioFinalNumvar","mioInitialFeasibleSolution","mioNodeDepth","mioNumActiveNodes","mioNumActiveRootCuts","mioNumBlocksSolvedInBb","mioNumBlocksSolvedInPresolve","mioNumBranch","mioNumIntSolutions","mioNumRelax","mioNumRepeatedPresolve","mioNumRestarts","mioNumRootCutRounds","mioNumSelectedCliqueCuts","mioNumSelectedCmirCuts","mioNumSelectedGomoryCuts","mioNumSelectedImpliedBoundCuts","mioNumSelectedKnapsackCoverCuts","mioNumSelectedLiproCuts","mioNumSeparatedCliqueCuts","mioNumSeparatedCmirCuts","mioNumSeparatedGomoryCuts","mioNumSeparatedImpliedBoundCuts","mioNumSeparatedKnapsackCoverCuts","mioNumSeparatedLiproCuts","mioNumSolvedNodes","mioNumbin","mioNumbinconevar","mioNumcon","mioNumcone","mioNumconevar","mioNumcont","mioNumcontconevar","mioNumdexpcones","mioNumdjc","mioNumdpowcones","mioNumint","mioNumintconevar","mioNumpexpcones","mioNumppowcones","mioNumqcones","mioNumrqcones","mioNumvar","mioObjBoundDefined","mioPresolvedNumbin","mioPresolvedNumbinconevar","mioPresolvedNumcon","mioPresolvedNumcone","mioPresolvedNumconevar","mioPresolvedNumcont","mioPresolvedNumcontconevar","mioPresolvedNumdexpcones","mioPresolvedNumdjc","mioPresolvedNumdpowcones","mioPresolvedNumint","mioPresolvedNumintconevar","mioPresolvedNumpexpcones","mioPresolvedNumppowcones","mioPresolvedNumqcones","mioPresolvedNumrqcones","mioPresolvedNumvar","mioRelgapSatisfied","mioTotalNumSelectedCuts","mioTotalNumSeparatedCuts","mioUserObjCut","optNumcon","optNumvar","optimizeResponse","presolveNumPrimalPerturbations","purifyDualSuccess","purifyPrimalSuccess","rdNumbarvar","rdNumcon","rdNumcone","rdNumintvar","rdNumq","rdNumvar","rdProtype","simDualDegIter","simDualHotstart","simDualHotstartLu","simDualInfIter","simDualIter","simNumcon","simNumvar","simPrimalDegIter","simPrimalHotstart","simPrimalHotstartLu","simPrimalInfIter","simPrimalIter","simSolveDual","solBasProsta","solBasSolsta","solItgProsta","solItgSolsta","solItrProsta","solItrSolsta","stoNumARealloc" ];
    liinfnames = [ "anaProScalarizedConstraintMatrixNumColumns","anaProScalarizedConstraintMatrixNumNz","anaProScalarizedConstraintMatrixNumRows","biCleanIter","biDualIter","biPrimalIter","foldingBiDualIter","foldingBiOptimizerIter","foldingBiPrimalIter","intpntFactorNumNz","mioAnz","mioFinalAnz","mioIntpntIter","mioNumDualIllposedCer","mioNumPrimIllposedCer","mioPresolvedAnz","mioSimplexIter","rdNumacc","rdNumanz","rdNumdjc","rdNumqnz","simplexIter" ];
    dinfsyms   = [ mosek.dinfitem.ana_pro_scalarized_constraint_matrix_density,mosek.dinfitem.bi_clean_time,mosek.dinfitem.bi_dual_time,mosek.dinfitem.bi_primal_time,mosek.dinfitem.bi_time,mosek.dinfitem.folding_bi_optimize_time,mosek.dinfitem.folding_bi_unfold_dual_time,mosek.dinfitem.folding_bi_unfold_initialize_time,mosek.dinfitem.folding_bi_unfold_primal_time,mosek.dinfitem.folding_bi_unfold_time,mosek.dinfitem.folding_factor,mosek.dinfitem.folding_time,mosek.dinfitem.intpnt_dual_feas,mosek.dinfitem.intpnt_dual_obj,mosek.dinfitem.intpnt_factor_num_flops,mosek.dinfitem.intpnt_opt_status,mosek.dinfitem.intpnt_order_time,mosek.dinfitem.intpnt_primal_feas,mosek.dinfitem.intpnt_primal_obj,mosek.dinfitem.intpnt_time,mosek.dinfitem.mio_clique_selection_time,mosek.dinfitem.mio_clique_separation_time,mosek.dinfitem.mio_cmir_selection_time,mosek.dinfitem.mio_cmir_separation_time,mosek.dinfitem.mio_construct_solution_obj,mosek.dinfitem.mio_dual_bound_after_presolve,mosek.dinfitem.mio_gmi_selection_time,mosek.dinfitem.mio_gmi_separation_time,mosek.dinfitem.mio_implied_bound_selection_time,mosek.dinfitem.mio_implied_bound_separation_time,mosek.dinfitem.mio_initial_feasible_solution_obj,mosek.dinfitem.mio_knapsack_cover_selection_time,mosek.dinfitem.mio_knapsack_cover_separation_time,mosek.dinfitem.mio_lipro_selection_time,mosek.dinfitem.mio_lipro_separation_time,mosek.dinfitem.mio_obj_abs_gap,mosek.dinfitem.mio_obj_bound,mosek.dinfitem.mio_obj_int,mosek.dinfitem.mio_obj_rel_gap,mosek.dinfitem.mio_probing_time,mosek.dinfitem.mio_root_cut_selection_time,mosek.dinfitem.mio_root_cut_separation_time,mosek.dinfitem.mio_root_optimizer_time,mosek.dinfitem.mio_root_presolve_time,mosek.dinfitem.mio_root_time,mosek.dinfitem.mio_symmetry_detection_time,mosek.dinfitem.mio_symmetry_factor,mosek.dinfitem.mio_time,mosek.dinfitem.mio_user_obj_cut,mosek.dinfitem.optimizer_ticks,mosek.dinfitem.optimizer_time,mosek.dinfitem.presolve_eli_time,mosek.dinfitem.presolve_lindep_time,mosek.dinfitem.presolve_time,mosek.dinfitem.presolve_total_primal_perturbation,mosek.dinfitem.primal_repair_penalty_obj,mosek.dinfitem.qcqo_reformulate_max_perturbation,mosek.dinfitem.qcqo_reformulate_time,mosek.dinfitem.qcqo_reformulate_worst_cholesky_column_scaling,mosek.dinfitem.qcqo_reformulate_worst_cholesky_diag_scaling,mosek.dinfitem.read_data_time,mosek.dinfitem.remote_time,mosek.dinfitem.sim_dual_time,mosek.dinfitem.sim_feas,mosek.dinfitem.sim_obj,mosek.dinfitem.sim_primal_time,mosek.dinfitem.sim_time,mosek.dinfitem.sol_bas_dual_obj,mosek.dinfitem.sol_bas_dviolcon,mosek.dinfitem.sol_bas_dviolvar,mosek.dinfitem.sol_bas_nrm_barx,mosek.dinfitem.sol_bas_nrm_slc,mosek.dinfitem.sol_bas_nrm_slx,mosek.dinfitem.sol_bas_nrm_suc,mosek.dinfitem.sol_bas_nrm_sux,mosek.dinfitem.sol_bas_nrm_xc,mosek.dinfitem.sol_bas_nrm_xx,mosek.dinfitem.sol_bas_nrm_y,mosek.dinfitem.sol_bas_primal_obj,mosek.dinfitem.sol_bas_pviolcon,mosek.dinfitem.sol_bas_pviolvar,mosek.dinfitem.sol_itg_nrm_barx,mosek.dinfitem.sol_itg_nrm_xc,mosek.dinfitem.sol_itg_nrm_xx,mosek.dinfitem.sol_itg_primal_obj,mosek.dinfitem.sol_itg_pviolacc,mosek.dinfitem.sol_itg_pviolbarvar,mosek.dinfitem.sol_itg_pviolcon,mosek.dinfitem.sol_itg_pviolcones,mosek.dinfitem.sol_itg_pvioldjc,mosek.dinfitem.sol_itg_pviolitg,mosek.dinfitem.sol_itg_pviolvar,mosek.dinfitem.sol_itr_dual_obj,mosek.dinfitem.sol_itr_dviolacc,mosek.dinfitem.sol_itr_dviolbarvar,mosek.dinfitem.sol_itr_dviolcon,mosek.dinfitem.sol_itr_dviolcones,mosek.dinfitem.sol_itr_dviolvar,mosek.dinfitem.sol_itr_nrm_bars,mosek.dinfitem.sol_itr_nrm_barx,mosek.dinfitem.sol_itr_nrm_slc,mosek.dinfitem.sol_itr_nrm_slx,mosek.dinfitem.sol_itr_nrm_snx,mosek.dinfitem.sol_itr_nrm_suc,mosek.dinfitem.sol_itr_nrm_sux,mosek.dinfitem.sol_itr_nrm_xc,mosek.dinfitem.sol_itr_nrm_xx,mosek.dinfitem.sol_itr_nrm_y,mosek.dinfitem.sol_itr_primal_obj,mosek.dinfitem.sol_itr_pviolacc,mosek.dinfitem.sol_itr_pviolbarvar,mosek.dinfitem.sol_itr_pviolcon,mosek.dinfitem.sol_itr_pviolcones,mosek.dinfitem.sol_itr_pviolvar,mosek.dinfitem.to_conic_time,mosek.dinfitem.write_data_time ];
    iinfsyms   = [ mosek.iinfitem.ana_pro_num_con,mosek.iinfitem.ana_pro_num_con_eq,mosek.iinfitem.ana_pro_num_con_fr,mosek.iinfitem.ana_pro_num_con_lo,mosek.iinfitem.ana_pro_num_con_ra,mosek.iinfitem.ana_pro_num_con_up,mosek.iinfitem.ana_pro_num_var,mosek.iinfitem.ana_pro_num_var_bin,mosek.iinfitem.ana_pro_num_var_cont,mosek.iinfitem.ana_pro_num_var_eq,mosek.iinfitem.ana_pro_num_var_fr,mosek.iinfitem.ana_pro_num_var_int,mosek.iinfitem.ana_pro_num_var_lo,mosek.iinfitem.ana_pro_num_var_ra,mosek.iinfitem.ana_pro_num_var_up,mosek.iinfitem.folding_applied,mosek.iinfitem.intpnt_factor_dim_dense,mosek.iinfitem.intpnt_iter,mosek.iinfitem.intpnt_num_threads,mosek.iinfitem.intpnt_solve_dual,mosek.iinfitem.mio_absgap_satisfied,mosek.iinfitem.mio_clique_table_size,mosek.iinfitem.mio_construct_solution,mosek.iinfitem.mio_final_numbin,mosek.iinfitem.mio_final_numbinconevar,mosek.iinfitem.mio_final_numcon,mosek.iinfitem.mio_final_numcone,mosek.iinfitem.mio_final_numconevar,mosek.iinfitem.mio_final_numcont,mosek.iinfitem.mio_final_numcontconevar,mosek.iinfitem.mio_final_numdexpcones,mosek.iinfitem.mio_final_numdjc,mosek.iinfitem.mio_final_numdpowcones,mosek.iinfitem.mio_final_numint,mosek.iinfitem.mio_final_numintconevar,mosek.iinfitem.mio_final_numpexpcones,mosek.iinfitem.mio_final_numppowcones,mosek.iinfitem.mio_final_numqcones,mosek.iinfitem.mio_final_numrqcones,mosek.iinfitem.mio_final_numvar,mosek.iinfitem.mio_initial_feasible_solution,mosek.iinfitem.mio_node_depth,mosek.iinfitem.mio_num_active_nodes,mosek.iinfitem.mio_num_active_root_cuts,mosek.iinfitem.mio_num_blocks_solved_in_bb,mosek.iinfitem.mio_num_blocks_solved_in_presolve,mosek.iinfitem.mio_num_branch,mosek.iinfitem.mio_num_int_solutions,mosek.iinfitem.mio_num_relax,mosek.iinfitem.mio_num_repeated_presolve,mosek.iinfitem.mio_num_restarts,mosek.iinfitem.mio_num_root_cut_rounds,mosek.iinfitem.mio_num_selected_clique_cuts,mosek.iinfitem.mio_num_selected_cmir_cuts,mosek.iinfitem.mio_num_selected_gomory_cuts,mosek.iinfitem.mio_num_selected_implied_bound_cuts,mosek.iinfitem.mio_num_selected_knapsack_cover_cuts,mosek.iinfitem.mio_num_selected_lipro_cuts,mosek.iinfitem.mio_num_separated_clique_cuts,mosek.iinfitem.mio_num_separated_cmir_cuts,mosek.iinfitem.mio_num_separated_gomory_cuts,mosek.iinfitem.mio_num_separated_implied_bound_cuts,mosek.iinfitem.mio_num_separated_knapsack_cover_cuts,mosek.iinfitem.mio_num_separated_lipro_cuts,mosek.iinfitem.mio_num_solved_nodes,mosek.iinfitem.mio_numbin,mosek.iinfitem.mio_numbinconevar,mosek.iinfitem.mio_numcon,mosek.iinfitem.mio_numcone,mosek.iinfitem.mio_numconevar,mosek.iinfitem.mio_numcont,mosek.iinfitem.mio_numcontconevar,mosek.iinfitem.mio_numdexpcones,mosek.iinfitem.mio_numdjc,mosek.iinfitem.mio_numdpowcones,mosek.iinfitem.mio_numint,mosek.iinfitem.mio_numintconevar,mosek.iinfitem.mio_numpexpcones,mosek.iinfitem.mio_numppowcones,mosek.iinfitem.mio_numqcones,mosek.iinfitem.mio_numrqcones,mosek.iinfitem.mio_numvar,mosek.iinfitem.mio_obj_bound_defined,mosek.iinfitem.mio_presolved_numbin,mosek.iinfitem.mio_presolved_numbinconevar,mosek.iinfitem.mio_presolved_numcon,mosek.iinfitem.mio_presolved_numcone,mosek.iinfitem.mio_presolved_numconevar,mosek.iinfitem.mio_presolved_numcont,mosek.iinfitem.mio_presolved_numcontconevar,mosek.iinfitem.mio_presolved_numdexpcones,mosek.iinfitem.mio_presolved_numdjc,mosek.iinfitem.mio_presolved_numdpowcones,mosek.iinfitem.mio_presolved_numint,mosek.iinfitem.mio_presolved_numintconevar,mosek.iinfitem.mio_presolved_numpexpcones,mosek.iinfitem.mio_presolved_numppowcones,mosek.iinfitem.mio_presolved_numqcones,mosek.iinfitem.mio_presolved_numrqcones,mosek.iinfitem.mio_presolved_numvar,mosek.iinfitem.mio_relgap_satisfied,mosek.iinfitem.mio_total_num_selected_cuts,mosek.iinfitem.mio_total_num_separated_cuts,mosek.iinfitem.mio_user_obj_cut,mosek.iinfitem.opt_numcon,mosek.iinfitem.opt_numvar,mosek.iinfitem.optimize_response,mosek.iinfitem.presolve_num_primal_perturbations,mosek.iinfitem.purify_dual_success,mosek.iinfitem.purify_primal_success,mosek.iinfitem.rd_numbarvar,mosek.iinfitem.rd_numcon,mosek.iinfitem.rd_numcone,mosek.iinfitem.rd_numintvar,mosek.iinfitem.rd_numq,mosek.iinfitem.rd_numvar,mosek.iinfitem.rd_protype,mosek.iinfitem.sim_dual_deg_iter,mosek.iinfitem.sim_dual_hotstart,mosek.iinfitem.sim_dual_hotstart_lu,mosek.iinfitem.sim_dual_inf_iter,mosek.iinfitem.sim_dual_iter,mosek.iinfitem.sim_numcon,mosek.iinfitem.sim_numvar,mosek.iinfitem.sim_primal_deg_iter,mosek.iinfitem.sim_primal_hotstart,mosek.iinfitem.sim_primal_hotstart_lu,mosek.iinfitem.sim_primal_inf_iter,mosek.iinfitem.sim_primal_iter,mosek.iinfitem.sim_solve_dual,mosek.iinfitem.sol_bas_prosta,mosek.iinfitem.sol_bas_solsta,mosek.iinfitem.sol_itg_prosta,mosek.iinfitem.sol_itg_solsta,mosek.iinfitem.sol_itr_prosta,mosek.iinfitem.sol_itr_solsta,mosek.iinfitem.sto_num_a_realloc ];
    liinfsyms  = [ mosek.liinfitem.ana_pro_scalarized_constraint_matrix_num_columns,mosek.liinfitem.ana_pro_scalarized_constraint_matrix_num_nz,mosek.liinfitem.ana_pro_scalarized_constraint_matrix_num_rows,mosek.liinfitem.bi_clean_iter,mosek.liinfitem.bi_dual_iter,mosek.liinfitem.bi_primal_iter,mosek.liinfitem.folding_bi_dual_iter,mosek.liinfitem.folding_bi_optimizer_iter,mosek.liinfitem.folding_bi_primal_iter,mosek.liinfitem.intpnt_factor_num_nz,mosek.liinfitem.mio_anz,mosek.liinfitem.mio_final_anz,mosek.liinfitem.mio_intpnt_iter,mosek.liinfitem.mio_num_dual_illposed_cer,mosek.liinfitem.mio_num_prim_illposed_cer,mosek.liinfitem.mio_presolved_anz,mosek.liinfitem.mio_simplex_iter,mosek.liinfitem.rd_numacc,mosek.liinfitem.rd_numanz,mosek.liinfitem.rd_numdjc,mosek.liinfitem.rd_numqnz,mosek.liinfitem.simplex_iter ];
    @staticmethod
    def _getdouinf(infname):
      idx = bisect_left(SolverInfo.dinfnames, infname)
      if idx != len(SolverInfo.dinfnames) and SolverInfo.dinfnames[idx] == infname:
        return SolverInfo.dinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getintinf(infname):
      idx = bisect_left(SolverInfo.iinfnames, infname)
      if idx != len(SolverInfo.iinfnames) and SolverInfo.iinfnames[idx] == infname:
        return SolverInfo.iinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getlintinf(infname):
      idx = bisect_left(SolverInfo.liinfnames, infname)
      if idx != len(SolverInfo.liinfnames) and SolverInfo.liinfnames[idx] == infname:
        return SolverInfo.liinfsyms[idx]
      else:
        return None
  return SolverInfo
mosek_fusion_SolverInfo=__mk_mosek_fusion_SolverInfo()
def __arg_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_alt_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedConstraint)
def __arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Variable) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Variable_2__)
def __arg_match_LSystem_4DataStream_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataStream_2__(v):
  return __arg_match_LSystem_4DataStream_2__(v)
def __arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ExprRangeDomain)
def __arg_alt_match_Lmosek_4fusion_4ExprRangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ExprRangeDomain_2__(v)
def __arg_match_D__(v):
  return isinstance(v,numpy.float64) or isinstance(v,float) or isinstance(v,int) or isinstance(v,numpy.int32) or isinstance(v,numpy.int64)
def __arg_alt_match_D__(v):
  return __arg_match_D__(v)
def __arg_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_alt_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedVariable)
def __arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Term_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Term) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Term_2__(v):
  return __arg_match__3Lmosek_4fusion_4Term_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Term_2__)
def __arg_match_Lmosek_4fusion_4ExprPSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ExprPSDDomain)
def __arg_alt_match_Lmosek_4fusion_4ExprPSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ExprPSDDomain_2__(v)
def __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return v is None or isinstance(v,mosek_fusion_NDSparseArray)
def __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v)
def __arg_match_Lmosek_4fusion_4SliceConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_SliceConstraint)
def __arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4SliceConstraint_2__(v)
def __arg_match_Emosek_4fusion_4ProblemStatus_2__(v):
  return isinstance(v,mosek_fusion_ProblemStatus)
def __arg_alt_match_Emosek_4fusion_4ProblemStatus_2__(v):
  return isinstance(v,mosek_fusion_ProblemStatus)
def __arg_match__3_3D__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3D__(i) for i in v.flatten()])
def __arg_alt_match__3_3D__(v):
  return __arg_match__3_3D__(v) or __arg_match_listof__(v,__arg_alt_match__3D__)
def __arg_match_Lmosek_4fusion_4DJCDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_DJCDomain)
def __arg_alt_match_Lmosek_4fusion_4DJCDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4DJCDomain_2__(v)
def __arg_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelVariable)
def __arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedBlocks)
def __arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v)
def __arg_match__3Lmosek_4fusion_4DJCDomain_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_DJCDomain) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4DJCDomain_2__(v):
  return __arg_match__3Lmosek_4fusion_4DJCDomain_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4DJCDomain_2__)
def __arg_match__3_3Lmosek_4fusion_4Parameter_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Parameter_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Parameter_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Parameter_2__)
def __arg_match_Lmosek_4fusion_4SliceVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SliceVariable)
def __arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SliceVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Expression) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Expression_2__)
def __arg_match_J__(v):
  return isinstance(v,numpy.int64) or isinstance(v,int) or isinstance(v,numpy.int32)
def __arg_alt_match_J__(v):
  return __arg_match_J__(v)
def __arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(v):
  return v is None or isinstance(v,mosek_fusion_DisjunctionTerms)
def __arg_alt_match_Lmosek_4fusion_4DisjunctionTerms_2__(v):
  return __arg_match_Lmosek_4fusion_4DisjunctionTerms_2__(v)
def __arg_match_Lmosek_4fusion_4Constraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_Constraint)
def __arg_alt_match_Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match_Lmosek_4fusion_4Constraint_2__(v)
def __arg_match__3J__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int64))
def __arg_alt_match__3J__(v):
  return __arg_match__3J__(v) or __arg_match_listof__(v,__arg_alt_match_J__)
def __arg_match__3_3J__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3J__(i) for i in v.flatten()])
def __arg_alt_match__3_3J__(v):
  return __arg_match__3_3J__(v) or __arg_match_listof__(v,__arg_alt_match__3J__)
def __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4ExprDomain_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_ExprDomain) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4ExprDomain_2__(v):
  return __arg_match__3Lmosek_4fusion_4ExprDomain_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4ExprDomain_2__)
def __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricMatrix)
def __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v)
def __arg_match__3D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3D__(v):
  return __arg_match__3D__(v) or __arg_match_listof__(v,__arg_alt_match_D__)
def __arg_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicVariable)
def __arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicVariable_2__(v)
def __arg_match__3I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3I__(v):
  return __arg_match__3I__(v) or __arg_match_listof__(v,__arg_alt_match_I__) or isinstance(v,range)
def __arg_match__3_5D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3_5D__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_D__,2)
def __arg_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Model_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Model) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Model_2__(v):
  return __arg_match__3Lmosek_4fusion_4Model_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Model_2__)
def __arg_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangeDomain)
def __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4RangeDomain_2__(v)
def __arg_match_LSystem_4StreamWriter_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4StreamWriter_2__(v):
  return __arg_match_LSystem_4StreamWriter_2__(v)
def __arg_match_Lmosek_4fusion_4RowBlockManager_2__(v):
  return v is None or isinstance(v,mosek_fusion_RowBlockManager)
def __arg_alt_match_Lmosek_4fusion_4RowBlockManager_2__(v):
  return __arg_match_Lmosek_4fusion_4RowBlockManager_2__(v)
def __arg_match_I__(v):
  return isinstance(v,numpy.int32) or isinstance(v,numpy.int64) or isinstance(v,int)
def __arg_alt_match_I__(v):
  return __arg_match_I__(v)
def __arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ExprLinearDomain)
def __arg_alt_match_Lmosek_4fusion_4ExprLinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ExprLinearDomain_2__(v)
def __arg_match__3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == object and all([isinstance(i0,str) for i0 in v ])
def __arg_alt_match__3S__(v):
  return __arg_match__3S__(v) or __arg_match_listof__(v,__arg_alt_match_S__)
def __arg_match_Lmosek_4fusion_4ExprConicDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ExprConicDomain)
def __arg_alt_match_Lmosek_4fusion_4ExprConicDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ExprConicDomain_2__(v)
def __arg_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDDomain)
def __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDDomain_2__(v)
def __arg_match__3_5I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3_5I__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_I__,2)
def __arg_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearDomain)
def __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedInts)
def __arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedInts_2__(v)
def __arg_match_Emosek_4fusion_4DJCDomainType_2__(v):
  return isinstance(v,mosek_fusion_DJCDomainType)
def __arg_alt_match_Emosek_4fusion_4DJCDomainType_2__(v):
  return isinstance(v,mosek_fusion_DJCDomainType)
def __arg_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_alt_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_match_LSystem_4CallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4CallbackHandler_2__(v):
  return __arg_match_LSystem_4CallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Matrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_Matrix)
def __arg_alt_match_Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match_Lmosek_4fusion_4Matrix_2__(v)
def __arg_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_match__3Lmosek_4fusion_4Constraint_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Constraint) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match__3Lmosek_4fusion_4Constraint_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Constraint_2__)
def __arg_match_Lmosek_4fusion_4Parameter_2__(v):
  return v is None or isinstance(v,mosek_fusion_Parameter)
def __arg_alt_match_Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match_Lmosek_4fusion_4Parameter_2__(v)
def __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelConstraint)
def __arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDVariable)
def __arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Term_2__(v):
  return v is None or isinstance(v,mosek_fusion_Term)
def __arg_alt_match_Lmosek_4fusion_4Term_2__(v):
  return __arg_match_Lmosek_4fusion_4Term_2__(v)
def __arg_match__3_3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3S__(i) for i in v.flatten()])
def __arg_alt_match__3_3S__(v):
  return __arg_match__3_3S__(v) or __arg_match_listof__(v,__arg_alt_match__3S__)
def __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return v is None or isinstance(v,mosek_fusion_Utils_StringBuffer)
def __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v)
def __arg_match__3_3I__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3I__(i) for i in v.flatten()])
def __arg_alt_match__3_3I__(v):
  return __arg_match__3_3I__(v) or __arg_match_listof__(v,__arg_alt_match__3I__)
def __arg_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseVariable)
def __arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Model_2__(v):
  return v is None or isinstance(v,mosek_fusion_Model)
def __arg_alt_match_Lmosek_4fusion_4Model_2__(v):
  return __arg_match_Lmosek_4fusion_4Model_2__(v)
def __arg_match_Lmosek_4fusion_4FusionException_2__(v):
  return v is None or isinstance(v,mosek_fusion_FusionException)
def __arg_alt_match_Lmosek_4fusion_4FusionException_2__(v):
  return __arg_match_Lmosek_4fusion_4FusionException_2__(v)
def __arg_match_Lmosek_4fusion_4ExprDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ExprDomain)
def __arg_alt_match_Lmosek_4fusion_4ExprDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ExprDomain_2__(v)
def __arg_match_Lmosek_4fusion_4ParameterImpl_2__(v):
  return v is None or isinstance(v,mosek_fusion_ParameterImpl)
def __arg_alt_match_Lmosek_4fusion_4ParameterImpl_2__(v):
  return __arg_match_Lmosek_4fusion_4ParameterImpl_2__(v)
def __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return v is None or isinstance(v,mosek_fusion_SolutionStruct)
def __arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v)
def __arg_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_alt_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Expression_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Expression_2__)
def __arg_match__3Lmosek_4fusion_4Parameter_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Parameter) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match__3Lmosek_4fusion_4Parameter_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Parameter_2__)
def __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Matrix_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4SimpleTerm_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_SimpleTerm) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4SimpleTerm_2__(v):
  return __arg_match__3Lmosek_4fusion_4SimpleTerm_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__)
def __arg_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_alt_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_match_Lmosek_4fusion_4SimpleTerm_2__(v):
  return v is None or isinstance(v,mosek_fusion_SimpleTerm)
def __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(v):
  return __arg_match_Lmosek_4fusion_4SimpleTerm_2__(v)
def __arg_match_Lmosek_4fusion_4Variable_2__(v):
  return v is None or isinstance(v,mosek_fusion_Variable)
def __arg_alt_match_Lmosek_4fusion_4Variable_2__(v):
  return __arg_match_Lmosek_4fusion_4Variable_2__(v)
def __arg_match_LSystem_4DataCallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataCallbackHandler_2__(v):
  return __arg_match_LSystem_4DataCallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Expression_2__(v):
  return v is None or isinstance(v,mosek_fusion_Expression)
def __arg_alt_match_Lmosek_4fusion_4Expression_2__(v):
  return __arg_match_Lmosek_4fusion_4Expression_2__(v)
def __arg_match_Lmosek_4fusion_4WorkStack_2__(v):
  return v is None or isinstance(v,mosek_fusion_WorkStack)
def __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(v):
  return __arg_match_Lmosek_4fusion_4WorkStack_2__(v)
def __arg_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Variable_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicConstraint)
def __arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Matrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConeDomain)
def __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ConeDomain_2__(v)
def __arg_match_Z__(v):
  return isinstance(v,bool) or isinstance(v,numpy.bool_)
def __arg_alt_match_Z__(v):
  return __arg_match_Z__(v)
def __arg_match_S__(v):
  return isinstance(v,str)
def __arg_alt_match_S__(v):
  return __arg_match_S__(v)
def __arg_match_listof__(v,f): return isinstance(v,list) and all([ f(i) for i in v])
import mosek
import mosek.fusion
import mosek.fusion.Utils
from . import fragments
